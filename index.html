<!DOCTYPE html>
<html lang="zh">
<head>

<meta http-equiv="Content-Security-Policy" content="
default-src 'self'; 
script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://*.streamable.com https://cdn.heapanalytics.comfunction captureContainerH https://www.gstatic.com https://apis.google.com https://cdn.onesignal.com https://onesignal.com https://api.onesignal.com https://*.firebaseio.com; 
style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com https://onesignal.com; 
font-src 'self' https://cdnjs.cloudflare.com https://fonts.gstatic.com;
img-src 'self' https: data: https://*.streamable.com https://heapanalytics.com https://*.googleusercontent.com;
media-src 'self' https://youfulca.com https://*.streamable.com https://assets.mixkit.co https://taira-komori.net;
connect-src 'self' https://v1.hitokoto.cn https://chatapi.akash.network https://text.pollinations.ai https://gen.pollinations.ai https://router.huggingface.co https://api.llm7.io https://*.streamable.com https://cdn.jsdelivr.net https://api-fawn-chi.vercel.app https://heapanalytics.com https://*.firebaseio.com wss://*.firebaseio.com https://www.gstatic.com https://www.googleapis.com https://securetoken.googleapis.com https://identitytoolkit.googleapis.com https://cdn.onesignal.com https://onesignal.com https://onesignal.com/api/v1/notifications https://api.onesignal.com;
frame-src 'self' https://streamable.com https://kenchan20141.pyscriptapps.com https://kenchan20141.github.io https://sansi.vercel.app https://lyricschi.vercel.app https://penpalchi.vercel.app https://litstudy.vercel.app https://621d05f47d591.site123.me https://script.google.com https://www.i2ocr.com https://*.firebaseapp.com https://onesignal.com;
object-src 'none';
base-uri 'self';
form-action 'self';
">

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>神思</title>

<!-- 添加到主畫面設定 -->
<meta name="application-name" content="神思">
<meta name="apple-mobile-web-app-title" content="神思">
<link rel="manifest" href="manifest.json">


<link rel="apple-touch-icon" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">


<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">


<!-- Android 圖示 -->
<link rel="icon" sizes="192x192" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="icon" sizes="144x144" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="icon" sizes="96x96" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<!-- iOS 圖示 -->
<link rel="apple-touch-icon" sizes="180x180" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="apple-touch-icon" sizes="152x152" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="apple-touch-icon" sizes="120x120" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<!-- 引入 Chart.js 以繪製雷達圖 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<!-- 新增這行：Firebase Authentication -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>




	<script>
// === 1. Firebase 初始化 (必須放在最頂部) ===
const firebaseConfig = {
  apiKey: "AIzaSyAdRrg66oVGuhbk1zOpSm5K85DKcQlAOes",
  authDomain: "login-system-2-b511c.firebaseapp.com",
  projectId: "login-system-2-b511c",
  storageBucket: "login-system-2-b511c.firebasestorage.app",
  messagingSenderId: "352631619492",
  appId: "1:352631619492:web:eccee85a46b2c2e3ddcb31",
  databaseURL: "https://login-system-2-b511c-default-rtdb.firebaseio.com" 
};

// 宣告全域變數
let database, auth;

// 確保只初始化一次，並立即賦值
if (typeof firebase !== 'undefined' && !firebase.apps.length) {
    try {
        firebase.initializeApp(firebaseConfig);
        console.log("Firebase 初始化成功！");
        database = firebase.database();
        auth = firebase.auth();
    } catch (e) {
        console.error("Firebase 初始化失敗：", e);
    }
} else if (typeof firebase !== 'undefined' && firebase.apps.length) {
    database = firebase.database();
    auth = firebase.auth();
}
</script>


<!-- === 新增：頁面右緣卡扣按鈕 === -->
<button id="sideMenuToggle" title="展開選單">
    <i class="fas fa-bars"></i>
</button>

<div id="sideMenu" class="side-menu-overlay">
    <div class="side-menu-content">
        <button class="side-menu-close" id="sideMenuClose">&times;</button>
        
      <div class="side-menu-items">
    <!-- 1. 雲端同步 -->
    <button class="side-menu-item" id="sideMenuCloudBtn" onclick="openStudentLoginModal()">
        <i class="fas fa-cloud-upload-alt"></i>
        <span>雲端同步</span>
        <div id="notifBadge" class="notification-badge"></div>
    </button>
		   
    <!-- 2. 歷史紀錄 -->
    <button class="side-menu-item" onclick="openHistoryContainer()">
        <i class="fas fa-history"></i>
        <span>歷史紀錄</span>
    </button>

    <!-- 3. 工具一覽 (已移至歷史紀錄下方) -->
    <button class="side-menu-item" id="sideMenuToolsBtn" onclick="openToolsFromSideMenu()">
        <i class="fas fa-toolbox"></i>
        <span>工具一覽</span>
    </button>

    <!-- 4. 返回主頁 -->
    <button class="side-menu-item" id="sideMenuHomeBtn" onclick="returnToHome()" style="display: none;">
        <i class="fas fa-home"></i>
        <span>返回主頁</span>
    </button>
    
    <!-- 5. 音樂播放器 -->
    <button class="side-menu-item" onclick="toggleMusicPlayer()">
        <i class="fas fa-music"></i>
        <span>音樂播放器</span>
    </button>
</div>
    </div>
</div>



<!-- === 新增：返回主頁按鈕 === -->
<button id="homeBtn" onclick="returnToHome()" title="返回主頁">
    <i class="fas fa-home"></i>
</button>


<!-- OneSignal SDK -->
<!-- OneSignal SDK -->
<script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
<script>
  window.OneSignalDeferred = window.OneSignalDeferred || [];

  window.addEventListener('load', async function() {
    OneSignalDeferred.push(async function(OneSignal) {
      try {
        await OneSignal.init({
          appId: "f85da4b8-abae-4c5e-8db9-c9f463fc9815",
          
          // === 關鍵修正：移除動態時間戳，避免每次產生新的 Worker ===
          serviceWorkerPath: "OneSignalSDKWorker.js",
          
          // 確保 Scope 正確
          serviceWorkerParam: { scope: "/AIChinese/" },

          allowLocalhostAsSecureOrigin: true,
          notifyButton: { enable: false } 
        });
        
        console.log("OneSignal 初始化成功 (修正版)！");

        // === 標籤設定 (保留你的邏輯) ===
        const s = JSON.parse(localStorage.getItem('studentProfile'));
        if (s) {
            // 延遲一點點確保 User ID 已建立
            setTimeout(() => {
                OneSignal.User.addTags({ 
                    grade: String(s.grade), 
                    class: String(s.class), 
                    userType: 'student' 
                });
                console.log("標籤已更新");
            }, 1000);
        }

      } catch (err) {
        console.error("OneSignal 初始化失敗:", err);
      }
    });
  });
</script>
	
<style>
/* === 全局基礎設定 === */
body {
    font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background: url('背景.png') center/cover fixed;
    padding-bottom: 60px; /* 為頁面內容設置底部內邊距，避免被音樂播放器遮擋 */
    transition: background-image 0.6s ease-in-out, background-color 0.6s ease-in-out;
}

h1 {
    text-align: center;
    color: #333;
}

/* === 返回主頁按鈕樣式 === */
#homeBtn {
    position: fixed;
    top: 20px;
    left: 20px; /* 左上角 */
    z-index: 9999;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.6); /* 半透明黑底 */
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.5);
    font-size: 24px;
    cursor: pointer;
    display: none; /* 預設隱藏 */
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

#homeBtn:hover {
    background-color: rgba(0, 0, 0, 0.8);
    transform: scale(1.1);
    border-color: #fff;
}

/* === 通用容器與佈局 === */
.box {
    background: rgba(220, 220, 220, 0.96);
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    padding: 20px;
    margin: 15px 0;
}

.category {
    margin-bottom: 20px;
}

.category h3 {
    font-size: 18px;
    margin-bottom: 10px;
    color: #fff; /* 白色文字，適配深色背景 */
    text-align: left;
}

/* 手機設備調整 */
@media (max-width: 600px) {
    .category {
        padding-left: 25px; /* 增加左內邊距，讓按鍵遠離左邊緣 */
    }

    #toolsList button {
        width: auto; /* 寬度自適應文字內容 */
        display: inline-block; /* 按鈕以行內塊元素顯示，配合置中 */
        margin: 10px 0; /* 調整為上下 10px，左右 0px，避免額外水平間距 */
        font-size: 14px; /* 保留字體大小 */
        padding: 8px 16px; /* 保留內邊距，提供適當空間 */
    }

    .category h3 {
        font-size: 16px; /* 保留標題字體大小 */
    }
}

.copyright-footer {
    position: fixed;
    bottom: 0;
    right: 0;
    padding: 5px 10px;
    background-color: #f1f1f1;
}

.copyright-footer p {
    margin: 0;
    font-size: 14px;
}

@media (max-width: 600px) {
    .copyright-footer p {
        font-size: 12px;
    }
}

/* === 背景動畫效果 === */
/* 晴天效果：太陽 */
.sun {
    position: absolute;
    top: 10%;
    left: 5%; /* 調整為靠左 */
    width: 100px;
    height: 100px;
    background-color: yellow;
    border-radius: 50%;
    box-shadow: 0 0 20px yellow;
    animation: sunGlow 2s infinite alternate;
    z-index: -1; /* 確保太陽在其他元素下方，避免遮擋按鍵 */
}

/* 平板設備調整 */
@media (max-width: 768px) {
    .sun {
        left: 5%;
        top: 5%;
        width: 100px;
        height: 100px;
    }
}

/* 手機設備調整 */
@media (max-width: 480px) {
    .sun {
        left: 2%;
        top: 2%;
        width: 80px;
        height: 80px;
    }
}

/* 太陽光芒動畫 */
@keyframes sunGlow {
    0% { box-shadow: 0 0 20px yellow; }
    100% { box-shadow: 0 0 40px yellow; }
}

/* 多雲效果：雲朵 */
.cloud {
    position: absolute;
    background-color: white;
    border-radius: 50%;
    opacity: 0.8;
    animation: cloudMove linear infinite;
}

@keyframes cloudMove {
    0% { transform: translateX(-100vw); }
    100% { transform: translateX(100vw); }
}

/* 下雨效果：雨滴 */
.raindrop {
    position: absolute;
    width: 2px;
    height: 10px;
    background-color: #ADD8E6; /* 淺藍色，更自然 */
    opacity: 0.7; /* 增加透明度 */
    animation: rainFall linear infinite;
}

@keyframes rainFall {
    0% { transform: translateY(-10px); }
    100% { transform: translateY(100vh); }
}

/* 下雪效果：雪花 */
.snowflake {
    position: absolute;
    background-color: #e0f7fa;
    border-radius: 50%;
    opacity: 0.7;
    animation: snowfall linear infinite;
}

@keyframes snowfall {
    0% { top: -10px; transform: translateX(0); }
    50% { transform: translateX(20px); }
    100% { top: 100vh; transform: translateX(0); }
}

/* === 標題樣式 === */
.title-container {
    background: none;
    padding: 0;
    position: relative;
    margin-bottom: 3rem;
    text-align: center;
}

.title-text {
    display: block;
    font-size: 3rem;
    color: #d1f2eb;
    text-shadow: 3px 3px 0 #7f8c8d;
    letter-spacing: 4px;
    animation: titleFloat 3s ease-in-out infinite;
}

/* === 按鈕基礎樣式 === */
button {
    background: #007bff;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s;
    margin: 5px;
}

button:hover {
    background: #0056b3;
}

.save-btn { background: #28a745; }
.save-btn:hover { background: #218838; }
.clear-btn { background: #dc3545; }
.clear-btn:hover { background: #c82333; }

/* === 表單輸入框美化 === */
/* === 表單輸入框美化 (已加入 password 支援) === */
select, textarea, input[type="text"], input[type="password"] {
    width: 100%;
    padding: 12px 15px;
    margin: 10px 0;
    border: 1px solid #dcdfe6;
    border-radius: 8px;
    box-sizing: border-box;
    background-color: #fcfdfd;
    font-size: 1.3em;
    color: #333;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    font-family: 'Noto Serif TC', serif; /* 確保字體一致 */
}

select:focus, textarea:focus, input[type="text"]:focus, input[type="password"]:focus {
    outline: none;
    border-color: #4A90E2;
    box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
}

textarea {
    resize: vertical;
    min-height: 80px; /* 設定最小高度 */
}

/* === 表格樣式 === */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
}

th, td {
    border: 1px solid #ccc;
    padding: 10px;
    text-align: left;
    vertical-align: top;
    word-break: break-word;
}

th {
    background: #f0f0f0;
}

.table-container {
    overflow-x: auto;
    width: 100%;
}

.table-container table {
    width: 100%;
    border-collapse: collapse;
}

.table-container th, .table-container td {
    border: 1px solid #ccc;
    padding: 10px;
    text-align: left;
    vertical-align: top;
    word-break: break-word;
}

.table-container th:first-child, .table-container td:first-child { width: 60px; }
.table-container th:nth-child(2), .table-container td:nth-child(2),
.table-container th:nth-child(3), .table-container td:nth-child(3) { min-width: 100px; }
.table-container th:nth-child(4), .table-container td:nth-child(4),
.table-container th:nth-child(5), .table-container td:nth-child(5) { min-width: 150px; }

/* === 動畫 === */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.tool-btn {
    animation: fadeIn 0.2s ease-in-out forwards;
    opacity: 0;
}

/* === 範疇按鍵樣式 === */
.category-buttons-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center; /* 讓按鈕在容器內居中 */
}

.btn-category {
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    background-color: rgba(142, 142, 147, 0.7); /* 半透明灰色 */
    color: white;
    backdrop-filter: blur(5px);
    margin: 0; /* 重置 margin */
}

.btn-category:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(115%);
}

.btn-category.active {
    filter: brightness(115%);
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 0 4px 12px rgba(0,0,0,0.25);
    transform: translateY(-2px);
}

/* Specific active colors */
#readingBtn.active { background-color: #28a745; }
#writingBtn.active { background-color: #007bff; }
#argumentBtn.active { background-color: #800080; }
#expandBtn.active { background-color: #dc3545; }
#booksBtn.active { background-color: #ffc107; }

/* Apply to the expand button as well */
#expandToolsBtn2 {
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    color: white;
    background-color: rgba(54, 187, 167, 0.8);
    backdrop-filter: blur(5px);
display: none; /* 新增這行 */
}

#expandToolsBtn2:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}

/* === 工具列表 === */
#toolsContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    overflow: hidden; /* 隱藏頁面滾動條 */
}

#toolsList {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    max-height: 80vh; /* 設置最大高度 */
    overflow-y: auto; /* 啟用垂直滾動條 */
    position: relative; /* 保持相對定位於容器內 */
}

#toolsList button {
    opacity: 0;
    margin: 10px 0;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#closeToolsBtn {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: #dc3545;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
}

#commentResult {
    width: 100%;
    overflow-wrap: break-word;
}

#toggleOverviewBtn {
    background-color: #A9A9A9; /* 灰色背景 */
    color: white; /* 白色文字 */
}

#toggleOverviewBtn:hover {
    background-color: #808080; /* 懸停時深灰色 */
}

#manuscriptPaperBtn {
    background-color: #17a2b8;
}
#manuscriptPaperBtn:hover {
    background-color: #138496;
}

#writingContainer, #readingContainer, #booksContainer, #expandContainer, #argumentContainer {
    display: none;
}
#argumentTopicSelectionArea, #argumentCustomTopicArea, #argumentWritingArea, #argumentGuideArea {
    margin-top: 10px;
}

/* === 音樂播放器樣式優化 === */
#music-player {
    position: fixed;
    bottom: 0px;
    left: 0;
    width: 100%;
    background-color: rgba(40, 40, 40, 0.95); /* 深色半透明背景 */
    backdrop-filter: blur(5px);
    color: white;
    padding: 10px 15px;
    display: none; /* 預設隱藏 */
    align-items: center;
    justify-content: space-between;
    z-index: 1002;
    box-sizing: border-box;
    font-size: 14px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 -4px 10px rgba(0,0,0,0.3);
}

#music-player .controls { 
    display: flex; 
    align-items: center; 
    flex-shrink: 0; 
    gap: 10px;
}

/* 播放按鈕樣式 */
#music-player .controls button#play-pause {
    background: none;
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 50%;
    color: white;
    font-size: 14px;
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    margin: 0; /* 重置 margin */
}

#music-player .controls button#play-pause:hover {
    background-color: white;
    color: #333;
    border-color: white;
    transform: scale(1.1);
}

#music-player .controls select { 
    background: #555; 
    color: white; 
    border: none; 
    padding: 6px 10px; 
    border-radius: 4px; 
    max-width: 150px; 
    cursor: pointer;
}

#music-player .progress { 
    flex: 1; 
    margin: 0 15px; 
    display: flex; 
    align-items: center; 
}
#music-player .progress input[type="range"] { 
    width: 100%; 
    cursor: pointer;
}

#music-player .mode { 
    margin-left: 10px; 
    flex-shrink: 0; 
}
#music-player .mode select { 
    background: #555; 
    color: white; 
    border: none; 
    padding: 6px 10px; 
    border-radius: 4px; 
    cursor: pointer;
}

/* 隱藏 (箭頭) 按鈕樣式 */
#music-player .hide-btn { 
    background: none; 
    border: none; 
    color: #aaa; 
    font-size: 18px; 
    cursor: pointer; 
    margin-left: 15px; 
    transition: color 0.3s;
    padding: 5px;
}
#music-player .hide-btn:hover {
    color: white;
    transform: translateY(2px);
}

/* 懸浮顯示按鈕 (替代原本的鋼琴 Emoji) */
#show-player {
    position: fixed;
    bottom: 25px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: rgba(30, 30, 30, 0.9);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.2);
    cursor: pointer;
    z-index: 1003;
    font-size: 20px;
    display: none; /* JS 會控制顯示 */
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    backdrop-filter: blur(5px);
    padding: 0;
}

#show-player:hover {
    transform: scale(1.15) rotate(15deg);
    background-color: #007bff; /* 懸停變藍色 */
    border-color: white;
    box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
}

@media (max-width: 600px) {
    #music-player { flex-wrap: wrap; padding: 5px; }
    #music-player .controls select { max-width: 100px; font-size: 12px; }
    #music-player .mode select { font-size: 12px; }
    #progress-bar-music {
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
        background: #ddd;
        border-radius: 5px;
    }
    #progress-bar-music::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    #progress-bar-music::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #007bff;
        border-radius: 50%;
        cursor: pointer;
    }
    #music-player .controls select, #music-player .mode select { max-width: 80px; padding: 3px; font-size: 12px; }
    #music-player .controls button, #music-player .hide-btn { padding: 5px; font-size: 16px; }
}

/* --- Styles for Tool 2 (語薈) --- */
:root {
    --bg-color: #f5f5f3;
    --text-color: #333;
    --primary-color: #6a7a7d;
    --secondary-color: #8f8f8f;
    --accent-color: #8c9ea1;
    --line-color: #c5c5c5;
    --shadow-color: rgba(0, 0, 0, 0.05);
    --highlight-bg-writing: rgba(230, 240, 245, 0.6);
    --highlight-bg-reading: rgba(245, 240, 230, 0.6);
    --font-main: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
}

#toolsContainer2 {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bg-color);
    z-index: 1005;
    overflow-y: auto;
    display: none;
    padding: 2rem 1rem;
    box-sizing: border-box;
    justify-content: center;
}

#closeToolsBtn2 {
    position: fixed;
    top: 15px;
    right: 25px;
    background-color: transparent;
    border: none;
    font-size: 2.5rem;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    z-index: 1006;
    line-height: 1;
    padding: 5px 10px;
}

#closeToolsBtn2:hover { color: #d32f2f; }

.main-container {
    max-width: 1200px;
    width: 100%;
    position: relative;
    opacity: 0;
    transition: opacity 0.5s ease-in;
}

.main-container.loaded { opacity: 1; }

.floating-header {
    position: fixed;
    top: 15px;
    left: 20px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(8px);
    padding: 5px 15px;
    border-radius: 30px;
    border: 1px solid #e0e0e0;
    z-index: 1000;
    box-shadow: 0 2px 10px var(--shadow-color);
    display: flex;
    align-items: center;
    gap: 10px;
}

#video-tour-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
}

#video-tour-btn .icon {
    width: 24px;
    height: 24px;
    fill: var(--primary-color);
    transition: fill 0.3s;
}

#video-tour-btn:hover .icon { fill: var(--accent-color); }

.floating-header h1 {
    font-size: 1.2rem;
    margin: 0;
    font-weight: 700;
    color: var(--primary-color);
}

.mind-map-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto 1fr auto;
    grid-template-areas:
    "core-ai core-ai"
    "foundations foundations"
    "writing reading"
    "assignments support";
    gap: 50px 20px;
    width: 100%;
    margin-top: 80px;
    padding-bottom: 50px;
    position: relative;
}

.node {
    display: flex;
    align-items: center;
    text-align: center;
    padding: 8px 12px;
    background-color: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-shadow: 0 3px 12px var(--shadow-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
}

.node:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    border-color: var(--accent-color);
}

.node a {
    text-decoration: none;
    color: inherit;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 0.95rem;
    gap: 8px;
    width: 100%;
}

.node .icon {
    width: 24px;
    height: 24px;
    margin-right: 0;
    fill: var(--primary-color);
}

#toolsContainer2 .category {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin-bottom: 0; /* Reset margin for this context */
}

#writing, #reading {
    padding: 20px;
    border-radius: 12px;
}
#writing { background-color: var(--highlight-bg-writing); }
#reading { background-color: var(--highlight-bg-reading); }

.category-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--primary-color);
    padding-bottom: 5px;
    border-bottom: 2px solid var(--accent-color);
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.category-title .icon {
    width: 24px;
    height: 24px;
    margin-right: 8px;
    fill: var(--primary-color);
}

.sub-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    width: 100%;
}

.sub-group-title {
    font-weight: bold;
    color: var(--secondary-color);
    font-size: 0.9rem;
    position: relative;
    padding-bottom: 5px;
    margin-bottom: 5px;
}
.sub-group-title::after{
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 1px;
    background-color: var(--line-color);
}

.node.level-2 { font-size: 0.9rem; }
.node.level-3 { font-size: 0.85rem; padding: 6px 10px; }
.node.level-3 a { font-weight: 400; flex-direction: row; }

/* Grid Area Assignments */
#core-ai { grid-area: core-ai; }
#foundations {
    grid-area: foundations;
    display: flex;
    flex-direction: row;
    justify-content: center;
    gap: 500px;
    align-items: flex-start;
}
#writing { grid-area: writing; }
#reading { grid-area: reading; }
#assignments { grid-area: assignments; }
#support { grid-area: support; }

.connector-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;
}

.connector-svg line {
    stroke: var(--line-color);
    stroke-width: 1.5;
    stroke-dasharray: 4;
    animation: dash 1s linear infinite;
}

@keyframes dash {
    to { stroke-dashoffset: -20; }
}

#yuyilu-toggle { cursor: pointer; }
.yuyilu-grades {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    max-height: 500px;
    overflow: hidden;
    transition: max-height 0.5s ease-in-out, opacity 0.3s ease-in-out;
    opacity: 1;
}
.yuyilu-grades.collapsed {
    max-height: 0;
    opacity: 0;
    pointer-events: none;
}

.foundation-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

@media (max-width: 768px) {
    #toolsContainer2 { padding: 1rem 0.5rem; }
    .floating-header { top: 10px; left: 10px; }

    .mind-map-container {
        margin-top: 70px;
        grid-template-columns: 1fr;
        grid-template-rows: auto;
        grid-template-areas:
        "core-ai"
        "foundations"
        "writing"
        "reading"
        "assignments"
        "support";
        gap: 40px;
    }

    #foundations {
        flex-direction: row;
        justify-content: space-between;
        align-items: flex-start;
        width: 90%;
        margin: 0 auto;
        gap: 10px;
    }

    #writing, #reading { padding: 15px; }
}

/* --- Preview Modal Styles --- */
.preview-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    z-index: 2000;
    padding: 1rem;
    box-sizing: border-box;
}

.preview-modal-content {
    background-color: #fff;
    border-radius: 12px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.2);
    width: 90%;
    height: 90%;
    max-width: 1000px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
}

.preview-close-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.7);
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    font-size: 1.5rem;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s, color 0.3s;
    z-index: 2010;
}
.preview-close-btn:hover {
    color: #fff;
    background-color: #d32f2f;
}

.preview-modal-body {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
}

#previewIframe {
    width: 100%;
    flex-grow: 1; /* 佔據大部分空間 */
    border: none;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    min-height: 60%; /* 確保預覽畫面有足夠高度 */
}

.preview-modal-footer {
    padding: 16px;
    background-color: #f7f9fa;
    border-top: 1px solid #e0e0e0;
    display: flex;
    align-items: flex-start;
    gap: 16px;
    overflow-y: auto;
    max-height: 40%;
    flex-shrink: 0;
}

.preview-description {
    font-size: 0.95rem;
    color: #333;
    line-height: 1.6;
    text-align: left;
    flex-grow: 1;
}

.preview-goto-btn {
    background: #007bff url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z'/%3E%3C/svg%3E") no-repeat 15px center;
    background-size: 18px 18px;
    color: white;
    padding: 10px 20px 10px 40px;
    border: none;
    border-radius: 20px;
    text-decoration: none;
    font-size: 1rem;
    font-weight: bold;
    transition: background-color 0.3s;
    cursor: pointer;
    flex-shrink: 0; /* 防止按鈕縮小 */
}
.preview-goto-btn:hover {
    background-color: #0056b3;
    color: white;
}

@media (max-width: 600px) {
    .preview-modal-footer {
        flex-direction: column;
        align-items: stretch;
    }
    .preview-goto-btn {
        align-self: flex-end; /* 在堆疊時仍將按鈕靠右 */
    }
}

/* --- Video Modal Styles --- */
.video-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    z-index: 2100;
    cursor: pointer;
}

.video-modal-content {
    position: relative;
    width: 90%;
    max-width: 960px;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    height: 0;
    cursor: default;
}

.video-modal-content iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: none;
}

/* --- 功能選擇與間距 --- */
.function-selector-wrapper {
    padding: 20px; /* 增加內邊距，讓內部元素有更多呼吸空間 */
    background-color: rgba(59, 184, 219, 0.2);
    border-left: 5px solid #0288d1;
    margin-top: 30px;
    margin-bottom: 35px; /* 明顯增加與下方內容的間距 */
    border-radius: 8px; /* 圓角稍大，視覺上更柔和 */
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.function-selector-wrapper label {
    font-size: 1.1em; /* 標題字體稍大，更突出 */
    font-weight: bold;
    color: #01579b;
    display: block;
    margin-bottom: 15px; /* 增加與下拉選單的間距 */
}
.function-selector-wrapper select {
    font-size: 1em; /* 統一下拉選單字體大小 */
    padding: 8px; /* 適度增加下拉選單的內邊距 */
}

/* 為各個功能容器內的主要區塊（div）增加統一的下間距 */
#writingContentContainer > div,
#expandContentContainer > div,
#argumentContentContainer > div {
    margin-bottom: 30px;
}

/* 清除最後一個元素的下邊距 */
#writingContentContainer > div:last-child,
#expandContentContainer > div:last-child,
#argumentContentContainer > div:last-child {
    margin-bottom: 0;
}

/* 針對閱讀區塊，其內部結構不同，單獨調整其子元素的間距 */
#readingInputArea > *:not(div#readingResult) {
    margin-bottom: 20px;
}

/* --- 改寫說明 UI --- */
.rewrite-explanation-container { margin-top: 20px; }
.rewrite-explanation-card {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.04);
}
.rewrite-explanation-card h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #343a40;
    font-size: 1.2em;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 10px;
}
.explanation-point {
    display: flex;
    align-items: flex-start;
    margin-bottom: 15px;
}
.explanation-point:last-child { margin-bottom: 0; }
.explanation-number {
    flex-shrink: 0;
    width: 28px;
    height: 28px;
     background-color: #6996b8 !important; 
box-shadow: 0 2px 5px rgba(0,0,0,0.15) !important;
    color: white;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    margin-right: 15px;
    font-size: 1em;
}
.explanation-text {
    font-size: 1em;
    line-height: 1.6;
    color: #495057;
}

/* --- 點評語氣標籤 --- */
.tone-selector-label {
    display: block; /* 確保標籤獨佔一行 */
    margin-top: 25px; /* 增加與上方元素的距離 */
}

/* --- 題目顯示區塊樣式 --- */
#topicResult, #argumentTopicResult, #expandTopicResult {
    position: relative;
    padding: 12px 15px;
    margin-bottom: 20px;
    border-left: 5px solid #2A9689;
    border-radius: 4px;
    font-size: 1em;
    display: none;
    background-color: transparent !important; /* 強制容器本身透明 */
    z-index: 0;
}

#topicResult::before,
#argumentTopicResult::before,
#expandTopicResult::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(54, 187, 167, 0.5); /* 半透明背景 */
    border-radius: inherit;
    z-index: -1;
}

#topicResult td, #argumentTopicResult td, #expandTopicResult td { background-color: #ffffff !important; }
#topicResult th, #argumentTopicResult th, #expandTopicResult th { background-color: #f0f0f0 !important; }
#topicResult:not(:empty), #argumentTopicResult:not(:empty), #expandTopicResult:not(:empty) { display: block; }

#topicSelectionArea > label,
#argumentTopicSelectionArea > label,
#expandTopicSelectionArea > label {
    display: block;
    margin-bottom: 10px;
}

/* --- 按鍵美化修訂 --- */
.topic-buttons-container {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-top: 10px;
}

.btn {
    padding: 8px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    color: white;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    border: 3px solid transparent;
    background-color: #8E8E93; /* 中性灰 */
}

.btn:not(.active):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}

.btn-generate.active { background-color: #4A90E2; }
.btn-custom.active { background-color: #7B68EE; }

.btn.active {
    filter: brightness(115%);
    border: 3px solid white;
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
    transform: translateY(-2px);
}

.btn .fas { font-size: 15px; }

/* --- 剩餘字數計數器 --- */
#charCount {
    margin-top: 0px;
    margin-bottom: 20px;
    text-align: right;
    font-size: 0.9em;
    color: #666;
}

/* --- 禁用按鈕樣式 --- */
button:disabled, .btn:disabled, .btn-icon-confirm:disabled, .btn-action:disabled {
    background-color: #cccccc !important;
    border-color: #cccccc !important;
    color: #666666;
    cursor: not-allowed;
    opacity: 0.6;
    box-shadow: none;
    transform: none;
}

/* --- 儲存/清除圖示按鍵 --- */
.action-buttons-container {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    margin-top: 10px;
    align-items: center;
}

.btn-add-icon { background-color: rgba(0, 123, 255, 0.8); }

.btn-icon-action {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: none;
    color: white;
    font-size: 16px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    transition: all 0.2s ease-in-out;
    margin: 0;
}

.btn-icon-action:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    filter: brightness(110%);
}

.btn-icon-action:active { transform: translateY(0); }
.btn-save-icon { background-color: rgba(26, 117, 149, 0.8); }
.btn-clear-icon { background-color: rgba(220, 53, 69, 0.8); }

/* --- 確認圖示按鍵 --- */
.btn-icon-confirm {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background-color: #28a745;
    border: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease-in-out;
}

.btn-icon-confirm:hover {
    transform: scale(1.1);
    filter: brightness(110%);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn-icon-confirm:active { transform: scale(1.15); }

/* ========================================= */
/* === [修訂 V2] 書籍討論資訊卡片優化 === */
/* ========================================= */
.discussion-info {
    text-align: left;
    background-color: #fdfcf8;
    border: 2px solid #e0ddd7;
    color: #495057;
    padding: 20px;
    border-radius: 12px;
    margin: 10px auto 30px auto;
    
    /* [電腦端修正] 行距由 2.0 減為 1.5，讓視覺更緊湊 */
    line-height: 1.5; 
    
    width: 100%;
    box-sizing: border-box;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    font-family: 'Noto Serif TC', serif;
}

/* 表格佈局 */
.discussion-info table {
    width: 100%;
    border-collapse: collapse;
    /* 移除 table-layout: fixed，讓欄位寬度根據內容自然調整，避免浪費空間 */
    table-layout: auto; 
}

.discussion-info td {
    border: none;
    
    /* [電腦端修正] 上下內距由 10px 減半為 5px */
    padding: 5px 8px; 
    
    vertical-align: top; /* 保持靠上對齊 */
    word-wrap: break-word;
    overflow-wrap: break-word;
    font-size: 1.1rem;
}

/* 標籤欄位 (左側：書名、作者...) */
.discussion-info td:first-child {
    width: 60px; /* 稍微縮窄標籤欄寬度 */
    font-weight: bold;
    color: #2A9689;
    white-space: nowrap;
    
    /* [電腦端保持] 讓「書名」二字左右對齊，比較美觀 */
    text-align: justify;
    text-align-last: justify; 
}

/* ========================================= */
/* === [手機版專用修復] === */
/* ========================================= */
@media (max-width: 600px) {
    .discussion-info {
        padding: 15px; /* 手機版內距縮小 */
    }

    .discussion-info table, 
    .discussion-info tbody, 
    .discussion-info tr, 
    .discussion-info td {
        display: block; /* 強制變成垂直排列 */
        width: 100% !important;
        box-sizing: border-box;
    }

    /* 1. 修復手機標籤文字被拉寬的問題 */
    .discussion-info td:first-child {
        text-align: left !important;      /* [關鍵修正] 強制靠左，取消左右對齊 */
        text-align-last: auto !important; /* [關鍵修正] 重置末行對齊 */
        
        color: #007bff; /* 藍色標籤 */
        font-size: 0.95rem;
        
        /* 讓標籤和內容靠得更近 */
        padding-bottom: 2px; 
        padding-top: 10px;
        margin-bottom: 0;
        border-bottom: none; /* 移除分隔線，讓視覺更連貫 */
    }

    /* 2. 內容部分 (書名本體) */
    .discussion-info td:last-child {
        padding-top: 0;
        padding-bottom: 10px; /* 每個欄位之間的距離 */
        padding-left: 0;
        border-bottom: 1px dashed #eee; /* 在內容下方加分隔線 */
    }

    /* 最後一個欄位不需要底線 */
    .discussion-info tr:last-child td:last-child {
        border-bottom: none;
        padding-bottom: 0;
    }
}

/* ========================================= */
/* === [修訂] 聊天氣泡排版優化 === */
/* ========================================= */

/* 聊天歷史容器 */
#chatHistory, #writingChatHistory, #argumentChatHistory, #writingGuideChatHistory {
    background-color: #f4f6f9; /* 更柔和的背景色 */
    border: 1px solid #e1e4e8;
    border-radius: 15px;
    padding: 25px 20px; /* 增加內部空間 */
    margin-top: 15px;
    margin-bottom: 15px;
    max-height: 500px; /* 增加高度 */
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px; /* 關鍵：氣泡之間的間距 */
}

/* 單個氣泡 */
.message-bubble {
    padding: 18px 22px; /* 增加氣泡內白，文字不貼邊 */
    border-radius: 18px;
    line-height: 1.8; /* 關鍵：增加行距，文字不再緊湊 */
    font-size: 1.05rem; /* 字體微調大 */
    word-wrap: break-word;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    max-width: 88%; /* 稍微放寬最大寬度 */
    animation: fadeIn 0.3s ease-in-out;
    position: relative;
}

/* AI 氣泡 (左側) */
.message-bubble.ai-message {
    background-color: #ffffff;
    color: #333;
    align-self: flex-start;
    border-top-left-radius: 4px;
    border: 1px solid #e0e0e0;
}

/* 用戶氣泡 (右側) */
.message-bubble.user-message {
    background-color: #2A9689; /* 主題綠 */
    color: white;
    align-self: flex-end;
    border-top-right-radius: 4px;
    box-shadow: 0 4px 10px rgba(42, 150, 137, 0.2);
}

/* 手機版氣泡微調 */
@media (max-width: 600px) {
    .message-bubble {
        padding: 15px;
        font-size: 1rem;
        max-width: 92%; /* 手機上氣泡可以更寬一點 */
    }
}

#chatInputContainer, #writingChatInputContainer, #argumentChatInputContainer, #writingGuideChatInputContainer {
    display: none;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}

#chatInputContainer textarea, #writingChatInputContainer textarea, #argumentChatInputContainer textarea, #writingGuideChatInputContainer textarea {
    flex-grow: 1;
    margin: 0;
}

#initialDiscussionForm { display: block; }

.books-modal {
    display: none;
    position: fixed;
    z-index: 1010;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.6);
    justify-content: center;
    align-items: center;
}

.books-modal .modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 25px;
    border: 1px solid #888;
    width: 90%;
    max-width: 500px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    position: relative;
    animation: fadeIn 0.4s;
}

.books-modal .close-modal-btn {
    color: #aaa;
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}
.books-modal .close-modal-btn:hover { color: black; }
#discussionControlButtons { margin-bottom: 20px; }
#booksButtons { display: none; }

/* --- 執行動作按鈕 --- */
.btn-action {
    display: inline-block;
    padding: 10px 20px;
    margin: 15px 0 5px 0;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
    transition: all 0.3s ease;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    color: white;
    background-color: rgba(31, 122, 85, 0.8);
    backdrop-filter: blur(5px);
    text-align: center;
    text-decoration: none;
}

.btn-action:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    filter: brightness(110%);
}

/* --- 懸浮視窗編輯器 --- */
textarea:not(.no-modal-editor), input[type="text"]:not(.no-modal-editor) {
    cursor: pointer;
    background-color: #f0f8ff;
    transition: background-color 0.2s;
}

textarea:not(.no-modal-editor):hover, input[type="text"]:not(.no-modal-editor):hover {
    background-color: #e6f2ff;
}

.outline-modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.65);
    z-index: 2000;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    box-sizing: border-box;
}

/* === 懸浮視窗容器設定 (修訂版：限制高度防止爆版) === */
.outline-modal-content {
    background-color: #fdfdfd;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    width: 90%;
    max-width: 900px;       /* 稍微加寬，讓電腦版視野更好 */
    max-height: 90vh;       /* 關鍵：限制高度最多佔螢幕 90% */
    position: relative;
    animation: fadeIn 0.3s;
    display: flex;          /* 使用 Flexbox 排版 */
    flex-direction: column; /* 垂直排列子元素 */
    box-sizing: border-box; /* 確保 padding 不會撐大寬度 */
}

.outline-modal-content h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #2A9689;
    font-size: 1.2em;
    font-weight: 700;
    border-bottom: 2px dashed #a8dad5;
    padding-bottom: 12px;
    text-align: center;
    letter-spacing: 2px;
    flex-shrink: 0;         /* 防止標題被壓縮 */
}

/* === 懸浮視窗輸入框設定 (修訂版：自動填滿空間) === */
#modal-textarea {
    width: 100%;
    box-sizing: border-box !important;
    
    /* 字體與原稿紙設定 (保持不變) */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 20px !important;       
    line-height: 40px !important;     
    color: #2c3e50;                   
    letter-spacing: 2px;              
    background-color: #fffcf6;        
    background-image: 
        linear-gradient(transparent 39px, rgba(42, 150, 137, 0.3) 39px, rgba(42, 150, 137, 0.3) 40px, transparent 40px),
        linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.03) 39px, rgba(0,0,0,0.03) 40px, transparent 40px);
    background-size: 40px 40px;       
    background-attachment: local;     
    border: 2px solid #8baea8;        
    border-radius: 8px;               
    padding: 0 18px !important;       
    box-shadow: inset 0 0 40px rgba(0,0,0,0.02);

    /* === 關鍵修訂：高度控制 === */
    flex-grow: 1;           /* 自動填滿視窗剩餘高度 */
    height: auto;           /* 讓 flex 控制高度 */
    min-height: 200px;      /* 設定最小高度 */
    resize: none;           /* 禁止手動拉伸，避免破壞佈局 */
    overflow-y: auto;       /* 內容過多時，只有輸入框內部會滾動 */
    margin-bottom: 10px;
}

/* 手機版適配 (保持不變，但需確保優先級) */
@media (max-width: 600px) {
    #modal-textarea {
        font-size: 16px !important;
        line-height: 32px !important;
        background-image: 
            linear-gradient(transparent 31px, rgba(42, 150, 137, 0.3) 31px, rgba(42, 150, 137, 0.3) 32px, transparent 32px),
            linear-gradient(90deg, transparent 31px, rgba(0,0,0,0.03) 31px, rgba(0,0,0,0.03) 32px, transparent 32px);
        background-size: 32px 32px !important;
        padding: 0 10px !important;
    }
}

.outline-modal-content .modal-buttons { 
    text-align: right; 
    margin-top: 5px; 
    flex-shrink: 0;         /* 防止按鈕被壓縮 */
}

.outline-modal-content .modal-buttons { text-align: right; margin-top: 15px; }
.outline-modal-content .preview-close-btn { position: absolute; top: 10px; right: 10px; }

#structure, #writingTone, #writingReviewer, #readingTone, #booksTone, #expandTone, #argumentOutlineTone, #argumentWritingTone, #argumentReviewer {
    font-size: 1.05em;
    padding: 6px 10px;
}

#booksContainer #initialDiscussionForm input[type="text"],
#booksContainer #initialDiscussionForm textarea {
    font-size: 1rem !important;
    padding: 10px 12px;
}

/* --- 答題步驟卡片 --- */
.steps-container {
    margin-top: 20px;
    padding-left: 15px;
    border-left: 4px solid #4A90E2;
}

.step-card {
    background-color: #f7f9fc;
    border-radius: 8px;
    padding: 15px 20px;
    margin-bottom: 20px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.step-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
}

.step-card:last-child { margin-bottom: 0; }
.step-title {
    font-weight: bold;
    font-size: 1.1em;
    color: #0056b3;
    margin-bottom: 10px;
}
.step-content {
    font-size: 1em;
    line-height: 1.7;
    color: #333;
}

#customTopicArea input[type="text"], #customTopicArea textarea, #argumentCustomTopicArea input[type="text"], #expandCustomTopicInputArea input[type="text"], #expandCustomTopicInputArea textarea, #expandGuideArea input[type="text"], #expandGuideArea textarea {
    font-size: 1rem !important;
    padding: 10px 12px;
}

/* --- 評等系統 --- */
.grading-container {
    margin-top: 25px;
    border-top: 2px dashed #aeb6bf;
    padding-top: 20px;
    max-width: 100%;
    overflow-x: hidden;
}

.grading-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    align-items: flex-start;
}

.grading-scores, .grading-radar {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    max-width: 100%;
    box-sizing: border-box;
    width: 90%;
    margin: 0 auto;
}

.grading-scores h3, .grading-radar h3 {
    margin-top: 0;
    color: #343a40;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    gap: 10px;
}

.score-item label {
    font-weight: bold;
    color: #495057;
    flex-shrink: 0;
    margin-right: 10px;
}

.score-item .slider-container {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    max-width: 160px;
}

.score-item .progress-bar-container {
    width: 120px;
    height: 12px;
    background-color: #e9ecef;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #ced4da;
}

.score-item .progress-bar-fill {
    height: 100%;
    width: 0%;
    background-color: #007bff;
    border-radius: 6px;
    transition: width 0.4s ease-in-out;
}

.score-item .score-display {
    font-weight: bold;
    width: 25px;
    text-align: center;
    color: #0056b3;
}

.total-score-container {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    flex-wrap: wrap;
}

#finalGrade, [id$="FinalGrade"] {
    font-size: 2.5em;
    font-weight: bold;
    color: #d9534f;
    line-height: 1;
}

#totalScoreDisplay, [id$="TotalScoreDisplay"] {
    font-size: 1.2em;
    font-weight: bold;
    color: #333;
}

.radar-chart-container {
    position: relative;
    aspect-ratio: 4 / 3;
    max-height: 350px;
    width: 100%;
}

@media (max-width: 768px) {
    .grading-grid {
        grid-template-columns: 1fr;
        width: 95%;
        margin: 0 auto;
        justify-items: center;
    }
    .grading-scores, .grading-radar {
        padding: 15px;
        width: 95%;
        max-width: 95%;
    }
    .radar-chart-container {
        aspect-ratio: 1 / 1;
        max-height: 400px;
    }
    .score-item { flex-wrap: wrap; }
    .score-item label { width: 100%; margin-bottom: 5px; }
    .score-item .slider-container { max-width: 100%; }
}

/* --- 儲存HTML按鈕 --- */
.result-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.btn-save-html {
    position: static;
    margin-top: 20px;
    width: 40px;
    height: 40px;
    background-color: rgba(106, 122, 138, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    color: white;
    display: none;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 10;
    opacity: 0.85;
    transition: all 0.2s ease-in-out;
    padding: 0;
    margin-left: auto;
    margin-right: auto;
}

.btn-save-html:hover {
    opacity: 1;
    transform: scale(1.1);
    background-color: rgba(90, 105, 120, 0.9);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.btn-save-html svg { width: 20px; height: 20px; }
#booksButtons #save-books-html-btn { background-color: rgba(74, 144, 226, 0.8); }

#writingReviewResultContainer, #argumentReviewResultContainer {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
}

/* --- 點評範疇 UI --- */
.scope-selector-container {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 10px;
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.08);
}

.scope-label input[type="checkbox"] { display: none; }

.scope-label {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    user-select: none;
    border: 1px solid transparent;
    background-color: #f0f0f0;
    color: #555;
}

.scope-label:not(.disabled):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-color: #007bff;
}

.scope-label.active {
    background-color: #007bff;
    color: white;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
}

.scope-label.disabled {
    background-color: #e9ecef;
    color: #adb5bd;
    cursor: not-allowed;
    opacity: 0.7;
}

.scope-label.all-scope.active {
    background-color: #4F5B93;
    color: white;
    box-shadow: 0 2px 5px rgba(79, 91, 147, 0.3);
}

/* --- 解題指引輸入框 --- */
#writingGuideTopicInput {
    padding: 15px;
    border: 2px solid #4A90E2;
    border-radius: 8px;
    width: 100%;
    margin-bottom: 15px;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    background-color: #fcfdfd;
}
#writingGuideTopicInput:focus {
    border-color: #28a745;
    box-shadow: 0 0 10px rgba(40, 167, 69, 0.2);
    outline: none;
}

/* 2. 標題區塊 */
.guide-section-header {
    padding: 10px 15px;
    margin-bottom: 15px;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 0 8px 8px 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.guide-section-header h3 {
    margin: 0;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* 3. 介紹卡片 (Intro) */
.guide-intro-card {
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    margin-bottom: 25px;
    line-height: 1.8;
    color: #444;
    font-size: 1.05rem;
    border: 1px solid #eee;
}

/* === 動漫風格角色選擇卡片 === */
.category-cards-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    perspective: 1000px;
    padding: 10px 0 30px 0;
}

.category-cards-container {
    display: flex;
    gap: 20px;
    overflow-x: auto;
    padding: 10px 20px;
    scrollbar-width: none;
    -ms-overflow-style: none;
    justify-content: center;
}

.category-cards-container::-webkit-scrollbar { display: none; }

.anime-card {
    position: relative;
    width: 120px;
    height: 180px;
    border-radius: 15px;
    background-image: var(--bg-img);
    background-size: cover;
    background-position: center;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    overflow: hidden;
    flex-shrink: 0;
    border: 1px solid rgba(255,255,255,0.2);
    filter: grayscale(30%);
}

.card-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.2) 60%, rgba(0,0,0,0) 100%);
    transition: all 0.3s ease;
}

.card-border-effect {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 15px;
    border: 2px solid transparent;
    transition: all 0.3s ease;
    z-index: 5;
    box-sizing: border-box;
}

.card-content {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    align-items: center;
    padding-bottom: 20px;
    z-index: 10;
}

.card-icon-container {
    font-size: 28px;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: auto;
    margin-top: 40px;
    transform: translateY(10px);
    transition: all 0.4s ease;
    opacity: 0.8;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
}

.card-text {
    text-align: center;
    transform: translateY(0);
    transition: transform 0.3s ease;
}

.card-zh {
    display: block;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    letter-spacing: 1px;
white-space: nowrap !important; /* 核心指令：強制文字不換行 */
    width: 100%;                    /* 確保文字容器寬度足夠 */
    text-align: center;             /* 確保文字水平置中 */
    display: block;                 /* 確保它是區塊元素 */
}

.card-en {
    display: block;
    font-size: 10px;
    font-weight: 700;
    color: rgba(255,255,255,0.6);
    letter-spacing: 2px;
    margin-top: 4px;
    text-transform: uppercase;
    font-family: 'Arial', sans-serif;
white-space: nowrap !important; /* 核心指令：強制文字不換行 */
}

.anime-card:hover {
    transform: translateY(-15px) scale(1.05);
    filter: grayscale(0%);
    box-shadow: 0 15px 30px rgba(0,0,0,0.5), 0 0 20px rgba(0, 191, 255, 0.6);
    z-index: 20;
}

.anime-card:hover .card-border-effect { border-color: rgba(255, 255, 255, 0.9); }
.anime-card:hover .card-overlay { background: linear-gradient(to top, rgba(0,86,179,0.8) 0%, rgba(0,0,0,0) 100%); }
.anime-card:hover .card-icon-container {
    transform: translateY(-5px) scale(1.2);
    color: #fff;
    text-shadow: 0 0 10px #00bfff;
}

.anime-card.active {
    transform: translateY(-8px) scale(1.02);
    filter: grayscale(0%);
    box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), 0 0 50px rgba(255, 215, 0, 0.4);
    z-index: 15;
}

.anime-card.active .card-border-effect {
    border: 3px solid #FFD700;
    box-shadow: inset 0 0 15px rgba(255, 215, 0, 0.5);
}

.anime-card.active .card-overlay { background: linear-gradient(to top, rgba(184, 134, 11, 0.8) 0%, rgba(0,0,0,0.1) 100%); }
.anime-card.active .card-zh { color: #fff; text-shadow: 0 0 10px #FFD700; }
.anime-card.active .card-en { color: #FFD700; }
.anime-card.active .card-icon-container { color: #FFD700; transform: translateY(-5px) scale(1.1); }

@media (max-width: 600px) {
    .category-cards-container {
        justify-content: flex-start;
        padding-bottom: 20px;
    }
    .anime-card { width: 100px; height: 150px; }
    .card-zh { font-size: 16px; }
    .card-en { font-size: 8px; }
    .card-icon-container { font-size: 24px; margin-top: 30px; }
}

/* ========================================= */
/* === 卡片排版終極修復 (Fix Layout V2) === */
/* ========================================= */

/* 1. 外層網格：確保每張卡片寬度被限制 */
.guide-grid-3 {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 強制三欄均分 */
    gap: 25px;            /* 卡片之間的間距 */
    width: 100%;
    box-sizing: border-box; /* 確保 padding 不會撐爆寬度 */
}

/* 2. 卡片本體：垂直排列 (標題在上，內容在下) */
.guide-card {
    display: flex !important;
    flex-direction: column !important;
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    height: 100%;         /* 讓卡片撐滿網格高度 */
    overflow: hidden;     /* 關鍵：防止內容溢出圓角 */
    position: relative;
    box-sizing: border-box; /* 關鍵：讓寬度包含邊框與內距 */
}

/* 3. 標題區域：藍色部分 */
.card-title, .seed-header {
    flex-shrink: 0;       /* 禁止標題被壓縮 */
    width: 100%;
    padding: 15px;
    font-size: 1.2rem;
    font-weight: bold;
    text-align: center;
    box-sizing: border-box; /* 防止標題文字撐爆 */
}

/* 4. 內容區域：白色文字部分 (修復重點) */
.card-content, .seed-body {
    flex-grow: 1;         /* 填滿剩餘高度 */
    padding: 20px;        /* 內邊距 */
    
    /* === 文字排版核心修復 === */
    font-size: 1rem;
    line-height: 1.8;     /* 增加行高，讓文字不擠 */
    color: #444;
    text-align: justify;  /* 左右對齊，讓方塊更整齊 */
    
    /* 強制換行設定 */
    white-space: normal !important;
    word-wrap: break-word !important;
    overflow-wrap: break-word !important;
    word-break: break-word; /* 針對中英文混排優化 */
    
    width: 100%;          /* 確保不超過卡片寬度 */
    box-sizing: border-box; /* 關鍵：讓 padding 包含在寬度內 */
}

/* 5. 手機版適配：變成單欄 */
@media (max-width: 768px) {
    .guide-grid-3 {
        grid-template-columns: 1fr !important; /* 手機強制一欄 */
    }
    .guide-card {
        margin-bottom: 20px;
        height: auto !important; /* 手機版高度自動 */
    }
}

/* 5. 針對不同類型的卡片配色 */
/* 藍色卡片 (心情/題眼) */
.emotion-card {
    border-top: 5px solid #4A90E2;
}
.emotion-card .card-title {
    background-color: #f0f7ff;
    color: #0056b3;
}

/* 綠色卡片 (種子/寫作方向) */
.seed-card {
    border-top: 5px solid #28a745;
}
.seed-card .seed-header {
    background-color: #f0fff4;
    color: #155724;
}

/* 6. 種子卡片內的段落標題 */
.seed-body p {
    margin-bottom: 12px;
}
.seed-body p:last-child {
    margin-bottom: 0;
}
.seed-body strong {
    color: #155724 !important; /* 改為深綠色 */
    display: inline-block;
    margin-bottom: 5px;
    font-size: 1.05rem;
    border-bottom: 2px solid rgba(40, 167, 69, 0.4) !important; /* 改為淺綠色底線 */
}

/* 7. 手機版適配：強制單欄 */
@media (max-width: 768px) {
    .guide-grid-3 {
        grid-template-columns: 1fr !important; /* 強制變為單欄 */
        gap: 30px; /* 增加手機版卡片間距 */
        margin-bottom: 30px;
    }
    
    .guide-card {
        height: auto !important; /* 手機版高度完全自動 */
        margin-bottom: 0; 
    }
}

/* 8. 下載按鈕容器防重疊修正 */
.result-wrapper {
    margin-top: 40px; /* 確保按鈕與上方內容有足夠距離 */
    padding-top: 20px;
    border-top: 1px dashed #ddd; /* 增加分隔線，視覺上區隔 */
    width: 100%;
    clear: both; /* 清除浮動 */
}

#sideMenuToggle {
    position: fixed;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    z-index: 9998;
    width: 20px;
    height: 60px;
    border-radius: 8px 0 0 8px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-right: none;
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    backdrop-filter: blur(5px);
}

#sideMenuToggle:hover {
    background-color: rgba(0, 0, 0, 0.8);
    width: 24px;
}

.side-menu-overlay {
    position: fixed;
    top: 50%;
    right: -80px;
    transform: translateY(-50%);
    width: 60px;
    height: auto;
    background-color: rgba(30, 30, 30, 0.95);
    backdrop-filter: blur(10px);
    z-index: 9999;
    transition: right 0.3s ease;
    box-shadow: -4px 0 15px rgba(0, 0, 0, 0.5);
    border-radius: 12px 0 0 12px;
    padding: 10px 0;
}

.side-menu-overlay.active {
    right: 0;
}

.side-menu-content {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    padding: 0;
}

.side-menu-close {
    display: none; /* 移除獨立關閉鍵 */
}

.side-menu-items {
    margin-top: 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 5px;
}

.side-menu-item {
    width: 100%;
    padding: 12px 0;
    background-color: transparent;
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.side-menu-item span {
    display: none; /* 隱藏文字 */
}

.side-menu-item:hover {
    background-color: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
}

.side-menu-item i {
    font-size: 24px;
    width: 100%;
    text-align: center;
}

/* 讓卡扣本身也能關閉選單 */
#sideMenuToggle.active {
    background-color: rgba(255, 100, 100, 0.8);
}



/* === 永遠隱藏主頁的「工具一覽」container（但保留代碼）=== */
#mainMenuBox ~ #toolsBox,
#toolsBox {
    display: none !important;
}

/* === 手機版：每行 2 張卡片，最後一張放大到兩張卡片寬 === */
@media (max-width: 600px) {
    .category-cards-wrapper {
        padding: 20px 0 50px 0;
    }

    .category-cards-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        justify-items: center;
        padding: 10px 20px;
        overflow: hidden;
    }

    /* 正常卡片大小（前四張） */
    .anime-card {
        width: 120px !important;
        height: 180px !important;
        flex-shrink: 0;
    }

    /* 第 5 張卡片：放大到兩張卡片的總寬度並居中 */
    .category-cards-container .anime-card:nth-child(5) {
        grid-column: 1 / -1;
        width: calc(120px * 2 + 24px) !important;  /* 兩張寬 + gap */
        height: 130px !important;
        max-width: none;
    }

    /* 第 5 張卡片內文字圖標微調（可選，視覺更突出） */
    .category-cards-container .anime-card:nth-child(5) .card-zh {
        font-size: 22px;
    }
    .category-cards-container .anime-card:nth-child(5) .card-en {
        font-size: 13px;
    }
    .category-cards-container .anime-card:nth-child(5) .card-icon-container {
        font-size: 34px;
        margin-top: 45px;
    }

    .card-zh {
        font-size: 18px;
    }
    .card-icon-container {
        font-size: 28px;
        margin-top: 40px;
    }
}

/* === 煙花特效畫布 === */
#fireworksCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 99999; /* 確保在最上層 */
    pointer-events: none; /* 讓滑鼠點擊可以穿透煙花，不影響按鈕操作 */
    display: none; /* 預設隱藏 */
}

/* ========================================= */
/* === 神思專用：文藝風原稿紙 UI 設計 (RWD 終極版) === */
/* ========================================= */

/* --- 1. 電腦版預設樣式 (大格、大字) --- */
/* --- 1. 電腦版預設樣式 (大格、大字) --- */
/* 將原本長串的 ID 選擇器改成單純的 textarea，這樣所有多行輸入框都會生效 */
/* --- 1. 電腦版預設樣式 (大格、大字) --- */
/* 加入 input[type="text"] 讓單行輸入框（如書名、作者）也生效 */
textarea, input[type="text"] {
    /* 防止爆版核心設定 */
    box-sizing: border-box !important;
    width: 100% !important;
    max-width: 100% !important;
    
    /* 字體與行高 (配合 40px 格子) */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 20px !important;       
    line-height: 40px !important;     
    color: #2c3e50;                   
    letter-spacing: 2px;              
    
    /* 原稿紙背景 (40px 高) */
    background-color: #fffcf6 !important;        
    background-image: 
        linear-gradient(transparent 39px, rgba(42, 150, 137, 0.3) 39px, rgba(42, 150, 137, 0.3) 40px, transparent 40px),
        linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.03) 39px, rgba(0,0,0,0.03) 40px, transparent 40px) !important;
    background-size: 40px 40px !important;       
    background-attachment: local;     
    
    /* 邊框與陰影 */
    border: 2px solid #8baea8 !important;        
    border-radius: 8px !important;               
    padding: 0 18px !important;       
    box-shadow: 
        inset 0 0 40px rgba(0,0,0,0.02),  
        5px 5px 0px rgba(42, 150, 137, 0.15); 
        
    transition: all 0.3s ease;
    resize: vertical;                 
}

/* 互動效果 - 點擊時加深陰影 */
textarea:focus, input[type="text"]:focus {
    background-color: #fff !important;           
    border-color: #2A9689 !important;            
    outline: none;
    box-shadow: 
        inset 0 0 10px rgba(42, 150, 137, 0.1), 
        8px 8px 0px rgba(42, 150, 137, 0.25); 
    transform: translateY(-2px);      
}

/* Placeholder 樣式 */
textarea::placeholder, input[type="text"]::placeholder {
    color: rgba(42, 150, 137, 0.4);   
    font-style: italic;               
    font-size: 16px;
    letter-spacing: 1px;
}

/* --- 2. 手機版響應式調整 (螢幕寬度小於 600px) --- */
/* --- 2. 手機版響應式調整 (螢幕寬度小於 600px) --- */
@media (max-width: 600px) {
    /* 同樣加入 input[type="text"] */
    textarea, input[type="text"] {
        /* 字體縮小，適配窄螢幕 */
        font-size: 16px !important;
        letter-spacing: 1px !important;
        
        /* 行高縮小至 32px (更緊湊) */
        line-height: 32px !important;
        
        /* 重新繪製背景格線 (配合 32px 高度) */
        background-image: 
            /* 31px 透明 + 1px 線條 = 32px */
            linear-gradient(transparent 31px, rgba(42, 150, 137, 0.3) 31px, rgba(42, 150, 137, 0.3) 32px, transparent 32px),
            linear-gradient(90deg, transparent 31px, rgba(0,0,0,0.03) 31px, rgba(0,0,0,0.03) 32px, transparent 32px) !important;
        background-size: 32px 32px !important;
        
        /* 減少內邊距，爭取書寫空間 */
        padding: 0 10px !important;
        
        /* 縮小陰影 */
        box-shadow: 
            inset 0 0 20px rgba(0,0,0,0.02),  
            3px 3px 0px rgba(42, 150, 137, 0.15) !important;
    }
    
    /* 手機版聚焦效果微調 */
    textarea:focus, input[type="text"]:focus {
        box-shadow: 
            inset 0 0 10px rgba(42, 150, 137, 0.1), 
            4px 4px 0px rgba(42, 150, 137, 0.25) !important;
        transform: translateY(-1px); 
    }
}
/* 懸浮視窗標題美化 (通用) */
.outline-modal-content h3 {
    color: #2A9689;
    font-family: 'Noto Serif TC', serif;
    border-bottom: 2px dashed #a8dad5;
    padding-bottom: 12px;
    margin-bottom: 20px;
    text-align: center;
    letter-spacing: 2px;
}

	/* ========================================= */
/* === 灰藍色原稿紙風格：下拉選單專用樣式 === */
/* ========================================= */

select {
    /* 1. 基礎字體與排版 */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 18px !important;
    font-weight: bold !important;
    line-height: 40px !important; /* 配合格線高度 */
    color: #455A64 !important;    /* 深灰藍文字 (Blue Grey 700) */
    letter-spacing: 1px;
    padding: 0 40px 0 15px !important; /* 右邊預留箭頭空間 */
    height: 44px !important;      /* 固定高度確保格線對齊 */
    width: 100%;
    margin: 10px 0;
    box-sizing: border-box;

    /* 2. 背景設定 - 灰藍色原稿紙 */
    background-color: #ECEFF1 !important; /* 淺灰藍底色 (Blue Grey 50) */
    
    /* 繪製底線：透明 -> 灰藍線條 -> 透明 + 自定義箭頭 */
    background-image:
        /* 格線：38px透明 + 2px 線條 = 40px */
        linear-gradient(transparent 38px, rgba(120, 144, 156, 0.4) 38px, rgba(120, 144, 156, 0.4) 40px, transparent 40px),
        /* 下拉箭頭圖示 (深灰藍色) */
        url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23455A64%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E") !important;
    
    background-repeat: no-repeat, no-repeat;
    background-position: center, right 15px center; /* 格線置中，箭頭靠右 */
    background-size: 40px 40px, 12px 12px;          /* 格線大小，箭頭大小 */
    background-attachment: local, scroll;           /* 讓背景隨內容滾動(雖然select很少滾動) */

    /* 3. 邊框與外觀 */
    border: 2px solid #90A4AE !important; /* 中灰藍邊框 (Blue Grey 300) */
    border-radius: 8px !important;
    
    /* 增加一點紙張厚度感 */
    box-shadow: 
        inset 0 0 20px rgba(255,255,255,0.5), /* 內部微光 */
        3px 3px 0px rgba(144, 164, 174, 0.3) !important; /* 右下角陰影 */
        
    /* 移除瀏覽器預設外觀 */
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    cursor: pointer;
    transition: all 0.3s ease;
}

/* 互動效果：滑鼠懸停或點擊時 */
select:focus, select:hover {
    background-color: #FFFFFF !important; /* 變亮 */
    border-color: #607D8B !important;     /* 邊框變深 (Blue Grey 500) */
    outline: none;
    transform: translateY(-2px);          /* 輕微浮起 */
    box-shadow: 
        inset 0 0 10px rgba(84, 110, 122, 0.1),
        5px 5px 0px rgba(84, 110, 122, 0.3) !important;
}

/* 針對音樂播放器內的小選單進行微調 (避免變得太大) */
#music-player .controls select, 
#music-player .mode select {
    height: 30px !important;
    line-height: 26px !important;
    font-size: 14px !important;
    padding: 0 25px 0 10px !important;
    background-size: 30px 30px, 10px 10px !important; /* 縮小格線和箭頭 */
    background-image:
        linear-gradient(transparent 28px, rgba(120, 144, 156, 0.4) 28px, rgba(120, 144, 156, 0.4) 30px, transparent 30px),
        url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23455A64%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E") !important;
}

/* 手機版響應式調整 */
@media (max-width: 600px) {
    select {
        font-size: 16px !important;
        height: 36px !important;
        line-height: 32px !important; /* 手機版格線高度縮小 */
        background-position: center, right 10px center;
        
        /* 重新繪製 32px 高度的格線 */
        background-image:
            linear-gradient(transparent 30px, rgba(120, 144, 156, 0.4) 30px, rgba(120, 144, 156, 0.4) 32px, transparent 32px),
            url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23455A64%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E") !important;
        background-size: 32px 32px, 10px 10px !important;
        
        box-shadow: 
            inset 0 0 10px rgba(255,255,255,0.5),
            2px 2px 0px rgba(144, 164, 174, 0.3) !important;
    }
}

/* ==========================================
   === 文藝風歷史紀錄卡片 (莫蘭迪色系) ===
   ========================================== */

/* 定義莫蘭迪色變數 */
:root {
    --morandi-bg: #fdfcf8;          /* 米白紙張底色 */
    --morandi-text: #5e5e5e;        /* 深灰文字 */
    --morandi-green: #8fa398;       /* 閱讀 - 灰綠 */
    --morandi-blue: #94a7b5;        /* 敘事 - 霧霾藍 */
    --morandi-purple: #b6a6ca;      /* 議論 - 香芋紫 */
    --morandi-red: #d69a92;         /* 拓展 - 豆沙紅 */
    --morandi-border: #e0ddd7;      /* 淺卡其邊框 */
    --morandi-shadow: rgba(149, 157, 165, 0.1);
}

/* 列表容器調整 */
.history-list-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); /* 改為網格排列 */
    gap: 20px;
    padding: 10px;
    max-height: 70vh;
    overflow-y: auto;
}

/* ==========================================
   === 歷史紀錄卡片：Note Card 打洞風格 ===
   ========================================== */

.history-card {
    /* 1. 基礎卡片設定 */
    background-color: var(--morandi-bg);
    border: 1px solid var(--morandi-border); /* 統一使用細邊框 */
    border-radius: 8px; 
    padding: 20px;
    position: relative;
    box-shadow: 4px 4px 0px rgba(0,0,0,0.03);
    transition: all 0.3s ease;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    overflow: hidden;

    /* 2. Note Card 關鍵樣式：打洞與分隔線 */
    padding-left: 55px !important; /* 左側留白給打洞區 */
    
    background-image: 
        /* A. 垂直分隔線 (模擬紅線或灰線，這裡用莫蘭迪灰 #e0ddd7) */
        linear-gradient(to right, transparent 39px, #e0ddd7 40px, transparent 41px),
        /* B. 打洞效果 (模擬孔洞，使用深灰色圓形 #d1cdc5) */
        radial-gradient(circle at 20px 50%, #d1cdc5 6px, transparent 7px);
    
    /* 設定背景圖層大小 */
    background-size: 
        100% 100%, /* 分隔線：撐滿整張卡片 */
        100% 35px; /* 打洞：每 35px 重複一顆 */
    
    /* 設定背景重複方式 */
    background-repeat: 
        no-repeat, /* 分隔線不重複 */
        repeat-y;  /* 打洞在垂直方向重複 */
        
    /* 設定起始位置 */
    background-position: 
        0 0,       /* 分隔線位置 */
        0 12px;    /* 打洞起始位置向下微調，避免切到頂部色條 */
}

/* 3. 頂部裝飾條 (保留您要求的頂部色條) */
.history-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 6px; /* 頂部色條高度 */
    background-color: #ccc; /* 預設顏色，會被下方 Theme 覆蓋 */
    opacity: 0.8;
    z-index: 1;
}

/* 4. 懸停效果 */
.history-card:hover {
    transform: translateY(-3px);
    box-shadow: 6px 6px 0px rgba(0,0,0,0.05);
    border-color: #d1cdc5;
    /* 確保 Hover 時不會出現左側粗色條，保持打洞風格 */
    border-left-width: 1px;
    border-left-style: solid;
}

/* 5. 顏色主題設定 (只改變頂部色條與標籤顏色) */

/* Theme 1 (灰綠) */
.history-card.history-theme-1::before { background-color: var(--m-color-1); }
.history-card.history-theme-1 .history-tag { background-color: var(--m-color-1); }
.history-card.history-theme-1:hover { border-left-color: var(--morandi-border); }

/* Theme 2 (霧霾藍) */
.history-card.history-theme-2::before { background-color: var(--m-color-2); }
.history-card.history-theme-2 .history-tag { background-color: var(--m-color-2); }
.history-card.history-theme-2:hover { border-left-color: var(--morandi-border); }

/* Theme 3 (香芋紫) */
.history-card.history-theme-3::before { background-color: var(--m-color-3); }
.history-card.history-theme-3 .history-tag { background-color: var(--m-color-3); }
.history-card.history-theme-3:hover { border-left-color: var(--morandi-border); }

/* Theme 4 (豆沙紅) */
.history-card.history-theme-4::before { background-color: var(--m-color-4); }
.history-card.history-theme-4 .history-tag { background-color: var(--m-color-4); }
.history-card.history-theme-4:hover { border-left-color: var(--morandi-border); }

/* Theme 5 (奶茶棕) */
.history-card.history-theme-5::before { background-color: var(--m-color-5); }
.history-card.history-theme-5 .history-tag { background-color: var(--m-color-5); }
.history-card.history-theme-5:hover { border-left-color: var(--morandi-border); }
/* 不同範疇的顏色標記 */
.history-card.type-reading { border-left-color: #28a745; }   /* 閱讀-綠 */
.history-card.type-narrative { border-left-color: #007bff; } /* 敘事-藍 */
.history-card.type-argument { border-left-color: #800080; }  /* 議論-紫 */
.history-card.type-expand { border-left-color: #dc3545; }    /* 拓展-紅 */



.history-meta {
    font-size: 0.85em;
    color: #888;
    margin-bottom: 5px;
}

.history-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    background-color: #eee;
    color: #555;
    font-size: 0.8em;
    margin-right: 8px;
    font-weight: bold;
}

.history-title {
    font-size: 1.1em;
    font-weight: bold;
    color: #333;
    margin: 0;
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* 操作區 (刪除按鈕) */
.history-actions {
    margin-top: 15px;
    display: flex;
    justify-content: flex-end;
    opacity: 0.6;
    transition: opacity 0.3s;
}

.history-card:hover .history-actions {
    opacity: 1;
}


.btn-delete-history {
    background-color: transparent;
    border: 1px solid #dc3545;
    color: #dc3545;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-delete-history:hover {
    background-color: #dc3545;
    color: white;
}

/* 3. 模態視窗內容美化 */
#historyModalContent {
    line-height: 1.6;
    font-size: 1.1em;
}

#historyModalContent h3 {
    border-bottom: 2px solid #eee;
    padding-bottom: 10px;
    margin-top: 20px;
    color: #0056b3;
}

/* 4. 新增：層級選單 (Grid Menu) 樣式 (Level 1 & 2) */
.history-grid-menu {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); /* 自動適應寬度 */
    gap: 15px;
    padding: 10px 0;
}

.history-folder-btn {
    background-color: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 20px 10px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #555;
    min-height: 100px; /* 確保按鈕有足夠高度 */
}

.history-folder-btn:hover {
    background-color: #fff;
    border-color: #007bff;
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0, 123, 255, 0.15);
    color: #007bff;
}

.history-folder-btn i {
    font-size: 2em;
    margin-bottom: 10px;
    color: #6c757d;
    transition: color 0.3s ease;
}

.history-folder-btn:hover i {
    color: #007bff;
}

.history-folder-btn span {
    font-weight: bold;
    font-size: 1.1em;
}

/* 5. 新增：麵包屑導航樣式 */
.history-breadcrumb span:hover {
    text-decoration: underline;
}

/* 6. 新增：雷達圖圖片化樣式 (確保 Canvas 轉圖後在歷史紀錄中正確顯示) */
.radar-chart-history-img {
    width: 100% !important;
    max-width: 500px;
    height: auto !important;
    margin: 0 auto;
    display: block;
    border: 1px solid #eee; /* 選用：增加邊框讓圖表更清晰 */
    border-radius: 8px;
    padding: 10px;
    background-color: #fff;
}

	/* 確保歷史紀錄內的卡片容器不會有過多的上下留白 */
#historyContainer .category-cards-wrapper {
    margin-top: 0;
    margin-bottom: 0;
}

/* 讓麵包屑導航更明顯 */
.history-breadcrumb {
    transition: all 0.3s ease;
}
.history-breadcrumb span:hover {
    opacity: 0.8;
}

/* === 新增：標頭的低調清空按鈕 === */
.history-clear-btn {
    background: transparent;
    border: 1px solid transparent; /* 預設無邊框 */
    color: #aaa; /* 淺灰色，非常低調 */
    font-size: 1.2rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.history-clear-btn:hover {
    color: #d9534f; /* 懸停時才變紅 */
    background-color: rgba(217, 83, 79, 0.1); /* 淡淡的紅色背景 */
    transform: rotate(15deg); /* 增加一點點互動趣味 */
}


/* 內容佈局 */
.history-info {
    flex-grow: 1;
}

/* 標題樣式：襯線字體，文藝感 */
.history-title {
    font-family: 'Noto Serif TC', serif;
    font-size: 1.15em;
    font-weight: 600;
    color: #4a4a4a;
    margin: 10px 0;
    line-height: 1.5;
    
    /* 多行省略 */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* 日期與標籤區域 */
.history-meta {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    padding-bottom: 10px;
    border-bottom: 1px dashed var(--morandi-border); /* 虛線分隔 */
}

.history-date {
    font-family: 'Courier New', monospace; /* 打字機字體 */
    font-size: 0.85em;
    color: #999;
    letter-spacing: 1px;
}

/* 範疇標籤 (像貼紙) */
.history-tag {
    font-size: 0.75em;
    padding: 2px 8px;
    border-radius: 4px;
    margin-right: auto; /* 將日期推到右邊 */
    color: #fff;
    font-weight: normal;
    letter-spacing: 1px;
}



	
/* 刪除按鈕美化 */
.btn-delete-history {
    background: transparent;
    border: none;
    color: #bfaea8; /* 淺紅棕色 */
    font-size: 1.1em;
    cursor: pointer;
    transition: all 0.2s;
    padding: 5px;
    border-radius: 50%;
}

.btn-delete-history:hover {
    color: #d69a92;
    background-color: rgba(214, 154, 146, 0.1);
    transform: scale(1.1);
}

/* ==========================================
   === 歷史紀錄樣式修訂 (多色卡片 & 導航美化) ===
   ========================================== */

/* 1. 定義 5 種莫蘭迪輪替色 (用於同一列表中的不同卡片) */
/* 讓同一個列表中的卡片擁有不同顏色，以作區分 */
.history-card.accent-1::before { background-color: #8fa398; } /* 灰綠 */
.history-card.accent-1 .history-tag { background-color: #8fa398; }
.history-card.accent-1:hover { border-color: #8fa398; }

.history-card.accent-2::before { background-color: #94a7b5; } /* 霧霾藍 */
.history-card.accent-2 .history-tag { background-color: #94a7b5; }
.history-card.accent-2:hover { border-color: #94a7b5; }

.history-card.accent-3::before { background-color: #b6a6ca; } /* 香芋紫 */
.history-card.accent-3 .history-tag { background-color: #b6a6ca; }
.history-card.accent-3:hover { border-color: #b6a6ca; }

.history-card.accent-4::before { background-color: #d69a92; } /* 豆沙紅 */
.history-card.accent-4 .history-tag { background-color: #d69a92; }
.history-card.accent-4:hover { border-color: #d69a92; }

.history-card.accent-5::before { background-color: #c7b299; } /* 奶茶棕 */
.history-card.accent-5 .history-tag { background-color: #c7b299; }
.history-card.accent-5:hover { border-color: #c7b299; }

/* 2. 麵包屑導航 (顏色區分修訂) */
.history-breadcrumb {
    background-color: transparent !important;
    border: none !important;
    border-bottom: 1px dashed #d1cdc5 !important;
    padding: 10px 5px !important;
    margin-bottom: 25px;
    font-size: 1rem;
    color: #999; /* 分隔符顏色 */
    display: flex;
    align-items: center;
    gap: 8px;
}

/* 第一層：主範疇 (藍色，可點擊) */
.history-breadcrumb span[onclick*="renderHistoryCategories"] {
    color: #007bff !important; 
    font-weight: 900;
    cursor: pointer;
}

/* 第二層：子功能分類 (深灰色，可點擊) */
.history-breadcrumb span[onclick*="enterHistoryCategory"] {
    color: #555 !important; 
    font-weight: bold;
    cursor: pointer;
    transition: color 0.3s;
}
.history-breadcrumb span[onclick*="enterHistoryCategory"]:hover {
    color: #007bff !important;
    text-decoration: underline;
}

/* 第三層：當前頁面 (霧霾藍，不可點擊) */
.history-breadcrumb span#breadcrumb-sub {
    color: #94a7b5 !important; 
    font-weight: bold;
    padding: 2px 4px;
    background-color: rgba(148, 167, 181, 0.1);
    border-radius: 4px;
}

/* 分隔符號 */
.history-breadcrumb span[id^="breadcrumb-sep"] {
    color: #ccc !important;
    font-weight: normal;
}

/* 3. 卡片細節微調 (確保日期與標籤排版) */
.history-meta {
    border-bottom: 1px dashed #e0ddd7;
    padding-bottom: 8px;
    margin-bottom: 10px;
    display: flex; /* 確保左右對齊 */
    justify-content: space-between; /* 標籤靠左，日期靠右 */
    align-items: center;
}

.history-date {
    font-family: 'Courier New', monospace;
    font-size: 0.85em;
    color: #aaa;
    letter-spacing: 0px;
    margin-left: auto; /* 強制靠右 */
}

.history-tag {
    color: white;
    font-size: 0.75em;
    padding: 2px 8px;
    border-radius: 4px;
    font-weight: normal;
    letter-spacing: 1px;
}

/* 手機版適配 */
@media (max-width: 600px) {
    .history-list-container {
        grid-template-columns: 1fr; /* 手機單欄 */
    }
}

	/* 搜尋到的卡片高亮動畫 */
@keyframes highlight-card {
    0% { transform: scale(1); box-shadow: 0 0 0 rgba(40, 167, 69, 0); }
    50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(40, 167, 69, 0.5); border-left-color: #28a745; }
    100% { transform: scale(1); box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
}

.history-card.highlighted {
    animation: highlight-card 1.5s ease-in-out;
    background-color: #f0fff4; /* 淡淡的綠色背景 */
}

	/* === 定義莫蘭迪色系變數 === */
:root {
    --m-color-1: #8fa398; /* 灰綠 */
    --m-color-2: #94a7b5; /* 霧霾藍 */
    --m-color-3: #b6a6ca; /* 香芋紫 */
    --m-color-4: #d69a92; /* 豆沙紅 */
    --m-color-5: #c7b299; /* 奶茶棕 */
}

/* === 修改：歷史紀錄導航列 (麵包屑) === */
/* 需求三：主範疇要莫迪蘭色，不要藍色 */
.history-breadcrumb span[onclick*="renderHistoryCategories"] {
    color: #6a7a7d !important; /* 莫蘭迪深灰藍 */
    font-weight: 900;
    cursor: pointer;
    transition: color 0.3s;
}
.history-breadcrumb span[onclick*="renderHistoryCategories"]:hover {
    color: #8c9ea1 !important;
}

/* === 修改：子功能按鈕 (Level 2) 的顏色邏輯 === */
/* 需求一：子功能卡片要不同顏色 */
.history-folder-btn.history-theme-1 { border-color: var(--m-color-1); color: var(--m-color-1); }
.history-folder-btn.history-theme-1 i { color: var(--m-color-1); }
.history-folder-btn.history-theme-1:hover { background-color: var(--m-color-1); color: white; }
.history-folder-btn.history-theme-1:hover i { color: white; }

.history-folder-btn.history-theme-2 { border-color: var(--m-color-2); color: var(--m-color-2); }
.history-folder-btn.history-theme-2 i { color: var(--m-color-2); }
.history-folder-btn.history-theme-2:hover { background-color: var(--m-color-2); color: white; }
.history-folder-btn.history-theme-2:hover i { color: white; }

.history-folder-btn.history-theme-3 { border-color: var(--m-color-3); color: var(--m-color-3); }
.history-folder-btn.history-theme-3 i { color: var(--m-color-3); }
.history-folder-btn.history-theme-3:hover { background-color: var(--m-color-3); color: white; }
.history-folder-btn.history-theme-3:hover i { color: white; }

.history-folder-btn.history-theme-4 { border-color: var(--m-color-4); color: var(--m-color-4); }
.history-folder-btn.history-theme-4 i { color: var(--m-color-4); }
.history-folder-btn.history-theme-4:hover { background-color: var(--m-color-4); color: white; }
.history-folder-btn.history-theme-4:hover i { color: white; }

.history-folder-btn.history-theme-5 { border-color: var(--m-color-5); color: var(--m-color-5); }
.history-folder-btn.history-theme-5 i { color: var(--m-color-5); }
.history-folder-btn.history-theme-5:hover { background-color: var(--m-color-5); color: white; }
.history-folder-btn.history-theme-5:hover i { color: white; }

/* === 修改：紀錄卡片 (Level 3) 的顏色邏輯 === */
/* 需求：卡片左側不要有色條，保留頂部色條(::before)與標籤顏色 */

/* 確保所有主題卡片的左邊框回歸預設樣式 (無粗色條) */
.history-card {
    border-left: 1px solid var(--morandi-border) !important;
}

/* Theme 1 (灰綠) */
.history-card.history-theme-1::before { background-color: var(--m-color-1); }
.history-card.history-theme-1 .history-tag { background-color: var(--m-color-1); }
/* 確保 hover 時也不會出現左側色條，只加深陰影 */
.history-card.history-theme-1:hover { border-left-color: var(--morandi-border); }

/* Theme 2 (霧霾藍) */
.history-card.history-theme-2::before { background-color: var(--m-color-2); }
.history-card.history-theme-2 .history-tag { background-color: var(--m-color-2); }
.history-card.history-theme-2:hover { border-left-color: var(--morandi-border); }

/* Theme 3 (香芋紫) */
.history-card.history-theme-3::before { background-color: var(--m-color-3); }
.history-card.history-theme-3 .history-tag { background-color: var(--m-color-3); }
.history-card.history-theme-3:hover { border-left-color: var(--morandi-border); }

/* Theme 4 (豆沙紅) */
.history-card.history-theme-4::before { background-color: var(--m-color-4); }
.history-card.history-theme-4 .history-tag { background-color: var(--m-color-4); }
.history-card.history-theme-4:hover { border-left-color: var(--morandi-border); }

/* Theme 5 (奶茶棕) */
.history-card.history-theme-5::before { background-color: var(--m-color-5); }
.history-card.history-theme-5 .history-tag { background-color: var(--m-color-5); }
.history-card.history-theme-5:hover { border-left-color: var(--morandi-border); }

/* === 歷史紀錄：輸入內容優化樣式 === */
.history-input-card {
    background-color: #fdfdfd;
    border: 1px solid #e0e0e0;
    border-left: 5px solid #6a7a7d; /* 莫蘭迪深灰藍裝飾線 */
    border-radius: 6px;
    padding: 20px;
    margin-bottom: 25px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

.history-input-header {
    margin-top: 0;
    margin-bottom: 15px;
    color: #4a4a4a;
    font-size: 1.1em;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 8px;
    border-bottom: 1px dashed #ddd;
    padding-bottom: 10px;
}

.history-input-body {
    font-family: 'Noto Serif TC', serif; /* 保持文藝字體 */
    font-size: 1rem;
    line-height: 1.8; /* 增加行高，避免文字擠在一起 */
    color: #333;
    white-space: pre-wrap; /* 保留換行 */
    word-wrap: break-word;
}

/* 自動將「標籤」加粗的樣式 (配合 JS 使用) */
.history-label-bold {
    font-weight: 700;
    color: #2c3e50;
    background-color: rgba(0,0,0,0.03);
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 5px;
}

	/* === 歷史紀錄：結構化顯示優化 === */
.history-parsed-container {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 區塊間距 */
}

.history-item-block {
    background-color: transparent;
}

.history-item-label {
    display: block;
    font-size: 0.95em;
    font-weight: bold;
    color: #2A9689; /* 使用你的主題綠色 */
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* 標題前的小裝飾 */
.history-item-label::before {
    content: '';
    display: block;
    width: 4px;
    height: 14px;
    background-color: #2A9689;
    border-radius: 2px;
}

.history-item-content {
    background-color: #f7f9fa; /* 淺灰背景，區分內容 */
    border: 1px solid #e1e4e8;
    border-radius: 8px;
    padding: 12px 15px;
    font-size: 1rem;
    line-height: 1.8;
    color: #333;
    font-family: 'Noto Serif TC', serif;
    white-space: pre-wrap; /* 關鍵：保留詩詞的換行 */
    word-break: break-word;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.02); /* 內陰影增加層次感 */
}

	/* === 歷史紀錄：結構化顯示優化 (莫蘭迪色系版) === */

/* 定義顏色對應類別 */
.history-theme-context-1 { --current-theme-color: var(--m-color-1); } /* 灰綠 */
.history-theme-context-2 { --current-theme-color: var(--m-color-2); } /* 霧霾藍 */
.history-theme-context-3 { --current-theme-color: var(--m-color-3); } /* 香芋紫 */
.history-theme-context-4 { --current-theme-color: var(--m-color-4); } /* 豆沙紅 */
.history-theme-context-5 { --current-theme-color: var(--m-color-5); } /* 奶茶棕 */

/* 預設顏色 (防呆) */
.history-parsed-container {
    --current-theme-color: #6a7a7d; 
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.history-item-block {
    background-color: transparent;
}

/* 標題樣式：使用動態變數 */
.history-item-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 1em;
    font-weight: bold;
    color: var(--current-theme-color); /* 跟隨主題色 */
    margin-bottom: 8px;
    padding-left: 2px;
}

/* 標題前的裝飾小圓點 */
.history-item-label::before {
    content: '';
    display: block;
    width: 8px;
    height: 8px;
    background-color: var(--current-theme-color); /* 跟隨主題色 */
    border-radius: 50%;
    opacity: 0.8;
}

/* 內容區塊樣式 */
.history-item-content {
    background-color: #fcfcfc;
    border: 1px solid #e1e4e8;
    /* 左側加上粗邊框，顏色跟隨主題，增強識別度 */
    border-left: 4px solid var(--current-theme-color); 
    border-radius: 4px; /* 稍微方一點，更有文件感 */
    padding: 12px 16px;
    font-size: 1rem;
    line-height: 1.8;
    color: #444;
    font-family: 'Noto Serif TC', serif;
    white-space: pre-wrap;
    word-break: break-word;
}

	/* === 歷史紀錄：標題原地編輯樣式 === */
.history-title {
    cursor: text; /* 提示用戶這是文字 */
    transition: background-color 0.2s;
    border-radius: 4px;
    padding: 2px 4px;
    margin: -2px -4px; /* 抵消 padding，保持位置不變 */
}

.history-title:hover {
    background-color: rgba(0, 0, 0, 0.05); /* 懸停時給一點提示 */
}

/* 編輯模式下的輸入框樣式 */
.history-title-input {
    font-family: 'Noto Serif TC', serif; /* 保持原有字體 */
    font-size: 1em; /* 保持原有大小 */
    font-weight: bold;
    color: #333;
    width: 100%;
    border: 1px solid #2A9689; /* 編輯時顯示綠色邊框 */
    border-radius: 4px;
    padding: 2px 4px;
    background-color: #fff;
    outline: none;
    box-shadow: 0 0 5px rgba(42, 150, 137, 0.3);
    margin: 0;
}

	/* === 新增：通用過渡動畫 === */
.fade-in-up {
    /* 使用 cubic-bezier 讓動畫更有質感，不是線性的死板移動 */
    animation: fadeUpEnter 0.5s cubic-bezier(0.19, 1, 0.22, 1) forwards;
    opacity: 0; /* 預設隱藏，由動畫控制變為可見 */
}

@keyframes fadeUpEnter {
    0% {
        opacity: 0;
        transform: translateY(15px) scale(0.98); /* 稍微縮小並向下偏移 */
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(1); /* 回復原狀 */
    }
}

	/* === 新增：頁面收縮退場動畫 === */
.page-exit-shrink {
    /* 0.4秒完成，使用 ease-in 讓開始慢結束快，感覺像被吸走 */
    animation: shrinkFadeOut 0.4s cubic-bezier(0.32, 0, 0.67, 0) forwards;
    transform-origin: center 20vh; /* 設定縮放中心點在視窗上方偏中，視覺更自然 */
    pointer-events: none; /* 動畫播放時禁止點擊，防止誤觸 */
}

@keyframes shrinkFadeOut {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    100% {
        opacity: 0;
        transform: scale(0.92) translateY(20px); /* 縮小並稍微往下沉 */
    }
}

/* === 新增：主頁選單進場特效 (配合退場) === */
.home-enter-pop {
    animation: popIn 0.5s cubic-bezier(0.19, 1, 0.22, 1) forwards;
    opacity: 0;
}

@keyframes popIn {
    0% {
        opacity: 0;
        transform: scale(1.05); /* 主頁從稍微放大的狀態回復，產生景深感 */
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

	/* 針對音樂播放器內的小選單進行微調 (改為簡約純淨風格) */
#music-player .controls select, 
#music-player .mode select {
    height: 30px !important;
    line-height: 26px !important;
    font-size: 14px !important;
    padding: 0 30px 0 10px !important; /* 右側留空間給箭頭 */
    
    /* === 樣式重置：去除原稿紙背景 === */
    background-color: rgba(255, 255, 255, 0.1) !important; /* 低調的半透明背景 */
    color: #fff !important; /* 白色文字 */
    border: 1px solid rgba(255, 255, 255, 0.2) !important; /* 極細的半透明邊框 */
    border-radius: 20px !important; /* 圓潤的膠囊狀 */
    box-shadow: none !important; /* 去除原本的紙張厚度陰影 */
    
    /* === 僅保留白色箭頭 === */
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e") !important;
    background-repeat: no-repeat !important;
    background-position: right 8px center !important;
    background-size: 14px 14px !important;
    
    transition: all 0.3s ease;
}

/* 互動效果：滑鼠懸停時 */
#music-player .controls select:hover, 
#music-player .mode select:hover {
    background-color: rgba(255, 255, 255, 0.2) !important; /* 稍微變亮 */
    border-color: rgba(255, 255, 255, 0.5) !important;
    transform: translateY(0) !important; /* 取消原有的浮起效果，保持穩定 */
}

/* 確保下拉後的選項是深色底 (避免在某些瀏覽器變白底黑字) */
#music-player select option {
    background-color: #333;
    color: white;
    padding: 5px;
}

/* === 學生雲端中心：全新課業列表樣式 === */

/* =======================================================
   === 雲端中心：Note Card 打洞風格 (莫蘭迪色系 V3) ===
   ======================================================= */

/* 1. 基礎卡片構造 (Note Card) */
.task-card {
    /* 基礎紙張設定 */
    background-color: #fdfcf8;      /* 米白紙張底色 */
    border: 1px solid #e0ddd7;      /* 淺卡其細邊框 */
    border-radius: 8px;
    position: relative;
    overflow: hidden;
    padding: 20px 15px 20px 55px;   /* 左側留白給打洞區 */
    margin-bottom: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 4px 4px 0px rgba(0,0,0,0.03); /* 復古硬陰影 */

    /* 關鍵：打洞與分隔線背景 */
    background-image: 
        /* A. 垂直分隔線 */
        linear-gradient(to right, transparent 39px, #e0ddd7 40px, transparent 41px),
        /* B. 打洞效果 (模擬孔洞) */
        radial-gradient(circle at 20px 50%, #d1cdc5 6px, transparent 7px);
    
    background-size: 
        100% 100%, /* 分隔線撐滿 */
        100% 35px; /* 打洞重複間距 */
    
    background-repeat: 
        no-repeat,
        repeat-y;
        
    background-position: 
        0 0,
        0 12px;
}

/* 2. 頂部顏色條 (用來區分狀態) */
.task-card::before {
    content: '';
    position: absolute;
	background-color: var(--theme-color) !important;
    top: 0;
    left: 0;
    width: 100%;
    height: 6px; /* 頂部色條高度 */
    z-index: 1;
}



/* 3. 懸停效果 */
.task-card:hover {
    transform: translateY(-3px);
    box-shadow: 6px 6px 0px rgba(0,0,0,0.05);
    background-color: #fff; /* 稍微變亮 */
}

/* 4. 左側文字區塊優化 */
.task-info {
    display: flex;
    flex-direction: column;
    gap: 6px;
    flex-grow: 1;
    padding-right: 15px;
    z-index: 2; /* 確保在背景之上 */
}

.task-topic {
    font-family: 'Noto Serif TC', serif; /* 文藝字體 */
    font-weight: bold;
    font-size: 1.1rem;
    color: #4a4a4a;
}

.task-meta {
    font-family: 'Courier New', monospace; /* 打字機字體日期 */
    font-size: 0.85rem;
    color: #999;
    display: flex;
    align-items: center;
    gap: 10px;
}

.task-type-tag {
    font-family: sans-serif;
    font-size: 0.75rem;
    padding: 2px 8px;
    border-radius: 4px;
    background: #eee;
    color: #666;
    font-weight: normal;
    letter-spacing: 1px;
}

/* 5. 右側狀態膠囊 (Pill) 優化 */
.task-status {
    flex-shrink: 0;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    z-index: 2;
}

/* =========================================
   === 狀態配色定義 (莫蘭迪色系) ===
   ========================================= */

/* A. 未繳交 (豆沙紅) */
.status-pending::before {
    background-color: #d69a92; /* 頂部色條 */
}
.status-pending .task-status {
    background-color: #f7ebea; /* 淺豆沙底 */
    color: #a67069;            /* 深豆沙字 */
}
.status-pending .task-topic {
    color: #a67069;            /* 題目變色以示提醒 */
}

/* B. 待批改 (灰綠) */
.status-submitted::before {
    background-color: #8fa398; /* 頂部色條 */
}
.status-submitted .task-status {
    background-color: #e8edea; /* 淺灰綠底 */
    color: #5e7067;            /* 深灰綠字 */
}
.status-submitted .task-topic {
    color: #888;               /* 題目變灰 */
}

/* C. 已發還 (香芋紫) */
.status-returned::before {
    background-color: #b6a6ca; /* 頂部色條 */
}
.status-returned .task-status {
    background-color: #f0ebf5; /* 淺紫底 */
    color: #7e6f8f;            /* 深紫字 */
}
.status-returned .task-topic {
    color: #333;               /* 題目深灰 */
}

/* === 三種狀態的配色 === */


/* === 老師評語專用樣式 (嵌入在歷史紀錄 UI 中) === */
.teacher-feedback-section {
    background-color: #fffaf5; /* 極淡的米暖色背景 */
    border: 2px solid #e6dace; /* 淺卡其/奶茶色邊框 */
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 30px;
    position: relative;
    box-shadow: 0 4px 15px rgba(141, 110, 99, 0.08); /* 暖色系微陰影 */
    animation: slideDown 0.5s ease-out;
}

.teacher-feedback-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px dashed #d7ccc8; /* 淺褐色虛線 */
    padding-bottom: 10px;
    margin-bottom: 15px;
}

/* 標題文字顏色 */
.teacher-feedback-title {
    font-weight: bold; 
    font-size: 1.2rem; 
    color: #8d6e63; /* 莫蘭迪深褐色文字 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.teacher-score-badge {
    background-color: #d9534f; /* 保留紅色分數牌，突顯重點 */
    color: white;
    font-size: 1.5rem;
    font-weight: bold;
    padding: 5px 15px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    transform: rotate(-2deg);
}

.teacher-comment-content {
    font-size: 1.1rem;
    line-height: 1.8;
    color: #4e342e; /* 深咖啡色文字 */
    white-space: pre-wrap;
    word-break: break-word;
    margin: 0;
    padding: 0;
}

@keyframes slideDown {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

.teacher-feedback-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px dashed #ffb74d;
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.teacher-score-badge {
    background-color: #d9534f;
    color: white;
    font-size: 1.5rem;
    font-weight: bold;
    padding: 5px 15px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transform: rotate(-2deg); /* 蓋章效果 */
}

.teacher-comment-content {
    font-size: 1.1rem;
    line-height: 1.8;
    color: #5d4037;
    white-space: pre-wrap; /* 保留老師評語的換行 */
}



	/* === 新增：評語詳情彈窗樣式 === */
.feedback-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75);
    z-index: 10000; /* 確保在最上層 */
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
    backdrop-filter: blur(5px);
}

.feedback-modal-content {
    background-color: #fff;
    width: 100%;
    max-width: 700px;
    max-height: 90vh;
    border-radius: 12px;
    box-shadow: 0 15px 50px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
    animation: fadeIn 0.3s ease-out;
}

.feedback-header {
    padding: 15px 20px;
    background-color: #f8f9fa;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.feedback-header h3 {
    margin: 0;
    color: #2A9689;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.feedback-close-btn {
    background: #e9ecef; /* 明顯的按鈕背景 */
    border: none;
    color: #555;
    font-size: 1.5rem;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
}

.feedback-close-btn:hover {
    background-color: #d9534f;
    color: white;
    transform: rotate(90deg);
}

.feedback-body {
    padding: 20px;
    overflow-y: auto;
    flex-grow: 1;
}

/* 老師評語區塊 */
.teacher-comment-box {
    background-color: #fff8e1;
    border: 1px solid #ffe0b2;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 20px;
    line-height: 1.6;
    color: #5d4037;
    position: relative;
}

.teacher-comment-box::before {
    content: '老師回饋';
    position: absolute;
    top: -10px;
    left: 15px;
    background: #ff9800;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
}

/* 學生原稿區塊 */
.original-work-box {
    background-color: #fdfdfd;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    margin-top: 10px;
}

.original-work-summary {
    padding: 12px 15px;
    cursor: pointer;
    font-weight: bold;
    color: #555;
    background-color: #f1f1f1;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: background 0.2s;
}

.original-work-summary:hover {
    background-color: #e2e6ea;
}

.original-work-content {
    padding: 15px;
    white-space: pre-wrap;
    font-family: 'Noto Serif TC', serif;
    color: #333;
    line-height: 1.8;
    border-top: 1px solid #eee;
}

@keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
}

	/* ============================================
   === 學生雲端中心：全螢幕模式 (App 風格) ===
   ============================================ */

/* 1. 強制讓內容容器填滿整個視窗 */
#studentCloudModal .modal-content {
    width: 100% !important;
    height: 100% !important;
    max-width: none !important;  /* 移除原本的寬度限制 */
    max-height: none !important; /* 移除高度限制 */
    margin: 0 !important;        /* 移除置中邊距 */
    border-radius: 0 !important; /* 移除圓角，更像原生頁面 */
    border: none !important;     /* 移除邊框 */
    display: flex;               /* 使用 Flexbox 佈局 */
    flex-direction: column;      /* 垂直排列內容 */
    box-sizing: border-box;
    padding: 20px;               /* 保持內距 */
}

/* 2. 調整關閉按鈕的位置，讓它更大、更顯眼 */
#studentCloudModal .close-modal-btn {
    top: 15px;
    right: 20px;
    font-size: 36px; /* 加大按鈕 */
    z-index: 10;
}

/* 3. 調整登入後的面板，讓它佔滿剩餘空間 */
/* === 修正：學生雲端面板 (第 2054 行附近) === */
#studentCloudPanel {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    margin-top: 10px !important;
    /* 原本是 overflow: hidden; 這導致了無法滾動，必須改為 visible */
    overflow: visible !important; 
    height: auto !important; /* 確保高度自動撐開 */
}

/* 4. 關鍵優化：讓課業列表自動延伸，並在內部滾動 */
/* 原本設定了 max-height: 250px，全螢幕模式下這會太短，所以要移除限制 */
#studentCloudModal #assignmentList {
    max-height: none !important;  /* 移除任何高度限制 */
    height: auto !important;      /* 高度隨內容自動變長 */
    overflow-y: visible !important; /* 內部不需要滾動條，直接撐開 */
    flex-grow: 0 !important;      /* 不要自動填滿，避免計算錯誤 */
    padding-bottom: 120px !important; /* ★關鍵：增加大量底部留白，防止手機版被底部導航列或邊緣遮擋 */
    border: none !important;
}

/* 5. 針對手機版的微調 */
@media (max-width: 600px) {
    #studentCloudModal .modal-content {
        padding: 15px;
    }
}

	/* === 區塊分隔線 (老師回饋 vs 學生作業) === */
.feedback-separator {
    position: relative;
    height: 1px;
    margin: 40px 0; /* 上下大幅留白，區隔兩者 */
    border: none;
    border-top: 2px dashed #d7ccc8; /* 淺褐色虛線 */
    text-align: center;
    overflow: visible;
}

.feedback-separator::after {
    content: '▼ 提交內容'; /* 中央提示文字 */
    position: absolute;
    top: -12px; /* 垂直置中 */
    left: 50%;
    transform: translateX(-50%);
    background-color: #fff; /* 白底蓋住虛線 */
    padding: 0 15px;
    color: #a1887f; /* 莫蘭迪淺褐文字 */
    font-size: 0.85rem;
    font-weight: bold;
    letter-spacing: 1px;
}

	/* =======================================================
   === 學生雲端中心：全螢幕鎖定樣式 (App 風格修正版) ===
   ======================================================= */

/* 1. 外層容器：變成全螢幕視窗，負責處理滾動 */
#studentCloudModal {
    position: fixed !important;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    background-color: #fdfcf8 !important; /* 設定背景色，避免透明 */
    z-index: 10050 !important; /* 確保在最上層 */
    padding: 0 !important;
    
    /* 關鍵：讓容器自己產生滾動條，而不是內容 */
    overflow-y: auto !important; 
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch; /* 讓 iOS 滾動更順滑 */
    
    /* 佈局重置：移除置中，改為自然流動 */
    display: none; /* 預設隱藏，由 JS 控制 */
    align-items: flex-start !important;
    justify-content: flex-start !important;
}

/* 2. 內容區域：撐滿寬度，移除圓角 */
#studentCloudModal .modal-content {
    width: 100% !important;
    max-width: 100% !important;
    min-height: 100% !important; /* 確保高度至少填滿螢幕 */
    margin: 0 !important;
    border: none !important;
    border-radius: 0 !important;
    box-shadow: none !important;
    background-color: transparent !important; /* 背景由外層決定 */
    padding: 20px 20px 80px 20px !important; /* 底部留白，方便手機操作 */
    box-sizing: border-box;
    
    /* 確保內部元素排列 */
    display: flex;
    flex-direction: column;
}

/* 3. 調整關閉按鈕位置 (固定在右上角，不會隨頁面滾動消失) */
#studentCloudModal .close-modal-btn {
    position: fixed !important; /* 固定定位 */
    top: 20px;
    right: 20px;
    background-color: rgba(255, 255, 255, 0.8);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 10060;
}

	/* ==========================================
   === 確保側邊選單在全螢幕模式下依然可見 ===
   ========================================== */

/* 1. 提高漢堡按鈕的層級 (原為 9998，全螢幕視窗為 10050) */
#sideMenuToggle {
    z-index: 20000 !important; 
}

/* 2. 提高選單展開後的層級 */
.side-menu-overlay {
    z-index: 20001 !important;
}

/* 3. 確保返回主頁按鈕的層級也足夠高 (以防萬一) */
#homeBtn, #sideMenuHomeBtn {
    z-index: 20000 !important;
}

	/* === 修訂：評語視窗層級提升 (解決被課業狀態遮擋的問題) === */
#historyModal, 
.preview-modal-overlay,
.feedback-modal-overlay {
    z-index: 20000 !important; /* 確保高於 studentCloudModal 的 10050 */
}

/* === 修訂：學生雲端中心 全屏設計與排版優化 (仿照語薈風格) === */
#studentCloudModal {
    background-color: #f5f5f3 !important; /* 語薈的米色背景 */
    padding: 0 !important;
}

#studentCloudModal .modal-content {
    background-color: transparent !important;
    width: 100% !important;
    max-width: 800px !important; /* 限制最大寬度，避免電腦版太寬 */
    margin: 0 auto !important;
    height: 100% !important;
    border-radius: 0 !important;
    box-shadow: none !important;
    padding: 80px 20px 20px 20px !important; /* 關鍵：頂部留 80px 空間給關閉鍵，防止重疊 */
    display: flex;
    flex-direction: column;
    justify-content: flex-start; /* 內容從上方開始 */
}

/* 關閉按鈕樣式優化 (與語薈一致) */
#studentCloudModal .close-modal-btn {
    position: fixed !important;
    top: 25px !important;
    right: 25px !important;
    background-color: transparent !important;
    border: none !important;
    color: #333 !important;
    font-size: 2.5rem !important;
    width: auto !important;
    height: auto !important;
    line-height: 1 !important;
    z-index: 10060 !important;
    box-shadow: none !important;
    cursor: pointer;
    transition: color 0.3s;
}

#studentCloudModal .close-modal-btn:hover {
    color: #d32f2f !important;
    background-color: transparent !important;
}

	/* === 修復：繳交課業選擇視窗 (層級與響應式優化) === */
#submitAssignmentModal {
    z-index: 25000 !important; /* 確保高於歷史紀錄 (20000) 和其他元素 */
    padding: 0 20px; /* 關鍵：左右留白，確保手機版不貼邊 */
    box-sizing: border-box; /* 確保 padding 不會撐大寬度 */
    display: none; /* 預設隱藏 */
    justify-content: center; /* 垂直居中 */
    align-items: center;     /* 水平居中 */
}

#submitAssignmentModal .modal-content {
    width: 100%;
    max-width: 450px; /* 限制電腦版最大寬度，比較精緻 */
    margin: auto; /* 確保在 Flex 容器中居中 */
    max-height: 85vh; /* 防止高度溢出 */
    display: flex;
    flex-direction: column;
    border-radius: 12px; /* 圓角更柔和 */
    box-shadow: 0 10px 30px rgba(0,0,0,0.3); /* 增加立體感 */
}

/* === 新增：莫蘭迪色系按鈕樣式 === */
.btn-morandi {
    /* 莫蘭迪暖棕色/陶土色，低飽和度，看起來舒服高級 */
    background-color: #a1887f !important; 
    background-image: linear-gradient(135deg, #bcaaa4 0%, #8d6e63 100%) !important;
    color: #fff !important;
    border: none !important;
    padding: 10px 20px !important;
    font-size: 1rem !important;
    border-radius: 8px !important;
    box-shadow: 0 4px 10px rgba(141, 110, 99, 0.3) !important;
    transition: all 0.3s ease !important;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-family: 'Noto Serif TC', serif;
}

.btn-morandi:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(141, 110, 99, 0.4) !important;
    filter: brightness(105%);
}

.btn-morandi:active {
    transform: translateY(0);
}

	/* ========================================= */
/* === 大綱結果表格美化 (原稿紙風格) === */
/* ========================================= */

/* 針對 敘事抒情(rewriteTable) 和 議論(argumentRewriteTable) 的改寫表格 */
/* 同時也美化點評表格 (commentTable, argumentCommentTable) 以保持一致 */
#rewriteTable td, #commentTable td,
#argumentRewriteTable td, #argumentCommentTable td {
    /* 1. 基礎字體與排版 (與輸入框一致) */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 18px !important;       
    line-height: 40px !important;     /* 關鍵：配合格線高度 */
    color: #2c3e50;                   
    letter-spacing: 1px;              
    
    /* 2. 原稿紙背景 (40px 高) */
    background-color: #fffcf6 !important;        
    background-image: 
        linear-gradient(transparent 39px, rgba(42, 150, 137, 0.2) 39px, rgba(42, 150, 137, 0.2) 40px, transparent 40px),
        linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.02) 39px, rgba(0,0,0,0.02) 40px, transparent 40px) !important;
    background-size: 40px 40px !important;       
    background-attachment: local;     
    
    /* 3. 邊框與間距 */
    border: 1px solid #8baea8 !important;        
    padding: 0 15px !important;       
    vertical-align: top; /* 文字靠上對齊 */
    
    /* 確保文字對齊格線 */
    white-space: pre-wrap; /* 保留換行 */
}

/* 表頭樣式美化 */
#rewriteTable th, #commentTable th,
#argumentRewriteTable th, #argumentCommentTable th {
    background-color: #2A9689 !important;
    color: white !important;
    font-weight: bold;
    border: 1px solid #1e7e72 !important;
    padding: 10px;
    font-size: 1.1em;
}

/* === 手機版響應式調整 (格線縮小) === */
@media (max-width: 600px) {
    #rewriteTable td, #commentTable td,
    #argumentRewriteTable td, #argumentCommentTable td {
        font-size: 16px !important;
        line-height: 32px !important; /* 手機版行高 */
        
        /* 手機版背景格線 (32px) */
        background-image: 
            linear-gradient(transparent 31px, rgba(42, 150, 137, 0.2) 31px, rgba(42, 150, 137, 0.2) 32px, transparent 32px),
            linear-gradient(90deg, transparent 31px, rgba(0,0,0,0.02) 31px, rgba(0,0,0,0.02) 32px, transparent 32px) !important;
        background-size: 32px 32px !important;
        
        padding: 0 8px !important;
    }
}

/* ========================================= */
/* === 大綱表格寬度優化 (V3 - 平衡版) === */
/* ========================================= */

/* 1. 統一「結構段重點/論點」(第二欄) 的寬度設定 */
/* 設定為 150px，與點評表格保持一致 */
#commentTable th:nth-child(2), #commentTable td:nth-child(2),
#argumentCommentTable th:nth-child(2), #argumentCommentTable td:nth-child(2),
#rewriteTable th:nth-child(2), #rewriteTable td:nth-child(2),
#argumentRewriteTable th:nth-child(2), #argumentRewriteTable td:nth-child(2) {
    min-width: 150px !important; 
    max-width: 300px !important; /* 限制最大寬度，避免太寬 */
    width: auto !important;
}

/* 2. 統一「情節大要/論據及論證」(第三欄) 的寬度設定 */
/* 設定為 280px，既能橫向伸展減少高度，又不會過寬 */
#commentTable th:nth-child(3), #commentTable td:nth-child(3),
#argumentCommentTable th:nth-child(3), #argumentCommentTable td:nth-child(3),
#rewriteTable th:nth-child(3), #rewriteTable td:nth-child(3),
#argumentRewriteTable th:nth-child(3), #argumentRewriteTable td:nth-child(3) {
    min-width: 180px !important; /* <--- 修改這裡，從 280px 改小 */
    width: auto !important;
}

/* 3. 確保原稿紙背景樣式 (通用) */
#rewriteTable td, #commentTable td,
#argumentRewriteTable td, #argumentCommentTable td {
    background-attachment: local !important; 
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 18px !important;       
    line-height: 40px !important;     
    color: #2c3e50;                   
    letter-spacing: 1px;              
    
    /* 原稿紙背景 (40px 高) */
    background-color: #fffcf6 !important;        
    background-image: 
        linear-gradient(transparent 39px, rgba(42, 150, 137, 0.2) 39px, rgba(42, 150, 137, 0.2) 40px, transparent 40px),
        linear-gradient(90deg, transparent 39px, rgba(0,0,0,0.02) 39px, rgba(0,0,0,0.02) 40px, transparent 40px) !important;
    background-size: 40px 40px !important;       
    
    border: 1px solid #8baea8 !important;        
    padding: 0 15px !important;       
    vertical-align: top;
    white-space: pre-wrap; 
}

/* 表頭樣式 */
#rewriteTable th, #commentTable th,
#argumentRewriteTable th, #argumentCommentTable th {
    background-color: #2A9689 !important;
    color: white !important;
    font-weight: bold;
    border: 1px solid #1e7e72 !important;
    padding: 10px;
    font-size: 1.1em;
    white-space: nowrap; 
}

/* 手機版微調 */
@media (max-width: 600px) {
    #rewriteTable td, #commentTable td,
    #argumentRewriteTable td, #argumentCommentTable td {
        font-size: 16px !important;
        line-height: 32px !important;
        background-image: 
            linear-gradient(transparent 31px, rgba(42, 150, 137, 0.2) 31px, rgba(42, 150, 137, 0.2) 32px, transparent 32px),
            linear-gradient(90deg, transparent 31px, rgba(0,0,0,0.02) 31px, rgba(0,0,0,0.02) 32px, transparent 32px) !important;
        background-size: 32px 32px !important;
    }
}


/* === 加載動畫覆蓋層樣式 === */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 252, 245, 0.92); /* 米白色半透明背景 */
    backdrop-filter: blur(5px); /* 毛玻璃效果 */
    z-index: 99999; /* 確保在最上層 */
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    flex-direction: column;
    animation: fadeIn 0.3s ease-in-out;
}

.loading-content {
    text-align: center;
    transform: translateY(-50px);
    width: 100%;          /* 確保容器撐滿 */
    padding: 0 20px;      /* 左右保留 20px 的安全邊距，不讓文字撞牆 */
    box-sizing: border-box; 
    display: flex;
    flex-direction: column;
    align-items: center;
}

.loading-gif {
    width: 280px; /* 根據你的 GIF 大小調整 */
    height: auto;
    margin-bottom: 25px;
    opacity: 0.8;
}

.loading-text {
    font-family: 'Noto Serif TC', serif;
    /* 核心修改：自動縮放字體大小 */
    font-size: clamp(1.2rem, 5vw, 2.2rem); 
    font-weight: 700;
    color: #2A9689;
    
    /* 核心修改：不分行 */
    white-space: nowrap; 
    
    /* 核心修改：字距也改為動態，避免在小螢幕太撐 */
    letter-spacing: clamp(2px, 1vw, 6px); 
    
    text-shadow: 0 2px 10px rgba(42, 150, 137, 0.2);
    animation: pulseText 2s infinite ease-in-out;
}
@keyframes pulseText {
    0% { opacity: 0.6; transform: scale(0.98); }
    50% { opacity: 1; transform: scale(1); }
    100% { opacity: 0.6; transform: scale(0.98); }
}


	/* === 生成結果畫布專用樣式 === */
.result-canvas-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(245, 245, 243, 0.98); /* 接近語薈的米色底 */
    z-index: 30000; /* 確保在最頂層 */
    display: none; /* 預設隱藏 */
    overflow-y: auto;
    animation: fadeIn 0.4s ease-out;
}

.result-canvas-content {
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

.result-canvas-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 0;
    border-bottom: 2px solid #2A9689;
    margin-bottom: 20px;
    position: sticky;
    top: 0;
    background: rgba(245, 245, 243, 0.95);
    z-index: 10;
}

#resultCanvasTitle {
    font-size: 1.4rem;
    font-weight: bold;
    color: #2A9689;
    font-family: 'Noto Serif TC', serif;
}

.result-canvas-close {
    background-color: #d9534f;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 8px;
}

.result-canvas-close:hover {
    background-color: #c9302c;
    transform: scale(1.05);
}

.result-canvas-body {
    flex-grow: 1;
    /* 這裡會繼承原本的結果樣式，如表格、點評卡片等 */
}

/* 確保畫布內的雷達圖容器高度正確 */
.result-canvas-body .radar-chart-container {
    height: 350px;
    margin-bottom: 20px;
}

@media (max-width: 600px) {
    .result-canvas-content { padding: 15px; }
    #resultCanvasTitle { font-size: 1.1rem; }
}

	/* === 新增：學生登出按鈕樣式 === */
.logout-icon-btn {
    background-color: #ef9a9a; /* 莫蘭迪淡紅色 */
    color: white;
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin-left: 10px; /* 與歡迎文字保持距離 */
    font-size: 14px;
    vertical-align: middle;
}

.logout-icon-btn:hover {
    background-color: #e53935; /* 懸停時變深紅 */
    transform: scale(1.15) rotate(90deg); /* 懸停時稍微旋轉放大 */
    box-shadow: 0 4px 8px rgba(229, 57, 53, 0.3);
}

	/* === 通知系統 UI === */
/* === 持久性通知系統 - 精緻排版版 === */
.sansi-notification-container {
    position: fixed;
    top: 25px;
    right: 20px;
    z-index: 100005;
    display: flex;
    flex-direction: column;
    gap: 18px;
    pointer-events: none;
}

.sansi-notification {
    pointer-events: auto;
    width: 300px;
    background-color: #fdfcf8;
    border: 1px solid #e0ddd7;
    border-radius: 12px;
    padding: 15px 15px 15px 50px; /* 增加左邊距給打洞區 */
    box-shadow: 0 15px 35px rgba(0,0,0,0.12);
    position: relative;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
    animation: notifIn 0.6s cubic-bezier(0.23, 1, 0.32, 1) forwards;
    
    /* 強化原稿紙打洞風格 */
    background-image: radial-gradient(circle at 22px 50%, #d1cdc5 6px, transparent 7px);
    background-size: 100% 35px;
    background-repeat: repeat-y;
}

@keyframes notifIn {
    from { opacity: 0; transform: translateX(80px) scale(0.9); }
    to { opacity: 1; transform: translateX(0) scale(1); }
}

.sansi-notification:hover {
    transform: translateY(-5px);
    box-shadow: 0 20px 40px rgba(0,0,0,0.18);
    background-color: #fff;
}

/* 頂部彩色裝飾線條 */
.sansi-notification::before {
    content: '';
    position: absolute;
    top: 0; left: 0; width: 100%; height: 6px;
    border-radius: 12px 12px 0 0;
}

/* 性質標籤樣式 */
.notif-badge {
    display: inline-block;
    padding: 2px 10px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
    letter-spacing: 1px;
    margin-bottom: 8px;
}

/* 莫蘭迪性質分類 - 修改版 */
/* 上方色條改為讀取變數，以便與課業列表的莫蘭迪色系一致 */
.sansi-notification::before { background-color: var(--theme-color) !important; }

/* 標籤與圖示顏色保持原有的性質區分 (紅色代表新，紫色代表發還)，不做變動 */
.notif-new .notif-badge { background-color: #f7ebea; color: #a67069; }
.notif-new .notif-icon { color: #d69a92; }

.notif-returned .notif-badge { background-color: #f0ebf5; color: #7e6f8f; }
.notif-returned .notif-icon { color: #b6a6ca; }

/* 內容排版 */
.notif-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
}

.notif-topic {
    font-family: 'Noto Serif TC', serif;
    font-weight: 700;
    font-size: 1.1rem;
    color: #333;
    line-height: 1.4;
    margin: 4px 0 8px 0;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

.notif-desc {
    font-size: 0.88rem;
    color: #777;
    line-height: 1.6;
    border-top: 1px dashed #eee;
    padding-top: 8px;
}

.notif-footer {
    margin-top: 10px;
    font-size: 0.75rem;
    color: #aaa;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 5px;
}

.notif-icon {
    font-size: 0.9rem;
}

/* === 雲端按鈕與紅點樣式修正 === */

/* 1. 確保按鈕本身是相對定位，讓紅點可以依附在它右上角 */
#sideMenuCloudBtn {
    position: relative !important; 
    overflow: visible !important; /* 確保紅點不會被切掉 */
}

/* 2. 紅點樣式 (呼吸燈效果) */
.notification-badge {
    display: none; /* 預設隱藏，由 JS 控制顯示 */
    position: absolute;
    top: 5px;          /* 距離頂部 */
    right: 5px;        /* 距離右邊 */
    width: 10px;
    height: 10px;
    background-color: #ff4444; /* 鮮豔紅 */
    border-radius: 50%;
    border: 2px solid #333;    /* 與深色背景區隔的邊框 */
    box-shadow: 0 0 5px rgba(255, 68, 68, 0.8);
    z-index: 100;
    pointer-events: none;      /* 讓紅點不影響點擊 */
    animation: badgePulse 2s infinite;
}

/* 紅點呼吸動畫 */
@keyframes badgePulse {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7); }
    70% { transform: scale(1.2); box-shadow: 0 0 0 4px rgba(255, 68, 68, 0); }
    100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
}


/* === 學習報告專用樣式 (莫蘭迪簡約風) === */
.report-section {
    margin-bottom: 40px;
    animation: fadeIn 0.5s ease;
}

.report-header {
    border-left: 5px solid #8fa398; /* 莫蘭迪灰綠 */
    padding-left: 15px;
    margin-bottom: 20px;
}

.report-header h3 {
    margin: 0;
    color: #5e7067;
    font-size: 1.4rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* 文字分析卡片 (無標題、無醜陋圖示) */
.report-text-card {
    background-color: #fdfcf8;
    border: 1px solid #e0ddd7;
    border-radius: 8px;
    padding: 20px;
    margin-top: 15px;
    line-height: 1.8;
    color: #555;
    font-size: 1rem;
    box-shadow: 0 2px 10px rgba(0,0,0,0.03);
    text-align: justify;
}

/* 強調文字樣式 */
.report-highlight {
    font-weight: bold;
    color: #94a7b5; /* 莫蘭迪霧霾藍 */
    border-bottom: 1px dashed #94a7b5;
}

/* 金句樣式 (靠左) */
.report-quote {
    margin-top: 30px;
    padding: 15px 20px;
    background-color: rgba(143, 163, 152, 0.1);
    border-radius: 8px;
    color: #5e7067;
    font-style: italic;
    font-weight: bold;
    text-align: left; /* 靠左對齊 */
    border-left: 4px solid #8fa398;
}

/* 確保雷達圖容器高度足夠 */
.report-radar-wrapper {
    margin-top: 20px;
    margin-bottom: 30px;
}


	/* ==========================================
   === 學習報告專用樣式 (V2 - 視覺分層版) ===
   ========================================== */

.report-section {
    margin-bottom: 50px; /* 增加間距，讓各範疇區隔更明顯 */
    animation: fadeIn 0.5s ease;
}

/* 1. 範疇標題 (膠囊型標籤，視覺上明確區分層級) */
.report-category-badge {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 10px 25px;
    border-radius: 50px;
    color: white;
    font-weight: bold;
    font-size: 1.3rem;
    margin-bottom: 20px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    letter-spacing: 1px;
}

/* 各範疇專屬顏色 (莫蘭迪色系加深版，確保白字清晰) */
.badge-narrative { background-color: #7da3c0; /* 藍 */ }
.badge-argument  { background-color: #a692c2; /* 紫 */ }
.badge-reading   { background-color: #8da399; /* 綠 */ }
.badge-expand    { background-color: #d69a92; /* 紅 */ }
.badge-general   { background-color: #5e7067; /* 深灰綠 */ }

/* 2. 文字分析卡片 (簡約米色) */
.report-text-card {
    background-color: #fdfcf8;
    border: 1px solid #e0ddd7;
    border-radius: 12px;
    padding: 25px;
    line-height: 1.9;
    color: #4a4a4a;
    font-size: 1.05rem;
    box-shadow: 0 4px 15px rgba(0,0,0,0.03);
    text-align: justify;
    margin-top: 10px;
}

/* 3. 金句專用容器 (Note Card 打孔風格) */
.report-quote-card {
    position: relative;
    background-color: #fffefb;
    border: 1px solid #e0ddd7;
    border-radius: 8px;
    padding: 30px 30px 30px 65px; /* 左側留白給打孔 */
    margin-top: 40px;
    box-shadow: 4px 4px 0px rgba(0,0,0,0.05);
    text-align: left; /* 靠左對齊 */
    
    /* 打孔與紅線特效 */
    background-image: 
        /* 垂直紅線 */
        linear-gradient(to right, transparent 49px, #eebdbd 50px, transparent 51px),
        /* 圓形打孔 */
        radial-gradient(circle at 25px 50%, #d1cdc5 8px, transparent 9px);
        
    background-size: 
        100% 100%,  /* 線條 */
        100% 40px;  /* 打孔重複間距 */
        
    background-repeat: 
        no-repeat,
        repeat-y;
        
    background-position: 
        0 0,
        0 15px; /* 打孔起始位置 */
}

/* 金句文字樣式 */
.report-quote-content {
    font-family: 'Noto Serif TC', serif;
    font-size: 1.2rem;
    font-weight: bold;
    color: #5d4037; /* 深咖啡色 */
    font-style: italic;
    line-height: 1.6;
}

.report-quote-author {
    margin-top: 10px;
    font-size: 0.9rem;
    color: #888;
    text-align: right;
    font-style: normal;
}

/* 雷達圖容器修正 */
.report-radar-wrapper {
    margin-bottom: 30px;
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    border: 1px solid #eee;
}


	/* === 學習報告專用樣式 (V3 - 最終修正版) === */

/* 1. 整體概況 (最高層級：全寬、置中、深色背景) */
.badge-general {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px 10px;
    margin-bottom: 10px;

    /* === 修改重點開始：無印風．暖麻米色 (Muji Linen) === */
    /* 這種漸層模擬了無印良品常見的未漂白棉麻或再生紙的質感 */
    background: linear-gradient(135deg, #C5B4A1 0%, #A99885 100%) !important; 
    
    /* 陰影調整為淡淡的暖棕色，讓卡片浮起得更自然 */
    box-shadow: 0 8px 20px rgba(169, 152, 133, 0.35) !important; 
    
    border-bottom: none !important; 
    /* === 修改重點結束 === */

    color: white; /* 白色文字在這個底色上依然清晰 */
    border-radius: 12px;
    position: relative;
    overflow: hidden;
}

/* 2. 其他主範疇 (膠囊型，靠左) */
.report-category-badge {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 10px 25px;
    border-radius: 50px;
    color: white;
    font-weight: bold;
    font-size: 1.2rem;
    margin-bottom: 20px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    letter-spacing: 1px;
}
/* 範疇顏色 */
.badge-narrative { background-color: #7da3c0; } /* 敘事-藍 */
.badge-argument  { background-color: #a692c2; } /* 議論-紫 */
.badge-reading   { background-color: #8da399; } /* 閱讀-綠 */
.badge-expand    { background-color: #d69a92; } /* 拓展-紅 */

/* 3. 確保雷達圖容器與文章點評一致 */
.report-radar-wrapper .grading-container {
    margin-top: 0;
    padding-top: 0;
    border-top: none;
}

	/* === 1. 修復手機版整體概況寬度溢出 === */
.badge-general {
    /* 確保寬度不超過父容器，並預留內距 */
    width: 100%;
    max-width: 100%; 
    box-sizing: border-box; /* 關鍵：讓 padding 包含在寬度內 */
    
    display: flex;
    justify-content: center;
    padding: 15px 10px; /* 左右內距稍微縮小 */
    margin-bottom: 30px;
    background-color: #5e7067;
    color: white;
    font-size: 1.6rem;
    font-weight: bold;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    letter-spacing: 2px;
    border-bottom: 4px solid #46544d;
    
    /* 強制文字換行，防止長標題撐開 */
    white-space: normal; 
    text-align: center;
}

/* 手機版字體微調 */
@media (max-width: 600px) {
    .badge-general {
        font-size: 1.3rem; /* 手機上字體稍微縮小 */
        padding: 12px 5px;
    }
}

/* === 2. 報告操作選擇視窗 (半屏 Bottom Sheet 風格) === */
.report-menu-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 10000;
    display: none;
    align-items: flex-end; /* 靠底對齊 */
    justify-content: center;
    backdrop-filter: blur(3px);
}

.report-menu-content {
    background: #fdfcf8;
    width: 100%;
    max-width: 600px; /* 電腦版限制寬度 */
    border-radius: 20px 20px 0 0; /* 上方圓角 */
    padding: 30px 20px 50px 20px;
    box-shadow: 0 -5px 25px rgba(0,0,0,0.15);
    animation: slideUp 0.3s ease-out;
    border-top: 5px solid #8fa398;
}

@keyframes slideUp {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
}

.report-menu-title {
    text-align: center;
    color: #5e7067;
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 25px;
    border-bottom: 1px dashed #ccc;
    padding-bottom: 10px;
}

.report-options-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

.report-option-card {
    background: white;
    border: 2px solid #e0ddd7;
    border-radius: 12px;
    padding: 25px 10px;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    color: #666;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}

.report-option-card:hover {
    transform: translateY(-5px);
    border-color: #8fa398;
    color: #8fa398;
    box-shadow: 0 5px 15px rgba(0,0,0,0.05);
}

.report-option-icon {
    font-size: 2rem;
    margin-bottom: 5px;
}

.report-option-text {
    font-weight: bold;
    font-size: 1.1rem;
}


/* ==========================================
   === 學習報告專用樣式 (V4 - 最終優化版) ===
   ========================================== */

/* 1. 整體概況標題容器 (增強版) */
.badge-general {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column; /* 改為垂直排列 */
    align-items: center;
    justify-content: center;
    padding: 20px 10px;
    margin-bottom: 10px; /* 減少下方間距，因為有分隔線 */
    background: linear-gradient(135deg, #5e7067 0%, #4b5e56 100%); /* 漸層背景 */
    color: white;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(94, 112, 103, 0.3);
    position: relative;
    overflow: hidden;
}

/* 標題文字 */
.badge-general-title {
    font-size: 1.6rem;
    font-weight: bold;
    letter-spacing: 2px;
    margin-bottom: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* 2. 綜合評級 (突出的視覺設計) */
.overall-grade-tag {
    background-color: #fff;
    color: #d9534f; /* 醒目的等級紅 */
    padding: 5px 25px;
    border-radius: 50px;
    font-size: 1.4rem;
    font-weight: 900;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    transform: scale(1);
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    border: 2px solid #d69a92; /* 莫蘭迪紅邊框 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.overall-grade-tag:hover {
    transform: scale(1.1);
}

.overall-grade-label {
    font-size: 0.8rem;
    color: #888;
    font-weight: normal;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* 3. 莫蘭迪色虛線分隔 */
.report-separator {
    position: relative;
    height: 1px;
    border: 0;
    border-top: 3px dashed #b6a6ca; /* 莫蘭迪紫 */
    margin: 40px 0 50px 0; /* 上下大幅留白 */
    opacity: 0.6;
}

/* 裝飾中間的小剪刀或圖示 (選用) */
.report-separator::after {
    content: '▼';
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    background: #fdfcf8; /* 背景色遮擋 */
    padding: 0 10px;
    color: #b6a6ca;
    font-size: 12px;
}

/* 4. 修復圖表佈局 (手機版強制垂直堆疊，不壓縮) */
@media (max-width: 768px) {
    /* 強制將左右兩欄變為單欄垂直排列 */
    .grading-grid {
        grid-template-columns: 1fr !important;
        gap: 30px !important;
    }
    
    /* 確保容器寬度填滿 */
    .grading-scores, .grading-radar {
        width: 100% !important;
        box-sizing: border-box !important;
        margin: 0 !important;
    }

    /* 確保雷達圖高度足夠 */
    .radar-chart-container {
        height: 300px !important; /* 給予固定高度 */
        width: 100% !important;
    }
    
    /* 手機字體微調 */
    .badge-general-title { font-size: 1.3rem; }
    .overall-grade-tag { font-size: 1.2rem; padding: 5px 20px; }
}

	/* ==========================================
   === 手機版顯示修復 (Mobile Responsiveness) ===
   ========================================== */
@media (max-width: 768px) {
    /* 1. 強制將「評分表」與「雷達圖」改為垂直排列 */
    .grading-grid {
        display: flex !important;       /* 使用 Flex 取代 Grid，控制力更好 */
        flex-direction: column !important; /* 垂直堆疊 */
        gap: 20px !important;           /* 上下間距 */
        width: 100% !important;
        margin: 0 !important;
    }

    /* 2. 限制容器寬度，防止溢出 */
    .grading-scores, 
    .grading-radar,
    .report-radar-wrapper {
        width: 100% !important;
        max-width: 100% !important;     /* 絕不超過螢幕寬 */
        box-sizing: border-box !important; /* 確保 padding 包含在寬度內 */
        padding: 15px !important;       /* 稍微減少內距 */
        margin: 0 !important;
        overflow: hidden !important;    /* 隱藏任何溢出的內容 */
    }

    /* 3. 修復雷達圖 Canvas 的響應式大小 */
    .radar-chart-container {
        position: relative !important;
        width: 100% !important;         /* 寬度撐滿容器 */
        height: auto !important;        /* 高度自動 */
        aspect-ratio: 1 / 1 !important; /* 保持正方形比例 */
        max-height: 350px !important;   /* 限制最大高度，避免在大手機上太長 */
        margin: 0 auto !important;
    }

    /* 4. 優化進度條區域 (避免標籤文字換行擠壓) */
    .score-item {
        display: flex !important;
        align-items: center !important;
        justify-content: space-between !important;
        gap: 10px !important;
    }

    .score-item label {
        font-size: 0.9rem !important;   /* 字體稍縮小 */
        white-space: nowrap !important; /* 防止文字換行 */
        min-width: 80px !important;     /* 給予最小寬度 */
    }

    .slider-container {
        flex-grow: 1 !important;        /* 讓進度條佔據剩餘空間 */
        width: auto !important;
    }

    /* 5. 確保標題和標籤也不會爆版 */
    .badge-general, 
    .report-category-badge {
        width: 100% !important;
        max-width: 100% !important;
        white-space: normal !important; /* 允許文字換行 */
        box-sizing: border-box !important;
    }
}

	/* ==========================================
   === 手機版顯示修復 (V2 - 標題置中不拉寬) ===
   ========================================== */
@media (max-width: 768px) {
    /* --- 1. 圖表與評分表佈局 (垂直堆疊) --- */
    .grading-grid {
        display: flex !important;
        flex-direction: column !important;
        gap: 20px !important;
        width: 100% !important;
        margin: 0 !important;
    }

    .grading-scores, 
    .grading-radar,
    .report-radar-wrapper {
        width: 100% !important;
        box-sizing: border-box !important;
        padding: 15px !important;
        margin: 0 !important;
        overflow: hidden !important;
    }

    .radar-chart-container {
        height: auto !important;
        aspect-ratio: 1 / 1 !important;
        max-height: 350px !important;
        margin: 0 auto !important;
    }

    /* --- 2. 標題樣式區分 (關鍵修正) --- */

    /* A. 整體概況 (最高層級)：強制拉寬 (100%)，方形圓角 */
    .badge-general {
        width: 100% !important;
        max-width: 100% !important;
        display: flex !important;
        flex-direction: column !important; /* 垂直排列內容 */
        align-items: center !important;
        
        box-sizing: border-box !important;
        padding: 20px 10px !important;
        margin-bottom: 30px !important;
        
        border-radius: 12px !important; /* 方形圓角，區別於膠囊 */
        text-align: center !important;
    }

    /* B. 一般範疇 (閱讀、議論等)：不拉寬 (fit-content) + 水平置中 + 膠囊狀 */
    /* ★★★ 使用 :not(.badge-general) 排除整體概況，避免衝突 ★★★ */
    .report-category-badge:not(.badge-general) {
        width: -moz-fit-content !important;
        width: fit-content !important;       /* 寬度只包住文字 */
        max-width: 90% !important;           /* 防止文字過長 */
        
        display: flex !important;
        justify-content: center !important;
        
        /* 關鍵：利用 margin auto 達成置中 */
        margin-left: auto !important;
        margin-right: auto !important;
        margin-bottom: 20px !important;
        
        border-radius: 50px !important;      /* 保持圓潤膠囊狀 */
        white-space: normal !important;
        text-align: center !important;
    }

    /* C. 進度條文字微調 */
    .score-item label {
        white-space: nowrap !important;
        min-width: 70px !important;
    }
}



	/* === 新增：雲端按鈕凍結狀態樣式 === */
.btn-frozen {
    opacity: 0.4 !important;           /* 降低透明度 */
    filter: grayscale(100%) !important; /* 變成灰色 */
    pointer-events: none !important;    /* 關鍵：徹底禁止滑鼠點擊事件 */
    cursor: wait !important;            /* 滑鼠移上去顯示等待圖示 */
    transform: scale(0.95);             /* 稍微縮小，視覺上感覺「凹陷/無效」 */
}

	/* === 安全版：只針對「課業列表」內的卡片生效 === */
/* 加上 #assignmentList 前綴，確保絕對不會影響到其他頁面的卡片 */
#assignmentList .task-card::before {
    background-color: var(--theme-color) !important;
}

	/* =======================================================
   === [新增] 修復改寫範例樣式 & 畫布聊天室樣式 ===
   ======================================================= */

/* 1. 改寫內容專用樣式 (已修正字體大小與行距) */
.rewrite-content {
    font-family: 'Noto Serif TC', serif !important;
    font-size: 1rem !important; /* 修正：由 1.1rem 改為 1rem，與點評一致 */
    line-height: 1.8 !important; /* 修正：微調行距 */
    color: #2c3e50 !important;
    white-space: pre-wrap !important;
    text-align: justify !important;
    background-color: #fff !important;
    padding: 20px !important;
    border-radius: 8px !important;
    border: 1px solid #e0e0e0 !important;
    margin-top: 10px;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.02);
}

/* 2. 結果畫布內的聊天室容器 (保持不變) */
.canvas-chat-container {
    margin-top: 50px;
    padding-top: 25px;
    border-top: 3px dashed #2A9689;
    animation: fadeIn 0.5s ease;
    background-color: #fcfdfd;
    padding-bottom: 20px;
}

/* 聊天室標題 */
.canvas-chat-header {
    color: #2A9689;
    font-size: 1.3rem;
    font-weight: bold;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* 聊天紀錄區域 */
.canvas-chat-history {
    background-color: #f0f4f8;
    border: 1px solid #d1d9e6;
    border-radius: 12px;
    padding: 20px;
    height: 300px; /* 固定高度 */
    overflow-y: auto;
    margin-bottom: 15px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* 輸入區域 */
.canvas-input-area {
    display: flex;
    gap: 10px;
    align-items: flex-start;
}

.canvas-input-area textarea {
    flex: 1;
    min-height: 50px;
    padding: 12px;
    border: 2px solid #ccc;
    border-radius: 8px;
    resize: vertical;
    font-size: 1rem;
    transition: border-color 0.3s;
    font-family: 'Noto Serif TC', serif;
}

.canvas-input-area textarea:focus {
    border-color: #2A9689;
    outline: none;
    box-shadow: 0 0 0 3px rgba(42, 150, 137, 0.2);
}

/* 發送按鈕 */
.canvas-send-btn {
    background-color: #2A9689;
    color: white;
    border: none;
    width: 55px;
    height: 55px;
    border-radius: 50%; /* 圓形 */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    transition: all 0.2s;
    flex-shrink: 0;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.canvas-send-btn:hover {
    background-color: #238074;
    transform: scale(1.1);
}

.canvas-send-btn:disabled {
    background-color: #ccc;
    cursor: not-allowed;
    transform: none;
}


	/* === 新增：詞彙/物象 網格展示樣式 === */
.vocab-grid {
    display: grid;
    /* 自動填滿，每格最小寬度 80px，適應手機與電腦 */
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 15px;
    padding: 15px 5px;
    margin-top: 10px;
}

.vocab-item {
    background-color: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px 5px;
    text-align: center;
    
    /* 字體設定：確保與主體一致 */
    font-family: 'Noto Serif TC', 'Songti TC', serif !important;
    font-size: 1.1rem !important;
    font-weight: 500;
    color: #555;
    
    box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    transition: all 0.3s ease;
    cursor: default;
    
    /* 防止長詞彙溢出 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.vocab-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 12px rgba(42, 150, 137, 0.15);
    border-color: #2A9689;
    color: #2A9689;
    font-weight: bold;
    background-color: #f0fdfc;
}

/* 針對改寫範例的標題修正，確保與上方一致 */
.rewrite-content {
    /* 再次確認字體大小與行距 */
    font-size: 1rem !important;
    line-height: 1.8 !important;
    font-family: 'Noto Serif TC', serif !important;
    color: #333 !important;
}


/* ========================================= */
/* === 取消生成 UI (莫蘭迪色系設計) === */
/* ========================================= */
 
/* 1. 純圖示取消鍵 (低調圓形按鈕) */
.cancel-icon-btn {
    margin-top: 30px;
    width: 46px;
    height: 46px;
    border-radius: 50%;
    background: transparent;
    border: 1px solid rgba(143, 163, 152, 0.6); /* 莫蘭迪灰綠邊框 */
    color: #8fa398;
    font-size: 1.2rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    backdrop-filter: blur(2px);
    pointer-events: auto; /* 確保可以點擊 */
}
 
.cancel-icon-btn:hover {
    background-color: rgba(143, 163, 152, 0.15);
    transform: rotate(90deg); /* 懸停時旋轉效果 */
    color: #5e7067;
    border-color: #5e7067;
    box-shadow: 0 0 15px rgba(143, 163, 152, 0.2);
}
 
/* 2. 確認視窗遮罩 (覆蓋在 Loading 之上) */
.morandi-modal-overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(253, 252, 248, 0.92); /* 米白遮罩，高模糊 */
    backdrop-filter: blur(8px);
    z-index: 20; /* 必須高於 loading-content */
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.3s ease;
}
 
/* 3. 視窗卡片本體 */
.morandi-modal-card {
    background: #fffcf6; /* 暖白紙張色 */
    padding: 30px 35px;
    border-radius: 16px;
    border: 1px solid #e0ddd7;
    box-shadow: 0 15px 40px rgba(141, 110, 99, 0.15); /* 暖色柔和陰影 */
    text-align: center;
    max-width: 85%;
    width: 340px;
    transform: translateY(0);
    animation: slideUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28); /* 彈性動畫 */
}
 
.morandi-title {
    color: #5d4037; /* 莫蘭迪深咖啡 */
    font-size: 1.3rem;
    margin: 0 0 12px 0;
    font-weight: bold;
    letter-spacing: 1px;
}
 
.morandi-text {
    color: #8d8d8d; /* 暖灰 */
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 25px;
}
 
/* 4. 按鈕群組 */
.morandi-btn-group {
    display: flex;
    gap: 15px;
    justify-content: center;
}
 
.morandi-btn {
    border: none;
    padding: 10px 24px;
    border-radius: 8px;
    font-size: 0.95rem;
    cursor: pointer;
    font-weight: bold;
    font-family: 'Noto Serif TC', serif;
    transition: transform 0.2s, filter 0.2s;
}
 
.morandi-btn:hover {
    transform: translateY(-2px);
    filter: brightness(105%);
}
 
.morandi-btn:active { transform: translateY(0); }
 
/* 灰色按鈕 (繼續等待) */
.btn-gray {
    background-color: #ececec;
    color: #777;
}
 
/* 紅色按鈕 (確認取消 - 豆沙紅) */
.btn-red {
    background-color: #d69a92;
    color: white;
    box-shadow: 0 4px 12px rgba(214, 154, 146, 0.4);
}
 
/* 動畫定義 */
@keyframes slideUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}


	/* ========================================= */
/* === [新增] 手機版確認視窗優化 === */
/* ========================================= */
@media (max-width: 600px) {
    .morandi-modal-card {
        /* 強制設定寬度為：螢幕總寬減去 80px (即左右各留 40px 的寬敞邊距) */
        width: calc(100% - 80px) !important;
        
        /* 移除原本的固定像素寬度限制 */
        max-width: none !important;
        
        /* 稍微縮小內邊距，讓文字在窄卡片中更有呼吸空間 */
        padding: 25px 20px !important;
    }
 
    /* 微調按鈕在手機上的間距 */
    .morandi-btn {
        padding: 10px 15px !important; /* 按鈕變稍微緊湊一點，防止換行 */
        font-size: 0.85rem !important;
        white-space: nowrap; /* 防止按鈕文字換行 */
    }
    
    .morandi-btn-group {
        gap: 10px !important; /* 縮小按鈕之間的距離 */
    }
}



/* === 手機版專用：莫蘭迪虛線與卡片修復 === */
@media (max-width: 600px) {
    /* 1. 虛線樣式 */
    .section-separator {
        display: block;
        width: 100%;
        height: 0;
        border-top: 5px dashed #a89f91; /* 莫蘭迪暖灰，很粗的虛線 */
        margin: 25px 0 15px 0;          /* 上下間距 */
        grid-column: 1 / -1;            /* 強制佔滿整行 */
        opacity: 0.6;
    }

    /* 2. 【關鍵修復】強制鎖定「課外書籍」為大卡片 */
    /* 使用 ID 選擇器，確保不會因為加了虛線而變形 */
    #booksBtn {
        grid-column: 1 / -1 !important;             /* 佔滿整行 */
        width: calc(120px * 2 + 24px) !important;   /* 兩張卡片寬 + 間距 */
        height: 130px !important;                   /* 設定高度 */
        max-width: none !important;
        margin: 0 auto !important;                  /* 置中 */
    }
    
    /* 調整大卡片內的文字大小 (保持您原本的設定) */
    #booksBtn .card-zh { font-size: 22px !important; }
    #booksBtn .card-en { font-size: 13px !important; }
    #booksBtn .card-icon-container { font-size: 34px !important; margin-top: 45px !important; }
}

/* 電腦版隱藏虛線 */
@media (min-width: 601px) {
    .section-separator { display: none; }
}


/* === 全局莫蘭迪 Alert 樣式 (手機版邊距優化版) === */
.sansi-alert-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(253, 252, 248, 0.6); /* 極淡米色遮罩 */
    backdrop-filter: blur(5px); /* 毛玻璃效果 */
    z-index: 2147483647; /* 最頂層 */
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.sansi-alert-box {
    background-color: #fdfcf8;
    border: 1px solid #e0ddd7;
    border-radius: 16px;
    box-shadow: 0 15px 40px rgba(141, 110, 99, 0.15);
    
    /* --- 關鍵修改開始 --- */
    width: auto;           /* 讓寬度自動適應，不強制固定 */
    max-width: 320px;      /* 電腦版最大限制寬度 */
    min-width: 260px;      /* 防止內容太少時縮得太小 */
    margin: 0 35px;        /* ★ 重點：手機版強制左右留白 35px，解決貼邊問題 */
    /* --- 關鍵修改結束 --- */

    padding: 25px;
    text-align: center;
    transform: translateY(20px);
    transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    position: relative;
    background-image: linear-gradient(to right, transparent 29px, #f2f0eb 30px, transparent 31px);
    background-size: 100% 100%;
}

.sansi-alert-icon {
    font-size: 2.5rem;
    color: #8fa398;
    margin-bottom: 15px;
}

.sansi-alert-message {
    font-family: 'Noto Serif TC', serif;
    font-size: 1.05rem;
    color: #5e5e5e;
    line-height: 1.6;
    margin-bottom: 25px;
    white-space: pre-wrap;
    word-break: break-word;
}

.sansi-alert-btn {
    background-color: #8fa398;
    color: white;
    border: none;
    padding: 10px 30px;
    border-radius: 50px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(143, 163, 152, 0.3);
    transition: all 0.2s ease;
    font-family: 'Noto Serif TC', serif;
}

.sansi-alert-btn:hover {
    background-color: #7d9186;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(143, 163, 152, 0.4);
}

.sansi-alert-show {
    opacity: 1;
}
.sansi-alert-show .sansi-alert-box {
    transform: translateY(0);
}

#classNumberUpdateModal .modal-content {
    padding: 0 20px; /* 添加左右20px的内边距 */
}

	@media (max-width: 480px) {
    #classNumberUpdateModal .modal-content {
        padding: 0 15px; /* 小屏幕设备使用稍小的内边距 */
    }
}

	/* 修改班號更新窗口的內容容器，增加上下內邊距 */
#classNumberUpdateModal .modal-content {
    padding: 30px 25px;  /* 上下30px，左右25px的內邊距 */
    box-sizing: border-box; /* 確保內邊距不會增加總寬度 */
}

/* 可選：如果需要進一步調整文字區域的上下間距 */
#classNumberUpdateModal .modal-content > div:first-child {
    margin-bottom: 25px; /* 增加標題區域與下方內容的距離 */
    padding-bottom: 10px; /* 增加標題區域底部的內邊距 */
    border-bottom: 1px solid #e9e5db; /* 可選：添加分隔線，增加視覺層次 */
}

/* 調整按鈕與選擇器之間的距離 */
#classNumberUpdateModal .modal-content button {
    margin-top: 15px; /* 增加按鈕上方邊距 */
}
	

/* === [新增] 歷史紀錄修訂功能樣式 === */
 
/* 1. 編輯模式下的視覺提示 */
[contenteditable="true"] {
    outline: none;
    border: 2px dashed #94a7b5 !important; /* 莫蘭迪藍虛線 */
    background-color: #fffcf6; /* 暖白底色 */
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    cursor: text;
}
 
/* 2. 莫蘭迪懸浮儲存鍵 (純圖案設計) */
.morandi-save-float-btn {
    position: fixed;
    bottom: 50px;
    right: 50px;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    
    /* 莫蘭迪灰綠漸層 */
    background: linear-gradient(135deg, #8fa398 0%, #7d9186 100%);
    color: white;
    
    border: none;
    box-shadow: 0 8px 25px rgba(143, 163, 152, 0.6);
    
    display: none; /* 預設隱藏 */
    align-items: center;
    justify-content: center;
    font-size: 1.6rem;
    cursor: pointer;
    z-index: 99999; /* 確保在最上層 */
    
    animation: floatPopIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transition: transform 0.2s ease, background 0.2s;
}
 
.morandi-save-float-btn:hover {
    transform: scale(1.1) rotate(15deg);
    background: linear-gradient(135deg, #9db1a6 0%, #8fa398 100%);
}
 
.morandi-save-float-btn:active {
    transform: scale(0.95);
}
 
@keyframes floatPopIn {
    from { opacity: 0; transform: scale(0); }
    to { opacity: 1; transform: scale(1); }
}

/* === 歷史紀錄操作按鈕區優化 === */
.history-actions {
    margin-top: 15px;
    display: flex;
    justify-content: flex-end;
    gap: 12px; /* 增加按鈕之間的間距 */
    opacity: 0.8; /* 稍微提高預設透明度，方便手機辨識 */
    transition: opacity 0.3s;
}

/* 下載按鈕樣式 (莫蘭迪藍/灰色) */
.btn-download-history {
    background: transparent;
    border: 1px solid #94a7b5; /* 霧霾藍邊框 */
    color: #94a7b5;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    padding: 0;
}

.btn-download-history:hover {
    background-color: #94a7b5;
    color: white;
    transform: scale(1.1);
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}

/* 手機版適配：確保按鈕區域夠大，防止誤觸 */
@media (max-width: 600px) {
    .history-actions {
        opacity: 1; /* 手機上總是顯示 */
        margin-top: 12px;
    }
    .btn-download-history, .btn-delete-history {
        width: 40px; /* 手機上按鈕稍微加大 */
        height: 40px;
        font-size: 1.1em;
    }
}


	/* === 備用線路提示視窗 (響應式設計) === */
.backup-alert-overlay {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(253, 252, 248, 0.85); /* 米白高模糊遮罩 */
    backdrop-filter: blur(8px);
    z-index: 999999; /* 確保在最上層 */
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.3s ease;
}

.backup-alert-card {
    background: #fff;
    
    /* === 修改部分：優化響應式寬度 === */
    /* 強制左右各留 30px 邊距，解決手機貼邊問題 */
    width: calc(100% - 60px); 
    max-width: 360px;         /* 電腦版最大寬度保持不變 */
    box-sizing: border-box;   /* 確保內距不會撐大卡片 */
    margin: 0 auto;           /* 確保水平置中 */
    /* ============================ */

    padding: 30px 25px;
    border-radius: 16px;
    border: 1px solid #e0ddd7;
    box-shadow: 0 15px 40px rgba(141, 110, 99, 0.15);
    text-align: center;
    position: relative;
}

.backup-alert-icon {
    font-size: 3rem;
    color: #d69a92; /* 莫蘭迪紅，表示警示 */
    margin-bottom: 15px;
    animation: pulse 2s infinite;
}

.backup-alert-title {
    color: #5d4037;
    font-size: 1.3rem;
    font-weight: bold;
    margin: 0 0 10px 0;
}

.backup-alert-desc {
    color: #888;
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 25px;
}

.backup-btn-group {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.backup-btn {
    border: none;
    padding: 10px 20px;
    border-radius: 50px;
    font-size: 0.95rem;
    cursor: pointer;
    font-weight: bold;
    font-family: 'Noto Serif TC', serif;
    transition: transform 0.2s;
}

.backup-btn:hover { transform: translateY(-2px); }

.btn-stay { background: #f0f0f0; color: #777; }
.btn-switch { 
    background: #8fa398; /* 莫蘭迪綠 */
    color: white; 
    box-shadow: 0 4px 12px rgba(143, 163, 152, 0.4);
}
	
</style>

<script>

// 全域變數：記錄當天(或本次會話) API 循環失敗的次數
let globalApiCycleFailures = 0;

// 顯示備用視窗
function showBackupAlert() {
    const modal = document.getElementById('backupAlertModal');
    if (modal) {
        modal.style.display = 'flex';
        // 觸發震動提醒 (如支援)
        if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
    }
}

// 關閉備用視窗
function closeBackupAlert() {
    const modal = document.getElementById('backupAlertModal');
    if (modal) modal.style.display = 'none';
}

// 追蹤失敗並判斷是否彈窗
function trackApiCycleFailure() {
    globalApiCycleFailures++;
    console.warn(`[System] API 完整循環失敗次數: ${globalApiCycleFailures}`);
    
    // 當累積失敗循環達到 2 次時，彈出視窗
    if (globalApiCycleFailures >= 2) {
        showBackupAlert();
        // 重置計數器，避免下次單次失敗又立即彈出 (可選)
        globalApiCycleFailures = 0; 
    }
}


	
// 頁面載入完成後，為所有 img 加上 lazy loading（包括動態生成的）
document.addEventListener("DOMContentLoaded", function() {
    document.querySelectorAll('img').forEach(img => {
        if (!img.hasAttribute('loading')) {
            img.setAttribute('loading', 'lazy');
        }
    });
});
// 觀察器：未來若有動態插入的圖片也自動加上
const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1) { // 元素節點
                if (node.tagName === 'IMG' && !node.hasAttribute('loading')) {
                    node.setAttribute('loading', 'lazy');
                }
                node.querySelectorAll && node.querySelectorAll('img').forEach(img => {
                    if (!img.hasAttribute('loading')) {
                        img.setAttribute('loading', 'lazy');
                    }
                });
            }
        });
    });
});
observer.observe(document.body, { childList: true, subtree: true });
</script>


	
</head>
<body>


<div class="title-container">
<h1>
<span class="title-text">神思</span>
</h1>
</div>


<div id="hitokoto-container" class="box">
<div id="hitokoto"></div>
<div id="hitokoto-footer">
<span id="hitokoto-from"></span>
<button id="refresh-btn"><i class="fas fa-sync-alt"></i></button>
</div>
</div>

	<!-- DSE 倒數日曆容器 -->
<div class="box" id="dse-countdown-box">
    <!-- 標題部分 (移除下拉選單，回歸純文字) -->
    <div class="dse-header">距離與DSE中文科分手尚餘</div>

    <!-- 主要顯示區域：左邊選單 + 右邊倒數 -->
    <div class="dse-main-wrapper">
        
        <!-- 左側：年級選擇器 (直排) -->
        <div class="grade-sidebar">
            <div class="grade-label">年級</div>
            <button class="grade-btn" data-val="s6">6</button>
            <button class="grade-btn" data-val="s5">5</button>
            <button class="grade-btn" data-val="s4">4</button>
            <button class="grade-btn" data-val="s3">3</button>
            <button class="grade-btn" data-val="s2">2</button>
            <button class="grade-btn" data-val="s1">1</button>
        </div>

        <!-- 右側：倒數卡片區 -->
        <div class="countdown-section">
            <div class="countdown-container">
                <!-- 「約」字標籤 -->
                <div id="approx-label" class="approx-label hidden">約</div>

                <!-- 千位 -->
                <div class="flip-unit hidden" id="unit-0">
                    <div class="card-part top" id="t0-next">0</div>
                    <div class="card-part bottom" id="b0-old">0</div>
                    <div class="flap" id="f0" data-old="0" data-new="0"></div>
                </div>
                
                <!-- 百位 -->
                <div class="flip-unit" id="unit-1">
                    <div class="card-part top" id="t1-next">0</div>
                    <div class="card-part bottom" id="b1-old">0</div>
                    <div class="flap" id="f1" data-old="0" data-new="0"></div>
                </div>
                <!-- 十位 -->
                <div class="flip-unit" id="unit-2">
                    <div class="card-part top" id="t2-next">0</div>
                    <div class="card-part bottom" id="b2-old">0</div>
                    <div class="flap" id="f2" data-old="0" data-new="0"></div>
                </div>
                <!-- 個位 -->
                <div class="flip-unit" id="unit-3">
                    <div class="card-part top" id="t3-next">0</div>
                    <div class="card-part bottom" id="b3-old">0</div>
                    <div class="flap" id="f3" data-old="0" data-new="0"></div>
                </div>

 <!-- ★★★ 新增這行：日字標籤 ★★★ -->
    <div class="days-label">日</div>
				
            </div>
            
            <div class="dse-footer">DAYS TO BREAKUP</div>
        </div>
    </div>
    
    <audio id="flip-sound" src="切換年級.mp3" preload="auto"></audio>
</div>



<style>
#hitokoto-container {
background: rgba(220, 220, 220, 0.96);
border-radius: 8px;
box-shadow: 0 2px 4px rgba(0,0,0,0.1);
padding: 16px;
margin: 15px 0;
text-align: center;
max-width: 800px;
position: relative;
}

@media (max-width: 600px) {
#hitokoto-container {
text-align: left;
}
}

#hitokoto {
font-size: 21px;
font-style: italic;
color: #333;
margin-bottom: 10px;
}

#hitokoto p {
margin: 5px 0;
}

#hitokoto-footer {
display: flex;
justify-content: space-between;
align-items: center;
margin-top: 10px;
}

#hitokoto-from {
font-size: 16px;
color: #666;
}

#refresh-btn {
background: none;
border: none;
cursor: pointer;
font-size: 20px;
color: #666;
transition: color 0.3s;
padding: 0;
margin: 0;
}

#refresh-btn:hover {
color: #000;
}


/* --- 新增：確認圖示按鍵樣式 --- */

.btn-icon-confirm {
/* 1. 外觀設定：圓形、綠色背景 */
width: 44px;
height: 44px;
border-radius: 50%; /* 製作成完美的圓形 */
background-color: #28a745; /* 成功、確認的綠色 */
border: none;

/* 2. 圖示置中與樣式 */
display: inline-flex;
align-items: center;
justify-content: center;
color: white; /* 圖示顏色 */
font-size: 20px; /* 圖示大小 */

/* 3. 互動效果與陰影 */
cursor: pointer;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
transition: all 0.2s ease-in-out;
}

.btn-icon-confirm:hover {
/* 4. 滑鼠懸停時：放大、提亮，陰影加深 */
transform: scale(1.1);
filter: brightness(110%);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn-icon-confirm:active {
/* 5. 點擊瞬間：再放大一點，提供回饋感 */
transform: scale(1.15);
}

/* === DSE 倒數日曆專用樣式 (響應式優化 - 底部選單版) === */
#dse-countdown-box {
    --dse-card-bg: #ffffff;
    --dse-text-color: #000000;
    --dse-line-color: #e0e0e0; 
    --dse-flip-duration: 0.6s;
    --dse-theme-color: #90A1B9;
    
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    padding: 15px 20px;
}

.dse-header {
    font-size: 1.1rem;
    letter-spacing: 0.3rem;
    margin-bottom: 1.2rem;
    color: #888;
    font-weight: 300;
    text-align: center;
}

/* === 主要容器 === */
.dse-main-wrapper {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 25px;
    width: 100%;
}

/* === 年級選單 (Desktop: 左側直排) === */
.grade-sidebar {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    padding-right: 20px;
    border-right: 1px dashed #ddd; /* 電腦版：右側分隔線 */
    flex-shrink: 0;
}

.grade-label {
    font-size: 0.75rem;
    color: #aaa;
    margin-bottom: 2px;
    font-weight: bold;
}

.grade-btn {
    background: transparent;
    border: 1px solid transparent;
    color: #ccc;
    font-family: 'Noto Serif TC', serif;
    font-size: 1rem;
    font-weight: bold;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.grade-btn:hover {
    color: var(--dse-theme-color);
    background: rgba(26, 117, 149, 0.1);
}

.grade-btn.active {
    color: white;
    background-color: var(--dse-theme-color);
    box-shadow: 0 2px 5px rgba(26, 117, 149, 0.3);
    transform: scale(1.1);
}

/* === 新增：日字標籤樣式 === */
.days-label {
    font-size: 24px;
    color: var(--dse-theme-color); /* 跟隨主題顏色 */
    margin-bottom: 20px;           /* 與數字底部對齊的微調 */
    margin-left: 8px;              /* 與數字保持一點距離 */
    font-weight: bold;
    opacity: 0.8;
}
	
/* === 右側倒數區塊 === */
.countdown-section {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.countdown-container {
    display: flex;
    gap: 10px;
    perspective: 1200px;
    justify-content: center;
    align-items: flex-end;
}

.approx-label {
    font-size: 24px;
    color: var(--dse-theme-color);
    margin-bottom: 20px;
    margin-right: 5px;
    font-weight: bold;
    opacity: 0.8;
}
.approx-label.hidden { display: none; }

/* 翻頁單元樣式 */
.flip-unit {
    position: relative;
    width: 90px;
    height: 120px;
    font-size: 70px;
    font-family: 'Noto Serif TC', "Songti TC", serif;
    font-weight: bold;
    text-align: center;
    border-radius: 6px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.03);
    color: var(--dse-text-color);
    line-height: 120px;
    z-index: 1;
}

.flip-unit::after {
    content: '';
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    border-radius: 6px;
    pointer-events: none;
    z-index: 10;
    background: linear-gradient(180deg, #46ECD5 0%, 
        #3BB8DB 40%, 
        #36BBA7 100%);
    mix-blend-mode: screen;
    box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.2);
}

.card-part {
    position: absolute;
    left: 0; width: 100%; height: 50%;
    overflow: hidden;
    background: var(--dse-card-bg);
    backface-visibility: hidden;
}

.top { top: 0; border-radius: 6px 6px 0 0; line-height: 120px; border-bottom: 0.5px solid var(--dse-line-color); }
.bottom { bottom: 0; border-radius: 0 0 6px 6px; line-height: 0px; border-top: none; }

.flap {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 50%;
    background: var(--dse-card-bg);
    border-radius: 6px 6px 0 0;
    transform-origin: bottom;
    z-index: 3;
    transition: transform var(--dse-flip-duration) cubic-bezier(0.4, 0, 0.2, 1);
    transform-style: preserve-3d;
    border-bottom: 0.5px solid var(--dse-line-color);
    color: var(--dse-text-color);
}
.flap::before { content: attr(data-old); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--dse-card-bg); border-radius: 6px 6px 0 0; backface-visibility: hidden; line-height: 120px; }
.flap::after { content: attr(data-new); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--dse-card-bg); border-radius: 0 0 6px 6px; transform: rotateX(-180deg); backface-visibility: hidden; line-height: 0; display: flex; justify-content: center; border-top: none; }
.card-part, .flap::before, .flap::after { text-shadow: 0 2px 3px rgba(0, 0, 0, 0.2); }
.flipping .flap { transform: rotateX(-180deg); }

.flip-unit.hidden { display: none; }

.dse-footer {
    margin-top: 1rem;
    letter-spacing: 0.2rem;
    font-size: 0.85rem;
    color: #c0c0c0;
    font-weight: 300;
}

/* === RWD 響應式調整 (關鍵修訂：按鈕移至底部) === */
@media (max-width: 600px) {
    .dse-main-wrapper {
        flex-direction: column; /* 垂直排列 */
        gap: 15px;
    }
    
    /* 1. 倒數區塊 (包含卡片和 DAYS TO BREAKUP) */
    .countdown-section {
        order: 1; /* 視覺上排第一 */
        width: 100%;
        margin-bottom: 5px;
    }

    /* 2. 年級選單 */
    .grade-sidebar {
        order: 2; /* 視覺上排第二 (底部) */
        flex-direction: row; /* 橫向排列 */
        width: 100%;
        justify-content: center;
        padding-right: 0;
        
        border-right: none;
        border-top: 1px dashed #e0e0e0; /* 分隔線改在上方 */
        
        padding-top: 15px;
        flex-wrap: wrap;
    }
    
    .grade-label {
        margin-right: 10px;
        margin-bottom: 0;
        align-self: center; /* 垂直置中 */
    }

    .grade-btn {
        width: 24px;  /* 手機版按鈕縮小 */
        height: 24px;
        font-size: 0.8rem;
    }

    .countdown-container {
        transform: scale(0.8); 
        margin: -10px 0;
    }
    
    .flip-unit {
        width: 70px;
        height: 100px;
        font-size: 55px;
        line-height: 100px;
    }
    .top { line-height: 100px; }
    .flap::before { line-height: 100px; }
}
</style>

<script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.js"></script>


<script>


// ==========================================
// === 覆寫原生 alert 為莫蘭迪 UI ===
// ==========================================
(function() {
    // 保存原始 alert 以防萬一需要使用 (雖然這裡我們選擇完全覆蓋)
    const originalAlert = window.alert;

    window.alert = function(message) {
        // 1. 移除頁面上可能已存在的 Alert (防止堆疊)
        const existingAlert = document.getElementById('sansi-custom-alert');
        if (existingAlert) existingAlert.remove();

        // 2. 建立 DOM 結構
        const overlay = document.createElement('div');
        overlay.id = 'sansi-custom-alert';
        overlay.className = 'sansi-alert-overlay';

        // 判斷是否為錯誤訊息 (簡單判斷關鍵字)
        const isError = String(message).includes('失敗') || String(message).includes('錯誤') || String(message).includes('請先');
        const iconClass = isError ? 'fa-exclamation-circle' : 'fa-info-circle';
        const iconColor = isError ? '#d69a92' : '#8fa398'; // 錯誤用豆沙紅，普通用灰綠

        overlay.innerHTML = `
            <div class="sansi-alert-box">
                <div class="sansi-alert-icon">
                    <i class="fas ${iconClass}" style="color: ${iconColor};"></i>
                </div>
                <div class="sansi-alert-message">${String(message)}</div>
                <button class="sansi-alert-btn" onclick="closeSansiAlert()">
                    明白
                </button>
            </div>
        `;

        // 3. 加入頁面
        document.body.appendChild(overlay);

        // 4. 觸發進場動畫 (需要一點延遲讓 DOM 渲染)
        requestAnimationFrame(() => {
            overlay.classList.add('sansi-alert-show');
        });

        // 5. 綁定鍵盤事件 (按 Enter 關閉)
        const handleEnter = (e) => {
            if (e.key === 'Enter' || e.key === 'Escape') {
                closeSansiAlert();
                document.removeEventListener('keydown', handleEnter);
            }
        };
        document.addEventListener('keydown', handleEnter);
    };

    // 全域關閉函式
    window.closeSansiAlert = function() {
        const overlay = document.getElementById('sansi-custom-alert');
        if (overlay) {
            // 退場動畫
            overlay.classList.remove('sansi-alert-show');
            setTimeout(() => {
                if (overlay) overlay.remove();
            }, 300); // 等待 CSS transition 結束
        }
    };
})();

	

let globalAbortController = null;

// === 新增：權限與額度控制 ===

// Base64 編碼的電郵
// kenchan20131@gmail.com (扮學生)
const STUDENT_ADDITION_B64 = "a2VuY2hhbjIwMTMxQGdtYWlsLmNvbQ=="; 
// kenchan20151@gmail.com (特許用家)
const SPECIAL_USER_B64 = "a2VuY2hhbjIwMTUxQGdtYWlsLmNvbQ==";

/**
 * 檢查訪客每日使用額度
 * @returns {boolean} true=允許繼續, false=阻止
 */
function checkGuestUsage() {
    // 1. 檢查是否已登入 (學生、老師、特許用家)
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (s) {
        console.log(`[權限檢查] 用戶已登入 (${s.name})，不設限制。`);
        return true; 
    }

    // 2. 未登入訪客：檢查 LocalStorage 計數
    const today = new Date().toLocaleDateString('zh-HK'); // 格式如 2025/1/15
    const storageKey = `sansi_guest_usage_${today}`;
    
    // 取得目前次數 (預設為 0)
    let currentCount = parseInt(localStorage.getItem(storageKey) || "0");
    
    console.log(`[權限檢查] 訪客狀態 | 日期: ${today} | 已用次數: ${currentCount} | 上限: 1`);

    if (currentCount >= 1) {
        alert("⚠️ 訪客每日體驗額度已用完。\n\n請登入學校帳號或註冊以無限使用所有功能。");
        console.warn("[權限檢查] 攔截：超過每日額度。");
        return false;
    }

    // 3. 增加計數 (在 API 呼叫成功前先扣除，防止併發)
    localStorage.setItem(storageKey, currentCount + 1);
    return true;
}




	
	// === [新增] 中斷生成控制邏輯 ===
 
// 打開確認視窗
function openCancelModal() {
    const modal = document.getElementById('cancelConfirmModal');
    if (modal) modal.style.display = 'flex';
}
 
// 關閉確認視窗 (繼續等待)
function closeCancelModal() {
    const modal = document.getElementById('cancelConfirmModal');
    if (modal) modal.style.display = 'none';
}
 
// 確認取消 (執行中斷)
function confirmCancel() {
    closeCancelModal(); // 關閉確認窗
    
    // 1. 中斷 API 連線
    if (globalAbortController) {
        globalAbortController.abort(); // 發送中斷訊號
        globalAbortController = null;
        console.log("使用者手動取消生成");
    }
 
    // 2. 隱藏加載畫面
    hideLoading();
 
    // 3. 重新啟用所有被鎖定的提交按鈕
    enableSubmitButtons();
}
 
// 輔助：重新啟用按鈕
function enableSubmitButtons() {
    const ids = [
        'submitWritingBtn', 'submitReadingBtn', 'submitExpandBtn', 'submitExpandGuideBtn',
        'submitArgumentOutlineBtn', 'submitArgumentWritingBtn', 'submitArgumentGuideBtn',
        'submitWritingGuideBtn', 'startDiscussionBtn', 'continueBtn',
        'continueWritingBtn', 'continueWritingGuideBtn', 'continueArgumentBtn',
        'canvasChatSendBtn'
    ];
    ids.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = false;
    });
}
	


// === 分頁控制變數 ===
let allAssignmentTasks = []; // 暫存該班級所有功課的 Metadata (不含內容，很小)
let currentLoadedCount = 0;  // 目前已顯示的數量
const BATCH_SIZE = 5;        // 每次載入幾份 (預設 5)

	

	// === 神思通知系統邏輯 ===

// === 神思通知系統邏輯 (高效能修正版) ===

// 讀取已讀紀錄
let notifiedIds = JSON.parse(localStorage.getItem('sansi_read_notifications') || '[]');

// 用來管理監聽器，避免重複綁定
let activeListeners = {
    assignments: null,
    submissions: {} // 儲存個別作業的提交狀態監聽器
};
let isNotificationInitialized = false; // 防止重複執行

function initNotificationListeners() {
    // 1. 防止重複啟動
    if (isNotificationInitialized) return;
    
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (!s) return; // 未登入則不執行

    // 建立通知容器 (如果不存在)
    if (!document.getElementById('notifContainer')) {
        const div = document.createElement('div');
        div.id = 'notifContainer';
        div.className = 'sansi-notification-container';
        document.body.appendChild(div);
    }

    isNotificationInitialized = true;
    console.log("通知監聽系統已啟動 (高效能模式)");

    // --- 1. 監聽班級課業列表 (主監聽器) ---
    const assignmentPath = `assignments/${s.grade}/${s.class}`;
    
    // 如果之前有監聽，先移除
    if (activeListeners.assignments) {
        database.ref(assignmentPath).off();
    }

    activeListeners.assignments = database.ref(assignmentPath);
    activeListeners.assignments.on('value', (snapshot) => {
        const assignmentsData = snapshot.val() || {};
        const assignmentKeys = Object.keys(assignmentsData);

        // A. 處理新課業通知
        assignmentKeys.forEach(key => {
            // 如果不在已讀列表中，發送通知
            if (!notifiedIds.includes(key)) {
                showSansiNotif('new', assignmentsData[key].topic, key);
            }

            // B. [關鍵優化] 為每一份存在的作業，精準監聽「該學生的提交狀態」
            // 這樣就不用下載全校的資料庫，大幅提升速度
            monitorSubmissionStatus(key, s.name, assignmentsData[key].topic);
        });

        // C. 清理舊監聽器 (如果作業被老師刪除了，就不再監聽該作業的提交狀態)
        Object.keys(activeListeners.submissions).forEach(monitoredKey => {
            if (!assignmentKeys.includes(monitoredKey)) {
                // 作業已不存在，移除監聽
                database.ref(`assignments_submissions/${monitoredKey}/${s.name}`).off();
                delete activeListeners.submissions[monitoredKey];
            }
        });

        // D. 同步移除畫面上已失效的通知卡片 (例如老師刪除了作業)
        const activeNotifs = document.querySelectorAll('.sansi-notification[data-type="new"]');
        activeNotifs.forEach(node => {
            const id = node.getAttribute('data-notif-id');
            if (!assignmentKeys.includes(id)) {
                node.classList.add('fade-out');
                setTimeout(() => { node.remove(); updateNotifBadge(); }, 500);
            }
        });

        updateNotifBadge();
    });
}

// 輔助函式：針對單份作業監聽「已發還」狀態
function monitorSubmissionStatus(assignmentId, studentName, topicTitle) {
    // 如果已經在監聽這份作業，就跳過
    if (activeListeners.submissions[assignmentId]) return;

    const submissionPath = `assignments_submissions/${assignmentId}/${studentName}`;
    const subRef = database.ref(submissionPath);

    // 儲存參照以便稍後可以移除
    activeListeners.submissions[assignmentId] = subRef;

    subRef.on('value', (snapshot) => {
        const myWork = snapshot.val();
        
        // 檢查是否有「已發還」標記
        if (myWork && myWork.teacherFeedback && myWork.teacherFeedback.status === 'returned') {
            // 產生唯一的評語 ID (利用時間戳)
            const feedbackId = "fb_" + assignmentId + "_" + myWork.teacherFeedback.timestamp;
            
            // 如果這個評語還沒被讀過，顯示通知
            if (!notifiedIds.includes(feedbackId)) {
                showSansiNotif('returned', myWork.title || topicTitle || "課業", feedbackId);
            }
        }
        
        // 如果狀態變成不是 returned (例如老師撤回)，可以在這裡處理通知撤回 (選用)
        // 目前保留簡單邏輯即可
    });
}

/**
 * 顯示通知卡片 (維持原本的 UI 邏輯)
 */
function showSansiNotif(type, topic, uniqueId) {
    if (document.querySelector(`[data-notif-id="${uniqueId}"]`)) return; // 防重複

    const container = document.getElementById('notifContainer');
    if (!container) return;

    // === 新增：莫蘭迪色系 ===
    const morandiPalette = ['#8fa398', '#94a7b5', '#b6a6ca', '#d69a92', '#c7b299'];
    // 隨機選取顏色
    const randomThemeColor = morandiPalette[Math.floor(Math.random() * morandiPalette.length)];

    const notif = document.createElement('div');
    notif.setAttribute('data-notif-id', uniqueId);
    notif.setAttribute('data-type', type); 
    
    // === 新增：設定色條顏色 ===
    notif.style.setProperty('--theme-color', randomThemeColor);
    
    const isNew = type === 'new';
    notif.className = `sansi-notification ${isNew ? 'notif-new' : 'notif-returned'}`;
    
    const badgeText = isNew ? '新課業發佈' : '批改已發還';
    const descText = isNew 
        ? '老師為你的班級指派了新任務，請適時進入系統完成練習。' 
        : '你提交的課業已有新的老師評語及評分，請即時檢閱。';

    notif.innerHTML = `
        <div class="notif-badge">${badgeText}</div>
        <div class="notif-header">
            <div class="notif-topic">《${topic}》</div>
        </div>
        <div class="notif-desc">${descText}</div>
        <div class="notif-footer">
            <span>點擊前往查看詳情</span>
            <i class="fas fa-chevron-right" style="font-size: 0.7rem;"></i>
        </div>
    `;

    notif.onclick = () => {
        // 記錄已讀
        if (!notifiedIds.includes(uniqueId)) {
            notifiedIds.push(uniqueId);
            localStorage.setItem('sansi_read_notifications', JSON.stringify(notifiedIds));
        }
        // 移除卡片
        notif.classList.add('fade-out');
        setTimeout(() => {
            notif.remove();
            updateNotifBadge();
        }, 500);
        // 打開雲端中心
        openStudentLoginModal();
    };

    container.appendChild(notif);
    updateNotifBadge();
}

// 更新側邊欄紅點
function updateNotifBadge() {
    const container = document.getElementById('notifContainer');
    const badge = document.getElementById('notifBadge');
    // 如果全域有未交功課變數 (window.hasPendingWork)，也要考慮進去
    const hasVisibleNotifs = (container && container.querySelectorAll('.sansi-notification').length > 0);
    const hasPending = window.hasPendingWork || false;

    if (badge) {
        badge.style.display = (hasVisibleNotifs || hasPending) ? 'block' : 'none';
    }
}



	
	
// 啟動點：頁面載入後執行
document.addEventListener('DOMContentLoaded', () => {
    // 只保留這一個啟動點，移除其他的 setTimeout
    setTimeout(initNotificationListeners, 1500);
});

// 修改原有的登入檢查，登入後立即啟動監聽
const originalCheckLoginForNotif = window.checkStudentLogin;
window.checkStudentLogin = async function() {
    await originalCheckLoginForNotif();
    // 登入成功後，立即初始化通知監聽 (如果尚未初始化)
    initNotificationListeners();
};


// 顯示或隱藏側邊選單紅點
function showRedBadge(show) {
    const cloudBtn = document.getElementById('sideMenuCloudBtn');
    if (!cloudBtn) return;

    let badge = cloudBtn.querySelector('.notification-badge');
    if (!badge) {
        badge = document.createElement('div');
        badge.className = 'notification-badge';
        cloudBtn.appendChild(badge);
    }
    badge.style.display = show ? 'block' : 'none';
}

// 在頁面載入及登入成功後啟動
document.addEventListener('DOMContentLoaded', () => {
    // 延遲一點點啟動，避開初次載入的數據洪流
    setTimeout(initNotificationListeners, 2000);
});

// 修改你原有的 checkStudentLogin，在切換到雲端面板時清除紅點
const originalCheckLogin = window.checkStudentLogin;
window.checkStudentLogin = async function() {
    await originalCheckLogin();
    showRedBadge(false); // 打開雲端中心就視為已讀
};

	// 打開結果畫布
function openResultCanvas(title) {
    const canvas = document.getElementById('resultCanvas');
    const body = document.getElementById('resultCanvasBody');
    document.getElementById('resultCanvasTitle').innerText = title || "生成結果";
    
    body.innerHTML = ''; // 清空舊內容
    canvas.style.display = 'block';
    document.body.style.overflow = 'hidden'; // 鎖定主頁面捲動
}

// 關閉結果畫布
function closeResultCanvas() {
    const canvas = document.getElementById('resultCanvas');
    canvas.style.display = 'none';
    document.body.style.overflow = 'auto'; // 恢復主頁面捲動
    
    // 如果有雷達圖實例，關閉時銷毀以防衝突 (選用)
    // if (window.narrative_radarChartInstance) window.narrative_radarChartInstance.destroy();
}


	// === 顯示加載動畫 ===
// === 顯示加載動畫 (隨機 GIF 版) ===
function showLoading(text) {
    const overlay = document.getElementById('loadingOverlay');
    const textEl = document.getElementById('loadingText');
    const imgEl = document.getElementById('loadingImage'); // 獲取圖片元素

    // ★★★ 在這裡設定你的 GIF 清單 ★★★
    // 請確保這些檔案都已經上傳到你的網站目錄中
    const gifList = [
        '生成中.gif',
        '生成中2.gif',
        '生成中3.gif',
        '生成中4.gif',
        '生成中5.gif',
        '生成中6.gif'
        // 如果有更多，可以繼續加： '生成中3.gif',
    ];

    if (overlay && textEl) {
        // 1. 隨機抽取一張 GIF
        if (imgEl) {
            const randomIndex = Math.floor(Math.random() * gifList.length);
            const selectedGif = gifList[randomIndex];
            imgEl.src = selectedGif; //更換圖片來源
        }

        // 2. 設定文字並顯示
        textEl.innerText = text || "正在運算中..."; 
        overlay.style.display = 'flex';
    }
}

// === 隱藏加載動畫 ===
function hideLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}


	// === 動畫觸發輔助函數 ===
function playEntryAnimation(elementId) {
    const el = document.getElementById(elementId);
    if (el) {
        // 1. 移除動畫 class (如果有的話)
        el.classList.remove('fade-in-up');
        
        // 2. 強制瀏覽器重繪 (Reflow) - 這是關鍵，否則瀏覽器會忽略重新添加 class 的動作
        void el.offsetWidth;
        
        // 3. 重新加入動畫 class
        el.classList.add('fade-in-up');
    }
}

document.addEventListener('DOMContentLoaded', function() {
const converter = OpenCC.Converter({ from: 'cn', to: 'tw' });
const hitokotoElement = document.getElementById('hitokoto');
const hitokotoFromElement = document.getElementById('hitokoto-from');
const refreshBtn = document.getElementById('refresh-btn');


function initDSECalendar() {
    // === 1. 設定日期 ===
    const config = {
        s6: '2026-04-09', 
        s5: '2027-04-02',
        offsets: { s4: 1, s3: 2, s2: 3, s1: 4 }
    };

    // === 2. 自動建立/獲取煙花畫布 ===
    let fireworksCanvas = document.getElementById('fireworksCanvas');
    if (!fireworksCanvas) {
        fireworksCanvas = document.createElement('canvas');
        fireworksCanvas.id = 'fireworksCanvas';
        fireworksCanvas.style.position = 'fixed';
        fireworksCanvas.style.top = '0';
        fireworksCanvas.style.left = '0';
        fireworksCanvas.style.width = '100%';
        fireworksCanvas.style.height = '100%';
        fireworksCanvas.style.pointerEvents = 'none'; 
        fireworksCanvas.style.zIndex = '2147483647';
        fireworksCanvas.style.display = 'none';
        document.body.appendChild(fireworksCanvas);
    }

    const gradeButtons = document.querySelectorAll('.grade-btn');
    const unit0 = document.getElementById('unit-0');
    const approxLabel = document.getElementById('approx-label');
    
    let currentGrade = localStorage.getItem('dse_grade') || 's6';

    // === 3. 煙花特效邏輯 (保持不變) ===
    let fireworksInterval;
    let autoStopTimer; 
    let cleanupTimer;  
    let fireworksActive = false;
    const ctx = fireworksCanvas.getContext('2d');
    let particles = [];

    function resizeCanvas() {
        fireworksCanvas.width = window.innerWidth;
        fireworksCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function createParticle(x, y) {
        const particleCount = 35; 
        for (let i = 0; i < particleCount; i++) {
            particles.push({
                x: x,
                y: y,
                colors: ['#1A7595', '#D87C7C', '#E6D0A6', '#8FB2C9', '#A8D8B9'],
                color: '',
                radius: Math.random() * 2 + 0.8, 
                velocity: {
                    x: (Math.random() - 0.5) * 6,
                    y: (Math.random() - 0.5) * 6
                },
                alpha: 0.9,
                decay: Math.random() * 0.01 + 0.005
            });
            particles[particles.length - 1].color = particles[particles.length - 1].colors[Math.floor(Math.random() * 5)];
        }
    }

    function animateFireworks() {
        if (particles.length === 0 && !fireworksActive) return;
        requestAnimationFrame(animateFireworks);
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
        ctx.globalCompositeOperation = 'lighter';
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
            p.x += p.velocity.x;
            p.y += p.velocity.y;
            p.velocity.y += 0.03;
            p.velocity.x *= 0.98;
            p.velocity.y *= 0.98;
            p.alpha -= p.decay;
            if (p.alpha <= 0) particles.splice(i, 1);
        }
    }

    function startFireworks() {
        if (fireworksActive) return;
        fireworksActive = true;
        fireworksCanvas.style.display = 'block';
        animateFireworks();
        createParticle(window.innerWidth / 2, window.innerHeight / 3);
        fireworksInterval = setInterval(() => {
            const x = Math.random() * (fireworksCanvas.width * 0.6) + (fireworksCanvas.width * 0.2);
            const y = Math.random() * (fireworksCanvas.height / 2); 
            createParticle(x, y);
        }, 700);
        clearTimeout(autoStopTimer);
        clearTimeout(cleanupTimer);
        autoStopTimer = setTimeout(() => stopLaunching(), 3000);
    }

    function stopLaunching() {
        clearInterval(fireworksInterval);
        fireworksActive = false;
        cleanupTimer = setTimeout(() => {
            fireworksCanvas.style.display = 'none';
            ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            particles = [];
        }, 3000);
    }

    function forceStopFireworks() {
        clearInterval(fireworksInterval);
        clearTimeout(autoStopTimer);
        clearTimeout(cleanupTimer);
        fireworksActive = false;
        fireworksCanvas.style.display = 'none';
        ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
        particles = [];
    }

    // === 4. 按鈕監聽 (修改處：傳入較短延遲) ===
    gradeButtons.forEach(btn => {
        if (btn.dataset.val === currentGrade) btn.classList.add('active');

        btn.addEventListener('click', function() {
            gradeButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            currentGrade = this.dataset.val;
            localStorage.setItem('dse_grade', currentGrade);
            
            // ★★★ 這裡改成 250ms (0.25秒)，切換時更快速 ★★★
            updateCountdown(true, 250); 
        });
    });

    // === 5. 倒數更新 (修改處：接收 delay 參數) ===
    function updateCountdown(animate = true, delay = 800) {
        // 使用傳入的 delay 參數，預設為 800ms
        const flipDelay = delay; 

        let targetDate;
        const isApprox = ['s1', 's2', 's3', 's4'].includes(currentGrade);
        if (approxLabel) approxLabel.classList.toggle('hidden', !isApprox);
        
        if (currentGrade === 's6' || currentGrade === 's5') {
            targetDate = new Date(config[currentGrade]);
        } else {
            const baseDate = new Date(config.s5);
            const yearsToAdd = config.offsets[currentGrade];
            targetDate = new Date(baseDate.getTime() + (yearsToAdd * 365 * 24 * 60 * 60 * 1000));
        }
        
        const now = new Date();
        targetDate.setHours(0, 0, 0, 0);
        now.setHours(0, 0, 0, 0);
        const diff = targetDate.getTime() - now.getTime();
        let days = Math.ceil(diff / (1000 * 60 * 60 * 24));
        
        const daysLabel = document.querySelector('.countdown-container .days-label, .days-label');
        
        // 處理負數天數
        if (days < 0) {
            forceStopFireworks();
            if (unit0) unit0.classList.remove('hidden');
            const fullStr = "已分手";
            for (let i = 0; i < 3; i++) {
                const unit = document.getElementById(`unit-${i}`);
                if (unit) {
                    unit.classList.remove('flipping');
                    document.getElementById(`t${i}-next`).innerText = fullStr[i] || '';
                    document.getElementById(`b${i}-old`).innerText = fullStr[i] || '';
                    const flap = document.getElementById(`f${i}`);
                    flap.setAttribute('data-old', fullStr[i] || '');
                    flap.setAttribute('data-new', fullStr[i] || '');
                }
            }
            const unit3 = document.getElementById('unit-3');
            if (unit3) unit3.classList.add('hidden');
            if (approxLabel) approxLabel.classList.add('hidden');
            if (daysLabel) daysLabel.style.display = 'none';
            const footer = document.querySelector('.dse-footer');
            if (footer) footer.textContent = "WE ARE FREE";
            return;
        }

        // 正常顯示
        if (daysLabel) daysLabel.style.display = '';
        if (unit0) unit0.classList.toggle('hidden', days < 1000);
        
        const fullStr = days.toString().padStart(4, '0');      // 新數字
        const prevDays = days + 1;                             // 舊數字
        const oldFullStr = prevDays.toString().padStart(4, '0'); 
        
        // 煙花邏輯
        if (days <= 0) {
            days = 0;
            if (!fireworksActive) startFireworks();
        } else {
            forceStopFireworks();
        }
        
        // ★★★ 第一階段：無動畫、瞬間重置為「舊數字」 (防閃爍邏輯) ★★★
        for (let i = 0; i <= 3; i++) {
            const unit = document.getElementById(`unit-${i}`);
            if (unit) {
                const oldVal = oldFullStr[i];
                const flap = document.getElementById(`f${i}`);

                // 關閉過渡，防閃爍
                flap.style.transition = 'none';
                unit.classList.remove('flipping');
                
                // 設為舊數字
                document.getElementById(`t${i}-next`).innerText = oldVal;
                document.getElementById(`b${i}-old`).innerText = oldVal;
                flap.setAttribute('data-old', oldVal);
                flap.setAttribute('data-new', oldVal);

                // 強制重繪
                void unit.offsetWidth; 

                // 恢復過渡
                flap.style.transition = ''; 
            }
        }

        // ★★★ 第二階段：根據 delay 時間翻頁 ★★★
        if (animate) {
            setTimeout(() => {
                const sound = document.getElementById('flip-sound');
                if (sound) {
                    sound.currentTime = 0;
					sound.volume = 1.0; // <--- 加入這行，強制設定為最大聲 (100%)
                    sound.play().catch(() => {});
                }

                for (let i = 0; i <= 3; i++) {
                    const unit = document.getElementById(`unit-${i}`);
                    if (unit) {
                        const newVal = fullStr[i];
                        const oldVal = oldFullStr[i];
                        
                        if (oldVal !== newVal) {
                            const flap = document.getElementById(`f${i}`);
                            document.getElementById(`t${i}-next`).innerText = newVal;
                            flap.setAttribute('data-new', newVal);
                            unit.classList.add('flipping');
                        }
                    }
                }
            }, flipDelay); // 使用動態傳入的 delay
        } else {
             for (let i = 0; i <= 3; i++) {
                const unit = document.getElementById(`unit-${i}`);
                if (unit) {
                    const newVal = fullStr[i];
                    document.getElementById(`t${i}-next`).innerText = newVal;
                    document.getElementById(`b${i}-old`).innerText = newVal;
                    const flap = document.getElementById(`f${i}`);
                    flap.setAttribute('data-old', newVal);
                    flap.setAttribute('data-new', newVal);
                }
            }
        }
    }
    
    // 首次執行 (保持較長延遲，這裡設為 800ms)
    setTimeout(() => {
        updateCountdown(true, 800);
    }, 100); 
}

// 確保腳本執行
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    initDSECalendar();
} else {
    document.addEventListener('DOMContentLoaded', initDSECalendar);
}

	
function fetchHitokoto() {
fetch('https://v1.hitokoto.cn/?c=d&c=i&c=k&encode=json')
.then(response => response.json())
.then(data => {
if (data.from.includes('魔道祖師')) {
fetchHitokoto(); // 如果來源是「魔道祖師」，重新獲取名言
} else {
// 使用 textContent 可以自動處理特殊字元，是顯示純文字的最佳選擇
hitokotoElement.textContent = converter(data.hitokoto);
hitokotoFromElement.textContent = `—— ${converter(data.from_who || '佚名')} 《${converter(data.from)}》`;
}
})
.catch(error => {
console.error('獲取名言失敗:', error);
hitokotoElement.innerHTML = '<p>獲取名言失敗，請稍後再試。</p>';
hitokotoFromElement.innerHTML = '';
});
}

fetchHitokoto();
refreshBtn.addEventListener('click', fetchHitokoto);
});
</script>

<!-- 內置的 5** 級數範文 (隱藏) -->
<div id="five-star-examples" style="display: none;">
<div id="example-yanhuo">
<h3>《煙火》</h3>
<p>回鄉的我凝望著門前的「河流」，沉默不語。那場璀璨的煙火又在我杳遠的回憶隱然綻放。
我記得，故鄉梁莊的那夜是樸素的，是低調的，就像默默俯身收割莊稼的農民；我記得，那時祖屋的遠處種著桑樹，樹上迴響著清亮的蟬聲，而近處蜿蜒著一道河，河畔的蘆葦總傳來蛙鳴；那是元旦，鄰居李叔親切地送上祝福，又從吳鎮的煙火廠帶來了龍吐珠，與村民慶賀新春。煙花在夜幕訇然盛放之時，七歲的我正環抱著爺爺的頸項。所有的澄黃、亮綠和緋紅倏爾煥爛在我的眼眸。火光乍現，煙花便瞬即璀璨而華麗地枯萎了，只賸下硝煙和火藥的氣息。
我哭了，爺爺以為我被煙火嚇壞了，瞬即摩娑著我的背。
其實，我不過是驚詫於一切美好的幻滅。
後來，我才瞭解人生有許多事情都注定是一場美好的幻滅，如同煙火。
爺爺是我的留守歲月最璀璨的印記。我從村校放學回家時，爺爺總會捧著熱氣騰騰的、白花花的饅頭迎接著我。阿念，吃吧，快點吃吧。爺爺沙啞的聲線仍猶在耳。童年的我總喜歡伏在爺爺的背上諦聽著時間，一秒，兩秒，是多麼沉穩的幸福呢。背並不厚實，但卻溫暖和煦。時間仿佛會一直定格在這一幀。然而在我九歲那年，爺爺死了，就淹死在門前的河。建築公司在河底挖沙蓋樓，河道看來平靜，卻暗藏漩渦。爺爺游泳時被暗湧拉扯到河底，就活活淹死了。短短數年的歲月，在人生裡不過是一場倉卒燃燒的煙火，爺爺在我的回憶裡綻放過澄黃、亮綠和緋紅，卻連一縷硝煙都沒有遺下，只遺下了一件濡濕的、皺巴巴的汗衣，儼如因衰老而再無能為力綻放的煙花。
還有門前的河流，在爺爺死後十年，已經沉默得如患上了失語症，河水乾涸，河床裸露，像被歲月無情強暴了一樣。夏蟬和青蛙，都憂鬱得噤聲不語，遷徙到回憶之外。李叔前年在電鍍廠中毒過身了。童年時一切一切的美好，都如海市蜃樓般驟然無存。歲月燃點了一場煙花，最後只遺下沉重的回憶，以及沉重地回憶的我。煙火再璀璨，也是匆促的。
本來我是這樣認為的。
直至又再離鄉之際，我才赫然窺探到煙火的秘密。
村口的大樹懸掛著纍纍碩大的林柿，那一個個橘橙的果實每年都爛在樹上，沒有村民採摘，連雀鳥都不屑一顧。在我準備踏出村口時，一顆飽滿的柿子掉落到我面前。我啃咬了一口，還是一如回憶的苦澀、難吃，我急不及待將咀嚼中的柿肉吐出來，且棄之如敝屣。我倏爾發現，縱然梁莊物換星移已不知幾度秋，但仍有許多回憶的遺跡，比如是眼前這棵金玉其外的柿樹。它的果實仍然是澀的，我想，是因為它仍然鮮活、茂盛、強壯，是因為它仍未枯謝、凋零、衰敝。假如它成為了歲月匆促幻滅的過客，也許那味道會是甘甜的苦澀，也許我會懷念那苦澀。
我再次凝望著那乾涸的河道。曩昔我嫌棄過蟬囀蛙鳴聒耳，擾人清夢；我埋怨過蘆葦纖長，阻礙了我的視野；我拒絕過爺爺的饅頭，因為寡淡無味，因為我想吃肉香滿溢的五香肘子啊，不想吃寡淡的、慘白的饅頭。我討厭過李叔蠟黃的臉色，討厭過他衣衫襤褸，討厭過他渾身汗臭，我討厭過李叔的一切。諷刺的是，隨著物和事匆促的面目全非，我竟爾留戀上一切我討厭過的。
於是我開始明白煙花的璀璨，在於它的匆促和幻滅。
時間會過濾掉所有人和事的雜質，隨著泯滅變易，我們開始犯賤地珍惜，然而珍惜的唯一意義僅在於遺憾，但正因為遺憾，才體現到事物的璀璨。倘若爺爺和李叔仍然在世，倘若門前的河仍然流淌不斷，倘若蟬聲蛙鳴依舊，倘若絢爛永恆，那麼一切便將腐爛而不再璀璨，他們和它們都將蛻變成被棄如敝屣的柿子。我曾以為煙火再璀璨，也是匆促的。但原來我錯了。原來煙火璀璨，正因為匆促。一旦煙火永恆，它將失去生命，教人徒然目眩。
離鄉的這夜，恰巧是元旦。是夜天陰，無雨。梁莊寂寥如一場夢，再沒有盛放的煙火。因為，煙花從此只在我的回憶裡燦爛地綻開、匆促地結果。</p>
</div>
<div id="example-gen">
<h3>《根》</h3>
<p>火焰燃起了一瓣又一瓣的灰燼，它們即生即滅，像飄萍，是一種無根的存在。餘燼隨風零落，又再揚起，終落入了深邃的虛無裡。人們說，紙錢燒成灰燼，便會飛落到地獄，交到亡靈的手裡。
父親，你收到了嗎？
你，尋到你的根了嗎？
我向着一枚貝殼問道。
我們的故鄉是一個江南小鎮，名曰周莊。明代江南首富沈萬三昔曾坐落此處發施號令，指點江山，各種契約、決斷和銀票都有這裡大進大出過，如今卻只賸下沈廳的空寂。鎮上到處都是貫穿南北的河道，就像永不乾涸的阡陌。周莊的河網養活了一代又一代的周莊人，從這裡出發，可借河道而東西南北，近至蘇杭，遠通東南亞。我的父親，只是貿易的一塊細小的零件——卑微的船夫，但他卻盤根錯節，支撐著整個家庭。
「爸，你甚麼時候回家？」
小時候，每當我牽扯著他的衣襬問他這道問題時，他總會帶著疲憊的莞爾，摩娑著我的腦殼說道：
「很快了，很快了。」
於是，一去便是三兩個月了。他在無垠的河川和滄渤航行了一輩子，曾為多少家庭送上過物資，又曾目睹過多少匆忙歸家的白鷗呢？然而，他自己卻成為了一個無根的人。他飄洋過海，仿佛只為回來時睡一覺昏沉的。無根的浪花，便是父親的象徵；一身的鹹腥，便是他半生的註腳。
他細碎又重複的夢囈被年幼的我記住了。
在漫長的夢裡，他是參天巨樹，偉岸的、繁茂的，扎根在風吹草低見牛羊的草原。風拂過他的臉龐，他貪婪地流了一行涎液。
一切都只為了養活我們四兄弟姐妹，成為這個家庭的根。母親呢，從不嚮往自由而無根的蒲公英，在我們孩提時代，她已經從周莊的河網掙脫出去了。只賸下父親，像根一樣默默無言地支撐著這個家庭的經濟，用河水澆灌，為它提供養份；用船櫓翻土，使它茁壯成長。我們幾兄弟姐妹，就恍如纍纍碩大的果實。果實之所以飽滿豐美，全因深扎泥土的根。
短暫洗去風塵後，又是一個擾人的昒暝。陽光揉開他的眼瞼，那沉重的眼瞼，一場無垠的旅程又將展開。
他成為了我們的根，自己呢，卻一直飄泊於風波不定的大海。我一直想，他的根究竟在哪裡呢？
也許，從來都不在印有郵遞編號的地方，而在我們。但早在十年前，都被我們砍斷了。終於，父親失去了他惟一的根。
長大後，我們不再牽扯父親的衣襬。父親在我們的印象，是一種昏睡的存在，我們之間存在著一種歲月孕育出來的隔閡——不冷淡又不溫韾的沉默。就像周莊的河水，既不溷濁，又不清澈。只有生活的氣息。隨著長大，我們一個又一個離開了日復如是的故鄉。他用一身風塵支撐的家，早在歲月的長河中淡褪了顏色。
被淹沒了。
大哥從來沒有帶過孩子回鄉。
二姐結婚時沒有邀請過父親。
妹妹幾年來音信杳無，聽說到加拿大去了。
只有我偶爾回鄉。父親總是無所事事，落寞地坐在斜曛映照的碼頭上，抽著雙喜牌香煙，眺望著那平靜如日子的河川。夕陽落在他身上，拓出了一個單薄的黑影。我這才知道，原來影子是會老，是會萎縮的。
他的身體開始坍塌，大不如曩日的壯碩，因為失去了根，失去了人生角色的緣故。他已經沒有了壯碩的理由。在病榻上，只有噏動的嘴唇透露著生命的跡象，在明滅不定的沉吟裡，我諦聽到我們的暱稱，又諦聽到那個關於樹的夢的碎片。不一樣的是，樹好像連根拔起了，似乎被一場颱風吹倒了。
我不會遺忘父親的好。每次他回周莊，他總會為我們帶來一枚貝殼，我愛把貝殼湊在耳畔聽那大海的聲音，有溫煦的，有舒爽的，有寂寞的，有思念的。他出航的畫面，總如真似幻地映照在我的腦海裡。但我無法將愛裸裎地宣之於口。父親，你飄泊半生，四海為家，卻終於失去了支撐你努力活著的角色。為了成為我們的根，你失去了自己的根。也許，也許你無法扎根在這個世界任何一隅，但我卻早為你預留了一捧最肥沃的泥土——在我心裡，讓你終於可以安息，終於可以落葉歸根，終於不用再飄泊不定。
海風永不止息地吹拂著一個夢，雲亦舒捲著無根的故事。</p>
</div>
<div id="example-dengdai">
<h3>《等待》</h3>
<p>月亮高懸在闃寂的夜空，儼如吊著一顆無眠的眼睛。它仿佛記得，自己已用幾千年的時間等待一個人，但卻已遺忘了等待的對象。於是，它映照著下方喧囂的城市，映照著每一個在城市裡等待著的人。
比如說，一個在晚窗前許願的孩子，他在等待著綠豆的幼苗在濕潤的棉花裡茁壯成長，並開花結果。
又比如說，一個無聲吶喊著的女人。他的丈夫，那醉醺醺的男人，又在發瘋。一頓拳打腳踢之後，她身上青一片、紫一片的。原來人的皮膚可以呈現如此斑駁的顏色。然而，她已不驚詫，因為暴力早教她看見青紫色的自己。不過，她在等待，她依猶在等待，依猶在等待那個婚禮上替自己戴上婚戒的他。
想著想着，她無端落下了一滴淚。原來，許多人也在歲月的長河裡無止境地等待著。等待的人並不孤單。
一幀泛黃且充滿顆粒感的照片裡，一個小女孩正佻皮地捏著母親的臉頰，母親佯作生氣，她幸福地「生氣」著。
可愛吧？這個左邊的小女孩，便是我的女兒。 
嗯，可愛。
同樣的對話，同樣的故事，在這八年的時光裡重重複複地敘述著。仿佛是一本八百頁的長篇小說，只有這樣的一段對話。但是，她仍樂此不疲地閱讀著小說的每一頁。因為，因為她已遺忘了上一頁的所有內容。
那個小女孩，便是我，而那位母親患了病，一場將我遺忘的病。
我一直等待著，等待著她有天重新憶記起我；等待著她像小時候一樣，摩娑著我的腦殼，溫柔地哄我入睡；等待著她生活裡每句使人心煩的嘮叨。我等待了八年，為此，我與她一起翻閱舊相冊，一起重遊所有老地方，然而奇蹟一直保持沉默，不作任何回應。在歲月的長河裡，只賺下佇立著、等候著的我。
女兒啊……
她又再躺在沙發上說著朦朦朧朧的囈語。
今晚煮了湯，放在客廳的……
「桌上」兩個音節裹未孵出來，便已胎死在掛掉的話裡了。那時的我，在過著燈紅酒綠的生活。月，仿佛才是昒暝的日出。一杯又一杯的長島冰茶灌進肚裡，根本容不下一碗溫熱的湯。
恰巧，也是八年的時間，媽媽也等待了八年的時間。她每一個晚上都在夢囈裡盼望著我歸家。然而等待一次又一次落空，只有蒼然寂寞的月色悄悄地透過窗戶，替她蓋上一張沒有溫度的被子。
八年後，我才真正明白等待的滋味，才體會到等待的煎熬。你是如何孤單地度過每一個昏暗的夜，如何忍受著一句句使你痛徹心扉的說話？一切的等待為了甚麼？
我的女兒回來了嗎？
你瞇著惺忪的睡眼問我。
還未，她還未回來，再等一下吧。
其實，她永遠都不會回來了，因為她已永恆地滯留在時光的隧道裡。在那個地方，夢即現實，回憶即現實，人永遠不會長大，更不會蒼老。因此之故，她永遠不會回來了。
至於我等待的人，等待的一聲呼喊，也不會回來了。她已羈困在一段停滯的時光裡，沒有逃逸，亦沒有人想逃逸。因為，她已等待得支離破碎，疲憊不堪了。
我們的等待，注定了落空。
但八年的等待裡，我終究參悟了落空的意義。正如那棵似乎會勃發生長的綠豆苗，也許一星期後便會似一場曉夢般枯萎，但孩子學會了生命的價值，學會了甚麼是失落，學會了憧憬在字典外的含義；又正如那個滿佈瘡痍的女人，在漫無邊際的等待裡，或許終於明白了有些等待並不值得，明白了有些等待並不值得，明白了有些等待只是一廂情願，於是鼓起離婚的勇氣。在等待裡，所有人都會找到新的意義。也許，等待只是一場燦爛奪目的煙花，只承諾開花，卻從不承諾結果。但在等待裡，我們都重新認識了自己和他人，甚或是人生。一如八年的等待，使我終於能體會媽媽的體會，孤寂、失望、無奈、感慨、悱惻，我都一一感受到了。她沒有遺下一句說話，便將我遺留在時光的彼岸，然而她內心最隱密的說話，我已諦聽到了。因為，我也成為了一個等待的人。等待的過程裡，我還學會了堅強、勇氣和耐心。從前，我何曾耐心地回應過她一句呢？
等著等著，她便像個孩子似的，哭嚷著要女兒回來，我溫柔地摩娑著她的髮絲、她的臉龐、她的下巴、她的背、她的手，又在她耳畔低語：「別怕，我與你一起等女兒回來，好不好？」她冷靜下來，默默地頷著首。
煙花，終於結了果，一如等待，終於在落空中結了果。</p>
</div>

<div id="example-yanhuo-l3">
<h3>《煙火》(3等範文)</h3>
<p>夏天的夜晚，總是充滿了期待。小明是小六的學生，他最喜歡的事情就是和家人一起去看煙火。每年的鎮上夏日祭典，廣場上都會放一場盛大的煙火表演。那絢麗的光芒、絢爛的色彩，總讓小明看得目不轉睛，心裡充滿了驚奇與快樂。
這一天，小明早早就吃完了晚飯，興奮地拉著爸爸媽媽的手，往廣場走去。路上，他看見許多鄰居和同學，大家都帶著笑容，提著小板凳或鋪著野餐墊，準備找個好位置欣賞煙火。小明的妹妹小芳也跟著，蹦蹦跳跳地哼著歌，手裡還拿著一根螢光棒，閃閃發光。
到了廣場，已經人山人海。小明一家找了一塊空地，鋪上毯子，坐下來等待。天空還有些微亮，夕陽的餘輝灑在遠處的山頭上，像一幅美麗的畫。廣場上有人在賣棉花糖和烤魷魚，香味飄過來，讓小明忍不住嚥了口口水。爸爸笑著說：「等看完煙火，爸爸給你買一串烤魷魚好不好？」小明高興地點點頭。
終於，天色完全暗了下來。突然，一聲「砰」的巨響劃破夜空，第一顆煙火像一朵巨大的金色菊花，在天空中綻放開來。人群中傳來一陣驚呼，小明瞪大了眼睛，嘴巴張成了「O」形。接著，紅的、藍的、綠的、紫的煙火一個接一個升空，有的像流星劃過，有的像瀑布傾瀉，還有的像一顆顆閃亮的星星，點亮了整個夜空。
小明最喜歡的是那種會「咻咻」轉圈的煙火。它們先是像火箭一樣衝上天，然後在空中轉出一個個彩色的光圈，好像在跳舞一樣。小芳拍著手喊：「好漂亮！像仙女在撒花！」小明也忍不住跟著喊：「再來一個！再來一個！」爸爸媽媽在一旁笑著，看著孩子們開心的模樣，也覺得特別幸福。
煙火表演持續了半個多小時，每一顆煙火都讓小明覺得驚喜萬分。他心想，這些煙火是怎麼做出來的呢？為什麼它們可以在天空中變出這麼多不同的形狀和顏色？表演結束後，小明忍不住問爸爸：「煙火是怎麼來的？是誰發明的？」
爸爸摸摸小明的頭，笑著說：「煙火的歷史很長喔！聽說是古代的中國人發明的。他們發現一些化學物質混在一起會爆炸，後來就用來做煙火，讓節日更熱鬧。每一顆煙火裡都有不同的化學藥劑，這些藥劑決定了它們的顏色和形狀。紅色的煙火可能有鍶，藍色的有銅，綠色的有鋇，這些都是科學的魔法！」
小明聽得眼睛亮亮的，覺得好神奇。他想像著一群科學家在實驗室裡調配藥劑，試著做出最漂亮的煙火。他心裡暗暗決定，回家後要上網查更多關於煙火的知識，或許將來他也能成為一個會做煙火的人！
煙火結束後，廣場上的人群慢慢散去。小明一家走在回家的路上，夜風輕輕吹過，帶著一絲涼意。小芳已經累得在爸爸的懷裡睡著了，小明卻還在回味剛剛的煙火。他抬起頭，看著滿天的星星，心裡充滿了夢想。他想，煙火就像人生一樣，雖然短暫，卻可以綻放出最美的光芒。只要努力，他相信自己也能像煙火一樣，在未來某一天閃耀屬於自己的光彩。
回到家，小明拿出日記本，寫下了今天的感受：「今晚的煙火好美！它們在天空中飛舞，像在告訴我，只要有夢想，就能飛得很高很高。我要好好學習，將來也要像煙火一樣，點亮別人的眼睛！」</p>
</div>

<!-- 新增議論文示例 -->
<div id="example-song-li">
<h3>《送禮之我見》</h3>
<p>每個人的一生都與禮物結下不解之緣。親友的滿月賀禮，承載著對新生命的祝福；長輩的壓歲紅包，包裹著對後輩的期許。然而，當物質洪流席捲現代社會，送禮這項古老習俗，卻在功利浪潮的沖刷下漸失本真，淪為人情往來的籌碼與攀比虛榮的角力場。人們穿梭於琳琅禮品間，精打細算著禮物的「價值」能否匹配關係的「份量」，卻鮮少思量這份心意是否仍如初生赤子般純粹無雜質。當饋贈的初衷被異化為計算，我們是否該停下腳步，重新審視禮物的真諦？

禮物的靈魂，從來不在其金玉其外的華美包裝，而在其蘊含的情意之真摯與純粹。古訓有云：「千里送鵝毛，禮輕情意重。」此語道破了饋贈的核心價值——心意遠勝物質。唐代詩人白居易在《秦中吟》中，對權貴間「一叢深色花，十戶中人賦」的奢靡饋贈極盡諷刺，揭露其虛榮浮誇的本質。反之，近代文豪魯迅，常以親筆題簽的書籍贈予青年學子。那薄薄一冊書，承載的是一位啟蒙者對後輩深沉的期許與精神火種的傳遞。魯迅深知，真正有力量的禮物，是能點亮心靈、啟迪思想的火炬，而非點綴門面的俗物。由此觀之，禮物之重，在於心意之深。若僅以價格衡量價值，則再貴重的禮品，亦不過是冰冷交易的憑證，失卻了情感交流的溫度。

可惜，當代社會中，禮物的異化現象俯拾皆是。饋贈時常淪為維繫社會關係網絡的工具，甚至背負著隱形的「債務枷鎖」。法國人類學家莫斯在《禮物》一書中精闢指出，傳統社會的禮物交換蘊含著「給予、接受、回報」的義務性循環，這股無形的社會壓力，常使受贈者感到負擔。反觀今日，此現象愈演愈烈。職場上，年節贈禮常被視為人情投資；婚宴嫁娶，賓客更暗自計較紅包厚薄是否「等值」。更甚者，如《紅樓夢》中賈府壽宴，王熙鳳對各房禮單的斤斤計較，將人情世故的算計演繹得淋漓盡致。當送禮者與受禮者皆困於「人情債」的算計，禮物便不再是心意的載體，而是淪為衡量利害得失的冰冷砝碼。這份計較，不僅磨損人際真誠，更使饋贈的初衷蒙塵。

或許有人辯稱，身處人情社會，送禮難以擺脫功利色彩，所謂「真誠」不過是理想化的奢談。此言差矣。禮物的真偽，關鍵在於饋贈者的用心與純粹。魏晉名士嵇康，面對好友山濤欲舉薦其為官的「厚禮」，選擇以《與山巨源絕交書》明志。這封看似決絕的信，恰恰是嵇康回贈給山濤最貴重的禮物——一份對本真與氣節的堅守。他寧願承受斷交的「失」，也不願以人格自由作為交換官位的「得」。嵇康的行為啟示我們，真正的禮物，源自內在的誠懇與尊重，而非外在的價值或目的。若內心澄澈，即便是婉拒，亦可成為一份震撼靈魂的厚禮；反之，若動機不純，再華貴的饋贈，亦不過是包裹著糖衣的虛偽交易。禮物的重量，終究繫於心意之秤，而非物質之衡。

誠然，在現實的夾縫中尋求全然超脫的饋贈境界並非易事。我們或許無法徹底摒棄人情往來的社會習性，但至少能在每一次饋贈前，叩問己心：這份禮物，是否源自純粹的關懷與祝福？而非包裹著交換、償還或炫耀的雜質。英國文豪王爾德曾諷刺道：「憤世嫉俗者知道所有東西的價格，卻不知道任何東西的價值。」這警語猶如明鏡，映照出我們在物質洪流中對價值的迷失。當我們過分執著於禮物的價格標籤，便極易遺忘其無價的情感內核。歸根結柢，送禮的最高藝術，在於使物質載體成為傳遞真情的使者，讓每一次贈予，都成為心靈間溫暖的交匯點。贈人玫瑰，手有餘香——這份香氣，源於真誠，存於心意，與物質的貴賤無涉。你我能否在下次饋贈時，讓這份芬芳，蓋過世俗的塵囂？</p>
</div>

<div id="example-lun-dushu">
<h3>《論讀書》</h3>
<p>讀書是一件很有趣又很重要的事情。小朋友們，你們喜歡讀書嗎？也許有的小朋友覺得讀書很無聊，但其實讀書可以讓我們變聰明、開心，還能認識很多新東西。今天我要來跟你們說說，為什麼讀書是一件很棒的事情。我會用簡單的理由告訴你們，讀書對我們有多好！

讀書就像打開一扇神奇的大門，裡面有很多新東西等著我們去發現。比如說，你有沒有想過恐龍是怎麼生活的？或者太空裡有什麼祕密？當你讀一本關於恐龍或太空的書，你就會知道好多有趣的事情。比如，我讀過一本書，說霸王龍的牙齒像香蕉一樣大！這是不是很酷？讀書可以讓我們學到課堂上沒教的東西，讓我們的腦袋裝滿知識。

不只科學，讀書還能讓我們認識不同的地方和文化。比如，你可以讀一本關於非洲的故事，知道那裡有大大的草原和跑得很快的獅子。這些知識讓我們對世界更好奇，也讓我們變得更聰明。所以，讀書就像一個寶藏箱，裡面裝滿了讓我們變厲害的知識！

你有沒有想過自己變成一個勇敢的騎士，或是飛到天上的超人？讀書可以幫我們想像這些很棒的事情！當我們讀故事書時，我們會跟著書裡的角色一起冒險。比如，我讀過一本書，講一個小男孩在森林裡找到一個魔法棒，然後他用魔法棒打敗了壞巫師。讀的時候，我好像也跟著他一起去冒險，感覺好刺激！

想像力很重要，因為它讓我們會想出新點子。當你畫畫、寫故事，或是玩遊戲時，好的想像力可以讓你做出很棒的事情。比如，你可能會因為讀了一本關於海盜的書，就自己畫了一艘很酷的海盜船！所以，讀書不只讓我們開心，還能讓我們的腦袋變得更有創意。

讀書不只能讓我們變聰明，還能讓我們的心變得更善良。有的書會教我們怎麼跟朋友相處，怎麼幫助別人。比如，我讀過一本書，講一個小女孩幫助了一隻受傷的小鳥，後來他們變成了好朋友。這個故事讓我覺得，幫助別人是一件很快樂的事情。

當我們讀這些故事時，我們會學到什麼是對的，什麼是錯的。這些書就像老師一樣，教我們怎麼做一個好人。比如，當你看到書裡的角色分享玩具，你也會想跟朋友分享東西。這樣，我們的心就會變得更溫暖，朋友也會更多！

有些小朋友可能會說：「讀書好無聊，我想玩遊戲或看電視！」我知道，玩遊戲和看電視也很開心，但它們跟讀書不一樣。遊戲和電視很快就會看完，但書裡的故事可以讓你慢慢想、慢慢感受。而且，讀書可以讓你自己決定故事怎麼走，比如你可以用想像力幫故事裡的角色想新的結局，這是遊戲和電視做不到的！

還有小朋友可能說：「書裡的字好多，看不懂！」沒關係，我們可以從簡單的書開始，比如圖畫書，裡面有好看的圖片，字也不多。慢慢地，你會發現讀書越來越簡單，也越來越有趣。所以，別害怕，試著讀一本你喜歡的書，你會發現它有多好玩！

總之，讀書是一件很棒的事情！它讓我們學到新知識，變得更有想像力，還能讓我們的心更溫暖。雖然有時候讀書可能有點難，但只要我們找到自己喜歡的書，就會覺得它像一個好朋友，陪我們一起成長。小朋友們，讓我們一起拿起書，開始一場知識的冒險吧！不管是故事書、科學書，還是漫畫書，每一本書都是一個新世界，等著我們去探索。每天讀一點書，你會發現自己越來越厲害，也越來越快樂！</p>
</div>




</div>








<!-- 內置的 DSE 評分原則 (隱藏) -->
<div id="dse-grading-principles" style="display: none;">
<h3>【擬卷理念】</h3>
<p>1. 考核能力：考核考生構思、表達、創作等能力。</p>
<p>2. 設題方式：或命題，或指定情境，並提供選擇。</p>
<p>3. 設題方向：主要環繞考生生活經驗及日常思考、關注的情或事；並盡量給予寫作空間，讓考生發揮創意。</p>
<p>4. 寫作要求：考生宜透過審題，思考寫作立意，選取材料，書寫文章。</p>
<p>5. 文體要求：以某類文體為主，或文體不限。</p>

<h3>【一般評分原則：審題、入品】</h3>
<p>1. 準確理解關鍵概念。</p>
<p>2. 明白寫作要求。</p>
<p>3. 把握不同品位的入品要求。</p>

<h3>【評分項目詳解】</h3>
<p><strong>內容 (40分):</strong></p>
<ul>
<li>立意、內容是否合乎寫作要求；是否豐富、深刻。</li>
<li>取材是否恰當；能否彰顯立意。</li>
<li>闡述是否合理、飽滿。</li>
</ul>
<p><strong>表達 (30分):</strong></p>
<ul>
<li>用詞是否精確、豐富。(主)</li>
<li>文句是否簡潔流暢。(主)</li>
<li>表達手法是否純熟靈活。(輔)</li>
</ul>
<p><strong>結構 (20分):</strong></p>
<ul>
<li>段落區分是否明晰。</li>
<li>起承轉合是否自然。</li>
<li>輕重詳略是否恰當。</li>
</ul>
<p><strong>標點字體 (10分):</strong></p>
<ul>
<li>字體為主，標點為輔。</li>
<li>標點使用在於準確和靈活，不在於數量多少。</li>
</ul>
<p><strong>錯別字 (3分):</strong></p>
<ul>
<li>0-1個給3分；2-4個給2分；5-7個給1分；8個或以上不給分。</li>
<li>重錯不計。</li>
</ul>

<h3>【離題卷評分】</h3>
<p>「內容」最高給「下上」；「表達」及「結構」最高給「中上」；「標點字體」最高仍可給「上上」。</p>

<h3>【字數不足650字】</h3>
<p>「內容」最高給分：550-649字：「上上」；450-549字：「中上」；300-449字：「中中(下)」；300字以下：「下上」。</p>

<h3>【一般評論摘要】</h3>
<p><strong>優勝之處:</strong></p>
<ul>
<li><strong>審題:</strong> 能正確理解題目。</li>
<li><strong>立意:</strong> 偶有佳作，能由日常生活引申至人生意義、生活哲理，呈現對生活有敏銳的觀察和思考。</li>
<li><strong>取材:</strong> 圍繞日常生活經歷或見聞取材。</li>
<li><strong>表達:</strong> 用詞大致恰當，文句大致通順；能恰當地敘事抒情、描繪人物或闡述看法；嘗試運用不同寫作手法。</li>
<li><strong>結構:</strong> 分段大致清晰，尚見脈絡；過渡合理，結構完整。</li>
</ul>
<p><strong>不足之處:</strong></p>
<ul>
<li><strong>審題:</strong> 流於表面，未抓緊題眼發揮。</li>
<li><strong>立意:</strong> 立意平常，層次不高。</li>
<li><strong>取材:</strong> 敘事忽略細節，描寫流於表面，論述粗疏簡略；未能翻出新意，提出精闢見解。</li>
<li><strong>表達:</strong> 經營不多，夾雜沙石；多口語入文、句子冗贅；部分與前文格格不入，影響達意。</li>
<li><strong>結構:</strong> 鮮能做到層層深化，前後呼應者；少數文章篇幅較長，惜時間所限，結果虎頭蛇尾；有詳略稍有失衡的情況。</li>
</ul>
</div>


<!-- 工具選擇 -->
<div class="box" id="toolsBox" style="display: none;">
    <h2>工具一覽：</h2>
    <button id="expandToolsBtn2">點擊展開</button>
<div id="effectContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; pointer-events: none;"></div>
</div>



<!-- 範疇選擇：動漫卡片風格 (已修訂：放入一致的 Container) -->
<div class="box" id="mainMenuBox"> <!-- 這裡加上了 ID -->
    <h2>選擇範疇：</h2>
    
   <!-- 音效檔：拔劍出鞘 (Metal Sword Sheath) -->
    <audio id="ui-click-sound" preload="auto">
        <source src="點擊.mp3" type="audio/mpeg">
    </audio>

    <div class="category-cards-wrapper">
        <div class="category-cards-container">
            <!-- 閱讀卡片 -->
            <div id="readingBtn" class="anime-card" style="--bg-img: url('郵筒.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                 
                    <div class="card-text">
                        <span class="card-zh">閱讀</span>
                        <span class="card-en">READING</span>
                    </div>
                </div>
            </div>

            <!-- 敘事抒情卡片 -->
            <div id="writingBtn" class="anime-card" style="--bg-img: url('相機.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                  
                    <div class="card-text">
                        <span class="card-zh">敘事抒情</span>
                        <span class="card-en">NARRATIVE</span>
                    </div>
                </div>
            </div>

            <!-- 議論卡片 -->
            <div id="argumentBtn" class="anime-card" style="--bg-img: url('筆.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                
                    <div class="card-text">
                        <span class="card-zh">議論</span>
                        <span class="card-en">ARGUMENT</span>
                    </div>
                </div>
            </div>

            <!-- 整合拓展卡片 -->
            <div id="expandBtn" class="anime-card" style="--bg-img: url('火車.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                  
                    <div class="card-text">
                        <span class="card-zh">整合拓展</span>
                        <span class="card-en">EXPAND</span>
                    </div>
                </div>
            </div>

          <!-- ★★★ 請在這裡插入這行代碼 ★★★ -->
<div class="section-separator"></div>

<!-- 課外書籍卡片 -->
<div id="booksBtn" class="anime-card" style="--bg-img: url('書.png');">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
             
                    <div class="card-text">
                        <span class="card-zh">課外書籍</span>
                        <span class="card-en">LIBRARY</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 寫作容器 -->
<div id="writingContainer" class="box">
    <h2>敘事抒情</h2>
    <div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/lke2eo?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

    <div class="function-selector-wrapper">
        <label for="writingType">選擇功能：</label>
        <select id="writingType" onchange="toggleWritingType()">
            <option value="" selected disabled>請在此選擇功能</option>
           
            <option value="大綱">大綱點評</option>
            <option value="片段描寫">文章點評</option>
			 <option value="guide">解題指引</option>
            <option value="敘事物象">敘事物象</option>
        </select>
    </div>

    <div id="writingContentContainer" style="display: none;">
        
        <!-- === 新增：解題指引區域 (修訂版) === -->
        <div id="writingGuideArea" style="display: none;">
            <label for="writingGuideTopicInput">請輸入題目：</label>
            <input type="text" id="writingGuideTopicInput" placeholder="例如：寂寞的真相、被遺忘的承諾..." style="font-size: 1.1rem;">
            
            <button id="submitWritingGuideBtn" class="btn-action" onclick="submitWritingGuide()">提交分析</button>

            <!-- 結果顯示區 -->
            <div id="writingGuideResultContainer" style="display: none; margin-top: 25px;">
                
                <!-- 第一部分：關鍵詞張力分析 -->
                <div class="guide-section-header" style="border-left: 5px solid #4A90E2; color: #4A90E2;">
                    <h3><i class="fas fa-search"></i> 題眼分析</h3>
                </div>
                <!-- 總體分析 (比喻與關係) -->
                <div id="guideIntro" class="guide-intro-card"></div>
                <!-- 三種心情 (三欄佈局) -->
                <div id="guideEmotions" class="guide-grid-3"></div>

                <!-- 第二部分：寫作方向建議 -->
                <div class="guide-section-header" style="border-left: 5px solid #28a745; color: #28a745; margin-top: 30px;">
                    <h3><i class="fas fa-compass"></i> 寫作方向</h3>
                </div>
                <!-- 三個故事種子 (三欄佈局) -->
                <div id="guideSeeds" class="guide-grid-3"></div>


<!-- 新增：解題指引的聊天室介面 -->
                <div id="writingGuideChatHistory" style="display: none; background-color: #f0f4f8; border: 1px solid #dde3ea; border-radius: 12px; padding: 20px 15px; margin-top: 15px; margin-bottom: 15px; max-height: 400px; overflow-y: auto; flex-direction: column;"></div>
                
                <div id="writingGuideChatInputContainer" style="display: none; align-items: center; gap: 10px; margin-top: 15px;">
                    <textarea id="writingGuideUserInput" class="no-modal-editor" rows="2" placeholder="可就以上指引追問..." style="flex-grow: 1; margin: 0;"></textarea>
                    <button id="continueWritingGuideBtn" class="btn-icon-action" onclick="continueWritingGuideDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
				</div>

				
                <!-- 儲存按鈕 -->
                <div class="result-wrapper">
                    <button id="save-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-敘事抒情-解題指引.html')" style="display: flex;">
                        <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    </button>
                </div>
            </div>
        </div>
        <!-- === 新增結束 === -->

        <div id="outlineStructureArea" style="display: none;">
            <label for="structure">選擇大綱結構：</label>
            <select id="structure" onchange="generateOutlineTable()">
                <option value="fourPart">起承轉合</option>
                <option value="threeLine">三線</option>
            </select>
        </div>
        
        <!-- ... 舊有代碼保持不變 ... -->
        <div id="topicSelectionArea">
            <label>選擇題目方式：</label>
            <div class="topic-buttons-container">
                <button class="btn btn-generate" onclick="generateTopic(this)">
                    <i class="fas fa-sync-alt"></i> 生成
                </button>
                <button class="btn btn-custom" onclick="showCustomTopicInput(this)">
                    <i class="fas fa-edit"></i> 自訂
                </button>
            </div>
            <div id="customTopicArea" style="display: none; margin-top: 15px;"></div>
        </div>

        <div id="topicResult"></div>
        <div id="narrativeElementsArea" style="display: none;">
            <label for="narrativeElements">請輸入您的取材或故事背景：</label>
            <textarea id="narrativeElements" rows="5" placeholder="例如：故事背景、人物設定、取材等..."></textarea>
        </div>
        
        <div id="writingArea">
            <div id="outlineTableArea"></div>
            <div id="outlineButtons" style="display: none;" class="action-buttons-container">
                <button class="btn-icon-action btn-save-icon" onclick="saveOutline()" title="儲存大綱">
                    <i class="fas fa-save"></i>
                </button>
                <button class="btn-icon-action btn-clear-icon" onclick="clearOutline()" title="清空大綱">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
            <textarea id="writingContent" rows="10" placeholder="請在此輸入您的文章..." style="display: none;"></textarea>
            
            <label for="writingTone" id="writingToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
            <select id="writingTone" style="display: none;">
                <option value="serious">嚴肅正經</option>
                <option value="chen">陳SIR語氣</option>
            </select>

            <label for="writingReviewer" id="writingReviewerLabel" class="tone-selector-label" style="display: none;">選擇閱卷員：</label>
            <select id="writingReviewer" style="display: none;">
                <option value="chen_sir" selected>陳Sir</option>
                <option value="ms_chan">Ms Chan</option>
                <option value="huang_laoshi">黃老師</option>
                <option value="deng_laoshi">鄧老師</option>
                <option value="xiao_laoshi">蕭老師</option>
                <option value="dong_laoshi">董老師</option>
                <option value="li_laoshi">李老師</option>
                <option value="zhen_laoshi">甄老師</option>
                <option value="wen_laoshi">溫老師</option>
                <option value="jiang_laoshi">江老師</option>
            </select>

            <div id="reviewScopeArea" style="display: none; margin-top: 25px;">
                <label class="tone-selector-label">選擇點評範疇：</label>
                <div class="scope-selector-container">
                    <label class="scope-label all-scope"><input type="checkbox" name="reviewScope" value="全部" checked> 全部</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="扣題"> 扣題</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="立意"> 立意</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="取材"> 取材</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="詳略"> 詳略</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="文筆"> 文筆</label>
                </div>
            </div>

            <button id="submitWritingBtn" class="btn-action" onclick="submitWriting()">提交</button>
            
            <div id="writingReviewResultContainer">
                <div id="writingGradingResult"></div>
                <div id="writingChatHistory" style="display: none;"></div>
                <div id="writingChatInputContainer" style="display: none;">
                    <textarea id="writingUserInput" class="no-modal-editor" rows="2" placeholder="可就以上點評追問..."></textarea>
                    <button id="continueWritingBtn" class="btn-icon-action" onclick="continueWritingDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
            
            <div class="result-wrapper" style="position: relative;">
                <div id="commentResult"></div>
              
            </div>
        </div>
    </div>
</div>



<!-- 閱讀容器 -->
<div id="readingContainer" class="box" style="display: none;">
<h2>閱讀</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/vt3i1j?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="readingFunction">選擇功能：</label>
<select id="readingFunction" onchange="toggleReadingFunction()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="comment">點評</option>
<option value="guide">指引</option>
<option value="training">訓練</option>  <!-- 新增此行 -->
</select>
</div>

<div id="readingInputArea" style="display: none;">
<label for="readingPassage">貼上閱讀篇章：</label>
<textarea id="readingPassage" rows="10" placeholder="請在此貼上閱讀篇章..."></textarea>
<label for="readingQuestion">貼上題目：</label>
<textarea id="readingQuestion" rows="3" placeholder="請在此貼上題目..."></textarea>
<div id="studentAnswerArea" style="display: none;">
<label for="studentAnswer">貼上答案：</label>
<textarea id="studentAnswer" rows="5" placeholder="請在此貼上答案..."></textarea>
</div>
<label for="readingTone" id="readingToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
<select id="readingTone" style="display: none;">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<!-- 將 <button onclick="submitReading()"> 改為： -->
<button id="submitReadingBtn" class="btn-action" onclick="submitReading()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="readingResult"></div>
	
</div>
</div>
</div>

<!-- 課外書籍容器 -->
<div id="booksContainer" class="box" style="display: none;">
<h2>課外書籍討論</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/4eznsi?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<!-- 初始輸入表單 -->
<div id="initialDiscussionForm">
<p>請在下方填寫書名、作者和討論問題，開始與陳SIR對話：</p>
<input type="text" id="bookTitle" class="no-modal-editor" placeholder="書名">
<input type="text" id="author" class="no-modal-editor" placeholder="作者">
<textarea id="discussionQuestion" class="no-modal-editor" rows="3" placeholder="討論問題"></textarea>
<label for="booksTone">選擇語氣：</label>
<select id="booksTone">
<option value="serious">嚴肅正經</option>
<option value="casual">輕鬆活潑</option>
</select>
<div id="discussionControlButtons">
<button id="startDiscussionBtn" class="btn-action" onclick="startDiscussion()">開始討論</button>
</div>
</div>

<!-- 聊天歷史紀錄 -->
<div class="result-wrapper" style="position: relative;">
	<div id="chatHistory"></div>
	
</div>


<!-- 聊天輸入介面 (已移除新增按鈕) -->
<div id="chatInputContainer">
<textarea id="userInput" class="no-modal-editor" rows="2" placeholder="請在此輸入您的回應..."></textarea>
<button id="continueBtn" class="btn-icon-action" onclick="continueDiscussion()" title="繼續討論" style="background-color: #2d9966;">
<i class="fas fa-paper-plane"></i>
</button>
</div>

<!-- 儲存/清除按鈕 (已加入新增按鈕) -->
<div id="booksButtons" class="action-buttons-container">
  
	
<!-- 「新增討論」按鈕已移到此處，位於儲存按鈕左方 -->
<button id="newTopicBtn" class="btn-icon-action btn-add-icon" title="新增討論主題">
<i class="fas fa-plus"></i>
</button>
<button class="btn-icon-action btn-save-icon" onclick="saveBooksChat()" title="儲存對話">
<i class="fas fa-save"></i>
</button>
<button class="btn-icon-action btn-clear-icon" onclick="clearBooksChat()" title="清空對話">
<i class="fas fa-trash-alt"></i>
</button>
</div>
</div>

<!-- 新增討論的彈出視窗 -->
<div id="newTopicModal" class="books-modal">
<div class="modal-content">
<span class="close-modal-btn" id="closeNewTopicModal">&times;</span>
<h3>新增討論</h3>
<input type="text" id="modalBookTitle" class="no-modal-editor" placeholder="書名">
<input type="text" id="modalAuthor" class="no-modal-editor" placeholder="作者">
<textarea id="modalDiscussionQuestion" class="no-modal-editor" rows="3" placeholder="討論問題"></textarea>
<div style="text-align: right; margin-top:15px;">
<button id="modalStartDiscussionBtn" class="btn-icon-confirm" title="開始新討論">
<i class="fas fa-check"></i>
</button>
</div>
</div>
</div>


<!-- 整合拓展容器 -->
<div id="expandContainer" class="box" style="display: none;">
<h2>整合拓展</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/2otwxv?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="expandFunction">選擇功能：</label>
<select id="expandFunction" onchange="toggleExpandFunction()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="comment">點評</option>
<option value="guide">指引</option>
</select>
</div>

<div id="expandContentContainer" style="display: none;">

<div id="expandTopicSelectionArea" style="display: none;">
<label>選擇題目方式：</label>
<div class="topic-buttons-container">
<!-- 套用新的 class: btn-generate -->
<button class="btn btn-generate" onclick="generateExpandTopic(this)">
<i class="fas fa-sync-alt"></i> 生成
</button>
<!-- 套用新的 class: btn-custom -->
<button class="btn btn-custom" onclick="showExpandCustomTopicInput(this)">
<i class="fas fa-edit"></i> 自訂
</button>
</div>
<!-- 這個 div 用來動態顯示自訂題目的輸入框 -->
<div id="expandCustomTopicInputArea" style="display: none; margin-top: 15px;">
</div>
</div>
<div id="expandTopicResult"></div>

<div id="expandWritingArea" style="display: none;">
<label for="expandContent">整合拓展（最多180字）：</label>
<textarea id="expandContent" rows="5" placeholder="請在此輸入整合拓展內容..." oninput="updateCharCount()"></textarea>
<p id="charCount">剩餘字數：180</p>
<label for="expandTone" id="expandToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
<select id="expandTone" style="display: none;">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<!-- 將 <button onclick="submitExpand()"> 改為： -->
<button id="submitExpandBtn" class="btn-action" onclick="submitExpand()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="expandCommentResult"></div>
	
</div>
</div>

<div id="expandGuideArea" style="display: none;">
<table>
<tr><th>題目</th><td><input type="text" id="expandGuideTitle" placeholder="請輸入題目"></td></tr>
<tr><th>主題句</th><td><textarea id="expandGuideTheme" rows="2" placeholder="請輸入主題句"></textarea></td></tr>
<tr><th>抄錄資料</th><td><textarea id="expandGuideData" rows="3" placeholder="請輸入抄錄資料"></textarea></td></tr>
<tr><th>整合拓展</th><td><textarea id="expandGuideExpand" rows="3" placeholder="請輸入整合拓展"></textarea></td></tr>
</table>
<!-- 【修訂處】為按鈕添加 ID -->
<button id="submitExpandGuideBtn" class="btn-action" onclick="submitExpand()">提交</button>
<div style="position: relative;">
	<div id="expandGuideResult"></div>

</div>
</div></div>
</div>

<!-- 議論容器 -->
<div id="argumentContainer" class="box" style="display: none;">
<h2>議論</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/0ki8mx?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="argumentType">選擇功能：</label>
<select id="argumentType" onchange="toggleArgumentType()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="outline">大綱點評</option>
<option value="writing">文章點評</option>
<option value="guide">指引</option>
</select>
</div>

<div id="argumentContentContainer" style="display: none;">
<div id="argumentTopicSelectionArea">
<label>選擇題目方式：</label>
<div class="topic-buttons-container">
<!-- 套用新的 class: btn-generate -->
<button class="btn btn-generate" onclick="generateArgumentTopic(this)">
<i class="fas fa-sync-alt"></i> 生成
</button>
<!-- 套用新的 class: btn-custom -->
<button class="btn btn-custom" onclick="showArgumentCustomTopicInput(this)">
<i class="fas fa-edit"></i> 自訂
</button>
</div>
<div id="argumentCustomTopicArea" style="display: none; margin-top: 15px;">
<!-- 內容將由 JavaScript 動態生成 -->
</div>
</div>
<div id="argumentTopicResult"></div>
<div id="argumentOutlineArea" style="display: none;">

<div id="argumentOutlineTableArea"></div>

<!-- 按鈕容器現在包含了新增、儲存和清除按鈕 -->
<div id="argumentOutlineButtons" class="action-buttons-container">
<button class="btn-icon-action btn-add-icon" onclick="addArgumentStructureSegment()" title="新增結構段">
<i class="fas fa-plus"></i>
</button>
<button class="btn-icon-action btn-save-icon" onclick="saveArgumentOutline()" title="儲存大綱">
<i class="fas fa-save"></i>
</button>
<button class="btn-icon-action btn-clear-icon" onclick="clearArgumentOutline()" title="清空大綱">
<i class="fas fa-trash-alt"></i>
</button>
</div>

<label for="argumentOutlineTone" class="tone-selector-label">選擇點評語氣：</label>
<select id="argumentOutlineTone">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<button id="submitArgumentOutlineBtn" class="btn-action" onclick="submitArgumentOutline()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="argumentOutlineResult"></div>

</div>
</div>
<div id="argumentWritingArea" style="display: none;">
<textarea id="argumentWritingContent" rows="10" placeholder="請在此輸入您的文章..."></textarea>
<label for="argumentWritingTone" class="tone-selector-label">選擇點評語氣：</label>
<select id="argumentWritingTone">
        <option value="serious">嚴肅正經</option>
        <option value="chen">陳SIR語氣</option>
    </select>

    <!-- ======= 請在這裡加入以下程式碼 ======= -->
    <label for="argumentReviewer" class="tone-selector-label">選擇閱卷員：</label>
    <select id="argumentReviewer">
      <option value="chen_sir" selected>陳Sir</option>
      <option value="ms_chan">Ms Chan</option>
      <option value="huang_laoshi">黃老師</option>
      <option value="deng_laoshi">鄧老師</option>
      <option value="xiao_laoshi">蕭老師</option>
      <option value="dong_laoshi">董老師</option>
      <option value="li_laoshi">李老師</option>
      <option value="zhen_laoshi">甄老師</option>
      <option value="wen_laoshi">溫老師</option>
      <option value="jiang_laoshi">江老師</option>
    </select>
    <!-- ======= 加入結束 ======= -->

<!-- ======= 請在這裡加入【議論文點評範疇】HTML 程式碼 ======= -->
<div id="argumentReviewScopeArea" style="display: none; margin-top: 25px;">
    <label class="tone-selector-label">選擇點評範疇：</label>
    <div class="scope-selector-container">
        <label class="scope-label all-scope"><input type="checkbox" name="argumentReviewScope" value="全部" checked> 全部</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="謀篇"> 謀篇</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論點"> 論點</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論據"> 論據</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論證"> 論證</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="文筆"> 文筆</label>
    </div>
</div>
<!-- ======= 加入結束 ======= -->

  <button id="submitArgumentWritingBtn" class="btn-action" onclick="submitArgumentWriting()">提交</button>

    <!-- 正確的結構：用 result-wrapper 包裹住所有結果和聊天介面 -->
    <div class="result-wrapper">
        
        <!-- 評分卡、文字點評和聊天介面都將被動態放入這個容器中 -->
        <div id="argumentReviewResultContainer">
            <!-- 評分系統或聚焦式點評將會被動態插入到這裡 -->
            <div id="argumentGradingResult"></div>

            <!-- 聊天歷史紀錄 -->
            <div id="argumentChatHistory" style="display: none;"></div>

            <!-- 聊天輸入介面 -->
            <div id="argumentChatInputContainer" style="display: none;">
                <textarea id="argumentUserInput" class="no-modal-editor" rows="2" placeholder="可就以上點評追問..."></textarea>
                <button id="continueArgumentBtn" class="btn-icon-action" onclick="continueArgumentDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>

    
    </div>
</div>
<div id="argumentGuideArea" style="display: none;">
<label for="argumentGuideTopic">題目：</label>
<input type="text" id="argumentGuideTopic" placeholder="請輸入題目">
<label for="argumentGuidePoint">論點（可選）：</label>
<textarea id="argumentGuidePoint" rows="3" placeholder="請輸入論點"></textarea>
<label for="argumentGuideEvidence">論據（可選）：</label>
<textarea id="argumentGuideEvidence" rows="3" placeholder="請輸入論據"></textarea>
<label for="argumentGuideArgument">論證（可選）：</label>
<textarea id="argumentGuideArgument" rows="3" placeholder="請輸入論證"></textarea>
<button id="submitArgumentGuideBtn" class="btn-action" onclick="submitArgumentGuide()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="argumentGuideResult"></div>
	
</div>
</div>
</div>
</div>

<!-- 音樂播放器 HTML (已更換圖示) -->
<!-- 音樂播放器 HTML (已移除懸浮按鈕) -->
<div id="music-player">
    <div class="controls">
        <select id="music-select">
            <option value="">選擇音樂</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-Abysswalker.mp3">The Abysswalker</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-Rosemoon.mp3">死せる都の戰乙女</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-deadly.mp3">五大罪</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-rapier.mp3">繼承劍的少女</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Ariadne-Battle.mp3">不屈意志之刃</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/battle-arms.mp3">西部戰鬥</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Battle.mp3">Battle Theme</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Wanderers-City.mp3">流浪城鎮</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Remotest-Liblary.mp3">沉睡的記憶</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Nostalgia.mp3">麥田懷舊</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/sunbeams.mp3">放學後</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/village.mp3">鄉村生活</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Take-a-Rest.mp3">休息一下</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/winter-snow.mp3">雪鄉</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Forgotten-Place.mp3">被遺忘的地方</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Rest-in-Peace.mp3">安息</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Farewell.mp3">告別</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/reminiscence.mp3">回憶</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/starry-night.mp3">星夜</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/last-wish.mp3">當思念傳到某人耳畔</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/sorrow.mp3">超越悲傷</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/hotarumichi.mp3">螢火蟲之路</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Sky-Airship.mp3">飛艇</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/Voyage_SE.mp3">跨越神秘之海</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/main-theme01.mp3">盼望</option>
            <option value="https://youfulca.com/wp-content/uploads/2022/08/saikai637.mp3">約定之地</option>
        </select>
        <button id="play-pause" title="播放/暫停"><i class="fas fa-play"></i></button>
    </div>
    
    <div class="progress">
        <input type="range" id="progress-bar-music" value="0" min="0" max="100">
    </div>
    
    <div class="mode">
        <select id="play-mode">
            <option value="loop" selected>單曲循環</option>
            <option value="next">自動播放下首</option>
        </select>
    </div>
    
    <button class="hide-btn" id="hide-player" title="關閉播放器"><i class="fas fa-chevron-down"></i></button>
</div>

<!-- 必須保留這個 audio 標籤，否則無法播放音樂 -->
<audio id="audio" preload="auto"></audio>

<!-- === 歷史紀錄容器 (最終版) === -->
<div id="historyContainer" class="box" style="display: none;">
    
 <!-- 標題列 -->
    <div class="history-header-bar" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #eee;">
        <h2 style="margin:0; color: #333; font-size: 1.5em;"><i class="fas fa-history"></i> 歷史紀錄</h2>
        
        <div style="display: flex; gap: 10px;">
            
            <!-- ★★★ 新增：生成學習報告按鈕 ★★★ -->
           <button class="history-clear-btn" title="學習報告" onclick="openReportMenu()" style="color: #2A9689;">
    <i class="fas fa-chart-pie"></i>
</button>
            <!-- ★★★ 新增結束 ★★★ -->

            <!-- 原有的：日期搜尋按鈕 -->
            <div id="historyDateSearchContainer" style="display: none; position: relative;">
                <button class="history-clear-btn" title="依日期搜尋" onclick="triggerDatePicker()">
                    <i class="fas fa-calendar-alt"></i>
                </button>
                <input type="date" id="historyDatePicker" onchange="scrollToHistoryDate(this)" 
                       style="position: absolute; top: 0; left: 0; width: 0; height: 0; opacity: 0; border: none; padding: 0;">
            </div>

            <!-- 原有的：清空按鈕 -->
            <button class="history-clear-btn" title="清空所有紀錄" onclick="clearAllHistory()">
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    </div>


	<!-- 學習報告操作選單 (新增) -->
<div id="reportMenuModal" class="report-menu-overlay" onclick="closeReportMenu(event)">
    <div class="report-menu-content">
        <div class="report-menu-title">學習報告</div>
        <div class="report-options-grid">
            <!-- 選項一：生成新報告 -->
            <div class="report-option-card" onclick="generateHistoryReport()">
                <i class="fas fa-magic report-option-icon"></i>
                <span class="report-option-text">生成新報告</span>
            </div>
            <!-- 選項二：檢閱紀錄 -->
            <div class="report-option-card" onclick="viewPastReports()">
                <i class="fas fa-folder-open report-option-icon"></i>
                <span class="report-option-text">檢閱紀錄</span>
            </div>
        </div>
    </div>
</div>

    <!-- 麵包屑導航 -->
    <div id="historyBreadcrumb" class="history-breadcrumb" style="display: none; margin-bottom: 20px; padding: 10px 15px; background: rgba(0,0,0,0.05); border-radius: 8px; font-size: 1rem;">
        <span onclick="renderHistoryCategories()" style="cursor: pointer; color: #007bff; font-weight: bold;"><i class="fas fa-home"></i> 主範疇</span> 
        <span id="breadcrumb-sep-1" style="display:none; color: #666;"> &gt; </span>
        <span id="breadcrumb-category" onclick="backToSubFunctions()" style="cursor: pointer; color: #007bff; display:none;"></span>
        <span id="breadcrumb-sep-2" style="display:none; color: #666;"> &gt; </span>
        <span id="breadcrumb-sub" style="font-weight: bold; color: #333; display:none;"></span>
    </div>

    <!-- 第一層：主範疇選擇 (卡片容器) -->
    <div id="historyLevel1Wrapper" class="category-cards-wrapper" style="padding-top: 10px; padding-bottom: 20px;">
        <div id="historyLevel1" class="category-cards-container">
            <!-- JS 將在這裡生成動漫卡片 -->
        </div>
    </div>

    <!-- 第二層：子功能選擇 (Grid 選單) -->
    <div id="historyLevel2" class="history-grid-menu" style="display: none;">
        <!-- JS 生成子功能按鈕 -->
    </div>

    <!-- 第三層：紀錄列表 -->
    <div id="historyLevel3" class="history-list-container" style="display: none;">
        <!-- JS 生成紀錄卡片 -->
    </div>
</div>

<!-- === 歷史紀錄詳細檢視視窗 (保持不變) === -->
<div id="historyModal" class="preview-modal-overlay">
    <div class="preview-modal-content" style="max-width: 900px; height: 90%;">
        <div class="history-modal-header" style="padding: 15px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center;">
            <h3 id="historyModalTitle" style="margin: 0; color: #2A9689;">紀錄詳情</h3>
            <span id="historyModalDate" style="color: #888; font-size: 0.9em;"></span>
        </div>
        <div class="preview-modal-body" style="padding: 20px; overflow-y: auto; display: block;">
            <div id="historyModalContent"></div>
        </div>
        <button class="preview-close-btn" onclick="closeHistoryModal()" style="top: 10px; right: 10px;">&times;</button>
    </div>
</div>

	
<!-- 展開工具二 (語薈) 容器 -->
<div id="toolsContainer2">
<button id="closeToolsBtn2">&times;</button>
<div class="main-container">
<!-- Floating Title -->
<!-- Floating Title -->
<header class="floating-header">
<h1>語薈</h1>
<button id="video-tour-btn" title="觀看介紹影片">
<svg class="icon" viewBox="0 0 24 24"><use xlink:href="#icon-video"></use></svg>
</button>
</header>

<!-- Embedded SVG Icons -->
<svg width="0" height="0" style="position:absolute">
<defs>
<symbol id="icon-brain" viewBox="0 0 24 24"><path d="M7.445 11.232C7.445 10.537 7.98 9.96 8.629 9.96H9.02V8.203H7.818C6.983 8.203 6.3 8.91 6.3 9.778V11.23H5.161C4.326 11.23 3.644 11.938 3.644 12.806V14.17H2.82C2.17 14.17 1.636 14.746 1.636 15.44V17.65H1.523C.688 17.65 0 18.358 0 19.226V20.48C0 21.35 0.688 22.056 1.523 22.056H6.738C6.738 23.13 7.573 24 8.628 24H15.37C16.425 24 17.26 23.13 17.26 22.058H22.477C23.312 22.058 24 21.35 24 20.48V19.225C24 18.357 23.312 17.65 22.477 17.65H22.364V15.44C22.364 14.745 21.83 14.17 21.18 14.17H20.356V12.805C20.356 11.937 19.674 11.23 18.839 11.23H17.68V9.777C17.68 8.908 17.017 8.2 16.182 8.2H14.98V9.96H15.37C16.02 9.96 16.555 10.536 16.555 11.23V12.986H15.37V15.92H8.629V12.986H7.445V11.232M11.1 11.23H12.9V14.17H11.1V11.23M12 1.947C10.13 1.947 8.58 2.894 7.854 4.316C7.65 3.52 7.2 2.813 6.545 2.27C5.124 1.053 2.95 1.54 1.987 3.16C0.945 4.925 1.489 7.346 3.09 8.528C3.21 8.62 3.33 8.71 3.464 8.78C3.464 7.024 4.818 5.618 6.52 5.618C8.22 5.618 9.573 7.024 9.573 8.78V9.1H14.4V8.78C14.4 7.024 15.78 5.618 17.48 5.618C19.18 5.618 20.536 7.024 20.536 8.78C20.662 8.71 20.782 8.62 20.91 8.528C22.51 7.346 23.055 4.925 22.013 3.16C21.05 1.54 18.876 1.053 17.455 2.27C16.8 2.813 16.35 3.52 16.145 4.316C15.42 2.894 13.87 1.947 12 1.947Z"/></symbol>
<symbol id="icon-write" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z" /></symbol>
<symbol id="icon-read" viewBox="0 0 24 24"><path d="M18.5,1.15C19.9,1.15 21.15,2.4 21.15,3.85V15.85C21.15,17.3 19.9,18.55 18.5,18.55H5.5C4.1,18.55 2.85,17.3 2.85,15.85V3.85C2.85,2.4 4.1,1.15 5.5,1.15H18.5M18.5,22.85H5.5C2.45,22.85 0,20.4 0,17.35V2.35C0,1.4 0.35,0.6 0.95,0.1C1.25,-0.1 1.7,-0.05 2,0.25L3.1,1.35C3.3,1.55 3.3,1.85 3.1,2.05L2.05,3.1C1.85,3.3 1.55,3.3 1.35,3.1L0.7,2.45C0.7,5.55 2.85,7.85 5.5,7.85H18.5C21.15,7.85 23.3,5.55 23.3,2.45L22.6,3.1C22.4,3.3 22.1,3.3 21.9,3.1L20.85,2.05C20.65,1.85 20.65,1.55 20.85,1.35L21.95,0.25C22.25,-0.05 22.7,-0.1 23,0.1C23.6,0.6 24,1.4 24,2.35V17.35C24,20.4 21.5,22.85 18.5,22.85Z" /></symbol>
<symbol id="icon-work" viewBox="0 0 24 24"><path d="M14,6V4H10V6H14M18,9H15V6H9V9H6A2,2 0 0,0 4,11V19A2,2 0 0,0 6,21H18A2,2 0 0,0 20,19V11A2,2 0 0,0 18,9Z" /></symbol>
<symbol id="icon-support" viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></symbol>
<symbol id="icon-foundation" viewBox="0 0 24 24"><path d="M12 2L2 7V17L12 22L22 17V7L12 2ZM19.6 8.25L12 12.5L4.4 8.25L12 4L19.6 8.25Z"/></symbol>
<symbol id="icon-explore" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A1.5,1.5 0 0,1 13.5,5.5A1.5,1.5 0 0,1 12,7A1.5,1.5 0 0,1 10.5,5.5A1.5,1.5 0 0,1 12,4M12,18.2C9.5,18.2 7.29,16.42 6.5,14H17.5C16.71,16.42 14.5,18.2 12,18.2Z"/></symbol>
<symbol id="icon-video" viewBox="0 0 24 24"><path d="M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z" /></symbol>
</defs>
</svg>

<!-- Mind Map Layout -->
<main class="mind-map-container" id="mind-map">
<svg class="connector-svg" id="connector-svg"></svg>

<!-- 1. Core AI -->
<div class="category" id="core-ai" data-connect-to="">
<div class="node" data-id="core-ai-node" style="padding: 10px 20px;">
<a href="https://kenchan20141.github.io/AIChinese/" data-tool-id="sansi">






<svg class="icon" style="width:32px; height:32px;"><use xlink:href="#icon-brain"></use></svg>
神思
</a>
</div>
<div class="sub-group" style="flex-direction: row; gap: 10px;">

<div class="node level-3"><a href="https://sansi.vercel.app/" data-tool-id="sansi-v3">神思 (備用)</a></div>
</div>
</div>

<!-- Foundations tier -->
<div id="foundations" data-connect-to="core-ai-node">
<div class="foundation-item" data-id="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-foundation"></use></svg>應試</div>
<div class="sub-group-title">AI擬題</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/generator/" data-tool-id="tizi">題孳<br></a></div>
</div>
<div class="foundation-item" data-id="foundation-explore">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-explore"></use></svg>課外探索</div>
<div class="sub-group-title">課外篇章</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/reading/" data-tool-id="reading-pieces">文學・片段</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/mensyu/" data-tool-id="mensyu">文樞</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/slowreading/" data-tool-id="slowreading">慢讀</a></div>
<div class="sub-group-title">主題探討</div>
<div class="node level-2"><a href="https://litstudy.vercel.app/" data-tool-id="study">文學專題探究</a></div>

<div class="sub-group-title">生活詩意</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/wabisabi/" data-tool-id="wabisabi">一瞬之詩</a></div>
<div class="sub-group-title">書籍推薦</div>
<div class="node level-2"><a href="https://621d05f47d591.site123.me/%E6%9B%B8%E9%96%A3%E8%97%8F%E6%9B%B8%E6%A6%82%E8%A6%BD" data-tool-id="book-overview">書籍概覽</a></div>
	<div class="sub-group-title">歌詞遊戲</div>
<div class="node level-2"><a href="https://lyricschi.vercel.app/" data-tool-id="lyrics">詞海拾心</a></div>
</div>
</div>

<!-- 2. Writing -->
<div class="category" id="writing" data-connect-to="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-write"></use></svg>寫作創作</div>
<div class="sub-group">
<div class="sub-group-title">AI範文</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/article/" data-tool-id="fanshui-narrative">翻水 (敘事)</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/essay/" data-tool-id="fanshui-argument">翻水 (議論)</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">草擬</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/manuscriptpaper/" data-tool-id="manuscript">智能原稿紙</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">潤色與延伸</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/words/" data-tool-id="words">字斟・句酌</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/slideshow/" data-tool-id="slideshow">文章幻燈片</a></div>
</div>
</div>

<!-- 3. Reading -->
<div class="category" id="reading" data-connect-to="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-read"></use></svg>閱讀溫習</div>
<div class="sub-group">
<div class="sub-group-title">課文溫習</div>
<div class="node level-2" id="yuyilu-toggle"><a href="#">語弈錄 </a></div>






<div class="yuyilu-grades collapsed" id="yuyilu-grades">
<div class="node level-3"><a href="https://kenchan20141.github.io/f1chinese/" data-tool-id="yuyilu-f1">中一</a> | <a href="https://kenchan20141.github.io/chinese2/" data-tool-id="yuyilu-f2">中二</a> | <a href="https://kenchan20141.github.io/chinese3/" data-tool-id="yuyilu-f3">中三</a></div>
<div class="node level-3"><a href="https://kenchan20141.github.io/f4chinese/" data-tool-id="yuyilu-f4">中四</a> | <a href="https://kenchan20141.github.io/chinese/" data-tool-id="yuyilu-f5">中五</a> | <a href="https://kenchan20141.github.io/chinese6/" data-tool-id="yuyilu-f6">中六</a></div>
</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/timer/" data-tool-id="timer">背書神器</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">文言文</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/mensyu/" data-tool-id="mensyu-2">文樞</a></div>
</div>
</div>

<!-- 4. Assignments -->
<div class="category" id="assignments" data-connect-to="core-ai-node">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-work"></use></svg>工具</div>
<div class="sub-group">
<div class="sub-group-title">課業流程</div>
<div class="node level-2"><a href="https://script.google.com/a/macros/ccckyc.edu.hk/s/AKfycby1T18HxuFICIaR0LYWRuaqlpmglkL191bVl39MH69zj5CQ-uhozF17edtJ_T54NhZ5/exec" data-tool-id="zhiyun">帙雲</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">實用工具</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/WCT/" data-tool-id="zhuoyu">琢玉</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/quizbuzzer/" data-tool-id="quizbuzzer">搶答器</a></div>
	<div class="node level-2"><a href="https://kenchan20141.github.io/pulseqa/" data-tool-id="pulseqa">脈問堂</a></div>
<div class="node level-2"><a href="https://www.i2ocr.com/free-online-chinese-traditional-ocr" data-tool-id="ocr">手寫文字轉換 (OCR)</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/epub/" data-tool-id="epub">電子書閱讀器</a></div>
	<div class="node level-2"><a href="https://kenchan20141.github.io/decibelmeter/" data-tool-id="decibelmeter">分貝計</a></div>
	<div class="node level-2"><a href="https://penpalchi.vercel.app/" data-tool-id="friends">以文會友</a></div>
</div>
</div>

<!-- 5. Support -->
<div class="category" id="support" data-connect-to="core-ai-node">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-support"></use></svg>學習支援</div>
<div class="sub-group">
<div class="sub-group-title">AI聊天室</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/chitutor/" data-tool-id="chitutor">喻蛋教室</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/histutor/" data-tool-id="histutor">史萊姆教室</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/counseling/" data-tool-id="counseling">解憂雜貨店</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">資源庫</div>
<div class="node level-2"><a href="https://621d05f47d591.site123.me/" data-tool-id="self-learning">自學資源</a></div>
</div>
</div>
</main>
</div>
</div>

<!-- Preview Modal (修訂後) -->
<div id="previewModal" class="preview-modal-overlay">
<div class="preview-modal-content">
<div class="preview-modal-body">
<iframe id="previewIframe" src="" frameborder="0" credentialless></iframe>
<div class="preview-modal-footer">
<div id="previewDescription" class="preview-description"></div>
<a id="previewGoToPageBtn" href="" target="_blank" class="preview-goto-btn">前往</a>
</div>
</div>
<button id="previewCloseBtn" class="preview-close-btn" title="關閉">&times;</button>
</div>
</div>


<!-- Video Modal (新增) -->
<div id="videoModal" class="video-modal-overlay">
<div class="video-modal-content">
<iframe id="videoIframe" allow="fullscreen" allowfullscreen src="" width="100%" style="border:none;" credentialless></iframe>
</div>
</div>

<script>


// === 監聽未繳交功課並控制紅點 (核心邏輯) ===
let pendingMonitorRef = null; // 用於儲存監聽器，方便登出時移除

function monitorPendingAssignments() {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    const badge = document.getElementById('notifBadge');
    
    // 如果沒有登入資料或找不到紅點元素，直接退出
    if (!s || !badge) return;

    // 如果之前有監聽器，先移除，避免重複疊加
    if (pendingMonitorRef) {
        pendingMonitorRef.off();
    }

    // 設定監聽路徑：該年級班別的所有功課
    pendingMonitorRef = database.ref(`assignments/${s.grade}/${s.class}`);

    pendingMonitorRef.on('value', async (snapshot) => {
        const assignments = snapshot.val();
        
        // 如果老師根本沒派發過功課，隱藏紅點
        if (!assignments) {
            badge.style.display = 'none';
            return;
        }

        const assignmentKeys = Object.keys(assignments);
        let hasPending = false;

        // 使用 Promise.all 並行檢查每一份功課的繳交狀態
        const checkPromises = assignmentKeys.map(async (key) => {
            // 檢查 assignments_submissions 路徑下是否有該學生的紀錄
            const subSnap = await database.ref(`assignments_submissions/${key}/${s.name}`).once('value');
            
            // 如果 subSnap.exists() 為 false，代表還沒交
            return subSnap.exists(); 
        });

        const results = await Promise.all(checkPromises);

        // 檢查結果：只要結果陣列中有任何一個 false (未交)，就標記為有待辦
        if (results.includes(false)) {
            hasPending = true;
        }

        // 更新 UI
        if (hasPending) {
            badge.style.display = 'block';
            badge.title = "您有未繳交的課業！"; // 滑鼠懸停提示
        } else {
            badge.style.display = 'none';
        }
    });
}
	

// --- 【全新修訂】儲存頁面為 HTML 的功能 (已整合雷達圖轉換) ---
function savePageAsHTML(filename = '神思-存檔.html') {
    // 1. 建立當前文檔的深度複製品，我們將在這個複製品上操作
    const clonedDocElement = document.documentElement.cloneNode(true);

    // --- 【核心新增邏輯：處理雷達圖】 ---
    // a. 找出當前頁面上所有可見的雷達圖畫布 (canvas)
    const visibleCanvases = document.querySelectorAll('.radar-chart-container canvas');
    
    visibleCanvases.forEach(originalCanvas => {
        // b. 檢查畫布是否真的可見，避免處理隱藏的圖表
        if (originalCanvas.offsetParent !== null) {
            try {
                // c. 將畫布內容轉換為 Base64 格式的圖片數據 (PNG)
                const imageDataUrl = originalCanvas.toDataURL('image/png');
                
                // d. 在 "複製品" 中找到對應的畫布
                const clonedCanvas = clonedDocElement.querySelector(`#${originalCanvas.id}`);
                
                if (clonedCanvas) {
                    // e. 建立一個新的 <img> 元素
                    const img = document.createElement('img');
                    img.src = imageDataUrl; // 將圖片數據設置為來源
                    img.style.width = '100%'; // 保持與原畫布容器寬度一致
                    img.style.height = 'auto'; // 高度自動調整
                    
                    // f. 在複製品中，用這張靜態圖片 <img> 取代原本的 <canvas>
                    clonedCanvas.parentNode.replaceChild(img, clonedCanvas);
                }
            } catch (e) {
                console.error('轉換雷達圖為圖片時發生錯誤:', e);
            }
        }
    });
    // --- 【雷達圖處理邏輯結束】 ---

    // 2. 在複製品上同步所有表單元素的當前狀態 (此部分邏輯不變)
    const originalTextareas = document.getElementsByTagName('textarea');
    const clonedTextareas = clonedDocElement.getElementsByTagName('textarea');
    for (let i = 0; i < originalTextareas.length; i++) {
        clonedTextareas[i].textContent = originalTextareas[i].value;
    }

    const originalInputs = document.querySelectorAll('input');
    const clonedInputs = clonedDocElement.querySelectorAll('input');
    for (let i = 0; i < originalInputs.length; i++) {
        clonedInputs[i].setAttribute('value', originalInputs[i].value);
        if (originalInputs[i].type === 'radio' || originalInputs[i].type === 'checkbox') {
             if (originalInputs[i].checked) {
                clonedInputs[i].setAttribute('checked', 'checked');
            } else {
                clonedInputs[i].removeAttribute('checked');
            }
        }
    }

    const originalSelects = document.getElementsByTagName('select');
    const clonedSelects = clonedDocElement.getElementsByTagName('select');
    for (let i = 0; i < originalSelects.length; i++) {
        const selectedIndex = originalSelects[i].selectedIndex;
        if (selectedIndex > -1) {
            Array.from(clonedSelects[i].options).forEach(opt => opt.removeAttribute('selected'));
            clonedSelects[i].options[selectedIndex].setAttribute('selected', 'selected');
        }
    }

    // 3. 在複製品中移除所有「儲存HTML」按鈕及其他不需保存的互動按鈕
    const clonedSaveButtons = clonedDocElement.querySelectorAll('.btn-save-html');
    clonedSaveButtons.forEach(btn => btn.remove());
    
    const clonedShowPlayerBtn = clonedDocElement.querySelector('#show-player');
    if (clonedShowPlayerBtn) clonedShowPlayerBtn.remove();
    
    const clonedExpandToolsBtn2 = clonedDocElement.querySelector('#expandToolsBtn2');
    if (clonedExpandToolsBtn2) clonedExpandToolsBtn2.remove();


    // 4. 生成完整的 HTML 字串
    const finalHtml = '<!DOCTYPE html>\n' + clonedDocElement.outerHTML;

    // 5. 創建 Blob 並觸發下載
    const blob = new Blob([finalHtml], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// --- 【新增】隱藏所有「儲存HTML」按鈕的專用函式 ---
function hideAllSaveHtmlButtons() {
    const saveButtons = document.querySelectorAll('.btn-save-html');
    saveButtons.forEach(button => {
        button.style.display = 'none';
    });
}

// 【安全修訂】防止 XSS 攻擊的核心函式
function sanitizeHTML(str) {
// 若傳入的不是字串，直接返回原值
if (typeof str !== 'string') return str;
// 將特殊字元轉換為 HTML 實體
return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// 【核心修訂】建立一個清除所有題目狀態的專用函式
function clearAllTopicStates() {
// 1. 清除所有題目顯示區塊的內容並隱藏它們
document.getElementById('topicResult').innerHTML = '';
document.getElementById('topicResult').style.display = 'none';
document.getElementById('argumentTopicResult').innerHTML = '';
document.getElementById('argumentTopicResult').style.display = 'none';
document.getElementById('expandTopicResult').innerHTML = '';
document.getElementById('expandTopicResult').style.display = 'none';

// 2. 清除所有儲存在 localStorage 的題目相關資料
// 「敘事抒情」相關
localStorage.removeItem("currentTopic");
localStorage.removeItem("currentFocus");
localStorage.removeItem("currentPlot");
localStorage.removeItem("lastTopic");

// 「議論」相關
localStorage.removeItem("argumentCurrentTopic");
localStorage.removeItem("lastArgumentTopic");

// 「整合拓展」相關
localStorage.removeItem("expandCurrentTitle");
localStorage.removeItem("expandCurrentTheme");
localStorage.removeItem("expandCurrentData");

// 3. 清除自訂題目的輸入區
const customTopicArea = document.getElementById("customTopicArea");
if (customTopicArea) {
customTopicArea.innerHTML = '';
customTopicArea.style.display = 'none';
}
const argumentCustomTopicArea = document.getElementById("argumentCustomTopicArea");
if (argumentCustomTopicArea) {
argumentCustomTopicArea.innerHTML = '';
argumentCustomTopicArea.style.display = 'none';
}
}



/**
* 更新按鈕的 활성화 (active) 狀態。
* @param {HTMLElement} clickedButton - 被點擊的按鈕元素。
*/
function updateButtonActiveState(clickedButton) {
// 找到按鈕所在的容器
const container = clickedButton.closest('.topic-buttons-container');
if (!container) return;

// 獲取容器內的所有按鈕
const buttons = container.querySelectorAll('.btn');

// 首先，移除所有按鈕的 'active' class
buttons.forEach(button => {
button.classList.remove('active');
});

// 然後，只為被點擊的按鈕添加 'active' class
clickedButton.classList.add('active');
}


// API 配置信息
const API_KEYS = [
   "pk_D77NeM4n6GnNCYbo",
"pk_c17y17tQ3BY71cpd",
"pk_Ax3rRTHkrdTQVIGD",
"pk_dGVqEggn4T4dwQI3",
"pk_YIFWnDFts0quviE0"
];
// let currentApiKeyIndex = 0; // 這個變數不再需要，可以刪除或註解掉
const API_URL = "https://gen.pollinations.ai/v1/chat/completions";
const MODEL = "gemini";


// [新增] 閱讀專用 API 配置
const READING_API_KEYS = [
   "pk_D77NeM4n6GnNCYbo",
"pk_c17y17tQ3BY71cpd",
"pk_Ax3rRTHkrdTQVIGD",
"pk_dGVqEggn4T4dwQI3",
"pk_YIFWnDFts0quviE0"
];
// let currentReadingApiKeyIndex = 0; // 這個變數不再需要，可以刪除或註解掉
const READING_API_URL = "https://gen.pollinations.ai/v1/chat/completions";
const READING_MODEL = "deepseek";


// =======================================================
// === [新增] 畫布聊天室核心邏輯 ===
// =======================================================

let canvasChatHistory = []; 
let currentContextType = ""; 
let currentContextContent = ""; 
let currentContextReview = ""; 

function getCanvasChatHTML(type) {
    currentContextType = type;
    canvasChatHistory = []; 
    return `
    <div class="canvas-chat-container">
        <div class="canvas-chat-header">
            <i class="fas fa-comments"></i> 閱卷員追問區
        </div>
        <div class="canvas-chat-history" id="canvasChatHistoryBox">
            <div class="message-bubble ai-message">你好！對於剛才的點評或改寫，有甚麼想進一步了解的嗎？歡迎追問！😊</div>
        </div>
        <div class="canvas-input-area">
            <textarea id="canvasChatInput" class="no-modal-editor" placeholder="在此輸入你的問題... (例如：為何這裡要這樣改？)"></textarea>
            <button id="canvasChatSendBtn" class="canvas-send-btn" onclick="sendCanvasMessage()" title="發送">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>`;
}

async function sendCanvasMessage() {
    const inputEl = document.getElementById("canvasChatInput");
    const historyBox = document.getElementById("canvasChatHistoryBox");
    const sendBtn = document.getElementById("canvasChatSendBtn");
    
    const userText = sanitizeHTML(inputEl.value.trim());
    if (!userText) return;

    // 1. 顯示用戶訊息
    const userBubble = document.createElement("div");
    userBubble.className = "message-bubble user-message";
    userBubble.innerHTML = userText.replace(/\n/g, '<br>');
    historyBox.appendChild(userBubble);
    
    inputEl.value = "";
    sendBtn.disabled = true;
    historyBox.scrollTop = historyBox.scrollHeight;

    // 2. 顯示 AI 思考中
    const aiBubble = document.createElement("div");
    aiBubble.className = "message-bubble ai-message";
    aiBubble.innerHTML = `<i class="fas fa-spinner fa-spin"></i> 正在思考...`;
    historyBox.appendChild(aiBubble);
    historyBox.scrollTop = historyBox.scrollHeight;

    const historyText = canvasChatHistory.map(h => `${h.role}: ${h.content}`).join("\n");
    
    let toneNote = "請用日常、親切的語氣回應，多用例子說明。";
    let activeReviewer = "中文老師";
    
    // === 設定語氣與閱卷員 ===
    // 檢查是否有陳SIR語氣設定
    const toneEls = [
        document.getElementById("writingTone"), 
        document.getElementById("readingTone"), 
        document.getElementById("expandTone"), 
        document.getElementById("argumentWritingTone"),
        document.getElementById("argumentOutlineTone")
    ];
    
    for (let el of toneEls) {
        if (el && el.offsetParent !== null && el.value === "chen") { // 檢查是否顯示且值為 chen
            toneNote = "你現在是陳SIR。請用幽默詼諧、適時揶揄的語氣回應，**必須使用大量Emoji** 🤪✨，表示揶揄時會用🤌這個EMOJI，偶爾用網絡用語。";
            activeReviewer = "陳SIR";
            break;
        }
    }

    // === 構建 Prompt 上下文 ===
    let promptContext = "";
    
    switch (currentContextType) {
        case 'narrative_writing':
        case 'argument_writing':
        case 'narrative_outline':
        case 'argument_outline':
        case 'expand_comment':
        case 'reading_comment':
            promptContext = `
            【背景資料】
            學生提交了一份作業，你已經給出了點評/改寫。
            學生的內容/原文：
            ${currentContextContent}
            ---
            你的點評/改寫內容：
            ${currentContextReview}
            ---
            【任務】
            請針對學生的問題進行回應，解釋你的點評理據，或提供更多寫作建議。`;
            break;

        case 'narrative_guide':
        case 'argument_guide':
        case 'expand_guide':
        case 'reading_guide':
            promptContext = `
            【背景資料】
            你剛剛為學生提供了寫作/答題指引。
            題目/輸入資料：
            ${currentContextContent}
            ---
            你生成的指引內容：
            ${currentContextReview}
            ---
            【任務】
            請引導學生如何利用這些指引來完成寫作或回答問題，激發他的靈感。`;
            break;

        case 'narrative_elements':
            promptContext = `
            【背景資料】
            你剛剛為學生生成了一系列「敘事物象」。
            題目與背景：
            ${currentContextContent}
            ---
            你生成的物象列表：
            ${currentContextReview}
            ---
            【任務】
            學生可能會問如何運用某個物象。請教導他如何將這些物象融入故事中，營造意境或推動情節。`;
            break;

        default:
            promptContext = `【背景資料】正在進行中文科學習討論。`;
    }

    const fullPrompt = `
    你是一位${activeReviewer}。
    ${promptContext}
    
    【對話紀錄】
    ${historyText}
    【學生最新問題】
    ${userText}

    1. 解釋要具體，不要空泛，最好舉例說明。
    2. 語氣要求：${toneNote}
    3. 字數控制在 200 字以內。
    `;

    try {
        const response = await callReadingAPI(fullPrompt);
        let formattedResponse = response.replace(/\n/g, '<br>');
        formattedResponse = formattedResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        aiBubble.innerHTML = formattedResponse;
        canvasChatHistory.push({ role: "Student", content: userText });
        canvasChatHistory.push({ role: "Teacher", content: response });
    } catch (error) {
        aiBubble.innerHTML = "抱歉，連線發生錯誤，請重試。";
        console.error(error);
    } finally {
        sendBtn.disabled = false;
        historyBox.scrollTop = historyBox.scrollHeight;
    }
}




	

// ======= 請在這裡加入以下程式碼 =======
const narrativeReviewerPreferences = {
    'chen_sir': '評分取向 (敘事抒情)：對扣題要求尚算嚴謹。極度看重「立意」、「取材」、「詳略」和「文學性」。多用修辭不一定是高分因素，更看重文句是否自然、有留白空間。',
    'deng_laoshi': '評分取向 (敘事抒情)：對扣題要求極為嚴苛。優先檢查是否有明確的「扣題小段」及「立意段」。情節的選取及詳略剪裁是否極度貼合題目是評分的最重核心。',
    'xiao_laoshi': '評分取向 (敘事抒情)：對扣題及結構要求比較嚴謹。不強求題材特別，但極度看重文章的「詞彙」是否豐富多變。',
    'huang_laoshi': '評分取向 (敘事抒情)：平衡看待所有標準。特別傾向於喜歡「立意」中有「真善美」思想情感的文章，若能體現此點，可在「立意」分數上給予正面考慮。',
    'dong_laoshi': '評分取向 (敘事抒情)：較平衡看待標準，但對「詳略」安排有特別高的要求。會仔細審視故事的敘事節奏，核心情節是否得到充分的細節描寫。',
    'li_laoshi': '評分取向 (敘事抒情)：對多用修辭、文句華美的文章特別有好感，這將直接影響「文學性」和「表達」的總分。對題材沒有特別要求。',
    'zhen_laoshi': '評分取向 (敘事抒情)：對扣題要求比較嚴謹。同時，對多用修辭的文章特別有好感。並且非常看重文章的「詳略」及「結構」。',
    'wen_laoshi': '評分取向 (敘事抒情)：綜合要求高。傾向喜歡「立意」有真善美、「表達」多用修辭、「詞彙」豐富的文章。同時對「扣題」及「詳略」都有較高要求。',
    'ms_chan': '評分取向 (敘事抒情)：對多用修辭的文章特別有好感。喜歡「特別的題材」，若取材新穎，可在「取材」分數上給予加分。非常看重文章是否有明確的「扣題小段」。',
    'jiang_laoshi': '評分取向 (敘事抒情)：對扣題比較嚴謹。要求多用修辭及詞匯豐富。特別喜歡文章對某些關鍵「畫面」有詳細的特寫刻劃，這會影響「取材」和「詳略」分數。立意段要清晰具體。對取材的新穎度也有一定要求。'
};

const argumentReviewerPreferences = {
    'chen_sir': '評分取向 (議論)：對論點是否緊扣題目要求嚴謹，要求學生多角度切入一個論題，會看重學生是否能舉例古今中外的論據。極度看重「立意」（論點的深度與層次）與「取材」（論據的恰當性與說服力）。要求文句具有文學性，較少運用虛詞。',
    'deng_laoshi': '評分取向 (議論)：對扣題（論點與題目的對應）要求極為嚴苛，要求學生運用豐富的論據。會優先檢查每段的「主題句」是否清晰回應題目，論證過程是否緊密圍繞主題句展開。「扣題」是決定整體分數的最關鍵因素。',
    'xiao_laoshi': '評分取向 (議論)：對扣題要求比較嚴謹。若文中有駁論，是一個加分項。要求論據豐富。極度看重論述用詞的「準確性」和「豐富性」。',
    'huang_laoshi': '評分取向 (議論)：平衡看待所有標準，不要求論點獨特，但論據要充實，論證要完整。',
    'dong_laoshi': '評分取向 (議論)：較平衡看待標準，但對「詳略」有特別要求，即論證核心部分是否詳盡，非核心論據是否能做到點到即止。',
    'li_laoshi': '評分取向 (議論)：對善用排比、對偶、引用等修辭來增強論證氣勢的文章特別有好感，這會直接提高「表達」分數。',
    'zhen_laoshi': '評分取向 (議論)：對扣題要求比較嚴謹。同時，也看重文章是否善用修辭增強說服力。對文章的整體「結構」，如起承轉合、駁論立論的安排，有較高要求。',
    'wen_laoshi': '評分取向 (議論)：綜合要求高。喜歡「詞彙」豐富準確的文章。對「扣題」及論證的「詳略」都有較高要求。',
    'ms_chan': '評分取向 (議論)：對善用修辭（如引用、設問）的文章特別有好感。喜歡看到「新穎的論據或角度」，若取材獨特，可在「取材」上加分。看重分論點是否清晰（相當於扣題小段）。要求論據獨特新穎。',
    'jiang_laoshi': '評分取向 (議論)：對扣題比較嚴謹。要求善用修辭且詞彙豐富。特別喜歡看到論證過程中，能將抽象道理與「具體生活場景」結合描寫，使論證更形象化。要求文章的「立場須清晰、明確」。對論據的新穎性有一定要求。'
};
// ======= 加入結束 =======



// [新增] 閱讀專用 API 呼叫函式 (加入 50 秒超時)
async function callReadingAPI(prompt, temperature = null) {
	 // ★★★ 新增：額度檢查 ★★★
    if (!checkGuestUsage()) {
        throw new Error("Guest usage limit exceeded");
    }
    let attempts = 0;
    const maxAttempts = READING_API_KEYS.length;
    // 每次調用都從一個隨機的索引開始
    let currentApiKeyIndex = Math.floor(Math.random() * READING_API_KEYS.length);
    const TIMEOUT_MS = 100000; // 設定 50 秒超時

    while (attempts < maxAttempts) {
        // 定義超時控制器
        const controller = new AbortController();
		globalAbortController = controller; // ★★★ 加入這一行：綁定全域控制器
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

        try {
            const requestBody = {
                model: READING_MODEL,
                messages: [{
                    role: "user",
                    content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
                }],
                max_tokens: 15000
            };

            if (temperature !== null) {
                requestBody.temperature = temperature;
            }

            const response = await fetch(READING_API_URL, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${READING_API_KEYS[currentApiKeyIndex]}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody),
                signal: controller.signal // 綁定中斷訊號
            });

            clearTimeout(timeoutId); // 成功收到回應，清除計時器

            if (response.status === 429) {
                console.warn(`閱讀 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
                currentApiKeyIndex = (currentApiKeyIndex + 1) % READING_API_KEYS.length;
                attempts++;
                continue;
            }

            if (!response.ok) {
                throw new Error(`API 調用失敗: ${response.statusText}`);
            }

            const data = await response.json();
            let content = data.choices[0].message.content.trim();
            content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

            if (!content) {
                throw new Error("API 回應無效或過濾後無內容");
            }

            return content;

        } catch (error) {
            // 清除計時器以防萬一
            clearTimeout(timeoutId);

            console.error(`使用閱讀 API Key ${currentApiKeyIndex} 時出錯 (嘗試 ${attempts + 1}/${maxAttempts}):`, error);
            
            // 無論是網絡錯誤、API錯誤還是超時(AbortError)，都切換下一個 Key
            currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
            attempts++;
            
            if (attempts >= maxAttempts) {
                // ★★★ 新增這一行：觸發失敗計數與檢查 ★★★
                trackApiCycleFailure(); 
                
                throw new Error("所有 API 密鑰均無法使用或連線超時");
            }
        }
    }
}



/* --------------------------------------
   音樂播放器 JS (無懸浮按鈕版)
   -------------------------------------- */
const audio = document.getElementById('audio');
const playPauseBtn = document.getElementById('play-pause');
const musicSelect = document.getElementById('music-select');
const progressBarMusic = document.getElementById('progress-bar-music');
const playMode = document.getElementById('play-mode');
const hidePlayerBtn = document.getElementById('hide-player');
const musicPlayer = document.getElementById('music-player');

let isPlaying = false;
let currentMusic = '';

// 音樂選擇
musicSelect.addEventListener('change', function() {
    const selectedMusic = this.value;
    if (selectedMusic) {
        audio.src = selectedMusic;
        audio.load();
        currentMusic = selectedMusic;
        audio.play().then(() => {
            isPlaying = true;
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        }).catch(error => console.error('自動播放失敗:', error));
    }
});

// 確保可以播放時自動播放
audio.addEventListener('canplay', function() {
    if (isPlaying) audio.play();
});

// 播放/暫停按鈕點擊
playPauseBtn.addEventListener('click', function() {
    if (isPlaying) {
        audio.pause();
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    } else {
        if (currentMusic) {
            audio.play();
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        } else {
            alert('請先選擇音樂');
        }
    }
    isPlaying = !isPlaying;
});

// 進度條更新
audio.addEventListener('timeupdate', function() {
    if (!audio.duration) return;
    const progress = (audio.currentTime / audio.duration) * 100;
    progressBarMusic.value = progress;
});

progressBarMusic.addEventListener('input', function() {
    const time = (this.value / 100) * audio.duration;
    audio.currentTime = time;
});

// 自動播放下一首邏輯
audio.addEventListener('ended', function() {
    if (playMode.value === 'loop') {
        audio.currentTime = 0;
        audio.play();
    } else if (playMode.value === 'next') {
        const options = musicSelect.options;
        for (let i = 0; i < options.length; i++) {
            if (options[i].value === currentMusic) {
                let nextIndex = (i + 1) % options.length;
                if (nextIndex === 0) nextIndex = 1;
                currentMusic = options[nextIndex].value;
                musicSelect.value = currentMusic;
                audio.src = currentMusic;
                audio.load();
                audio.play();
                break;
            }
        }
    }
});

// 隱藏播放器 (這會直接把播放器關掉，不再顯示懸浮按鈕)
hidePlayerBtn.addEventListener('click', function() {
    musicPlayer.style.display = 'none';
});

// 注意：打開播放器的功能現在完全由側邊選單的 toggleMusicPlayer() 負責

// 預設寫作題目列表
const topics = [
"旁觀", "舞台", "這件物件很是輕巧，卻讓我明白『但求無愧於心』的道理。", "山頂", "種子", "根", "疤痕",
"今天，我不能參賽，只能坐在觀眾席上，但當時的所見所聞卻給予我嶄新的體會。", "從今以後，我不會再輕言放棄。",
"等候", "我曾經努力嘗試，但最終仍是事與願違", "回憶", "徹夜難眠", "彩虹",
"星空下，眼前的景象讓我想起那段往事，令我不禁歎了一口氣……", "路牌", "今學年最後悔的一件事",
"最令我感動的一句話", "再試一次", "今天再次在台上演奏，我已經脫胎換骨，不再是從前那個驕傲自滿的我了。",
"每次經過這條街，看着街上的景物，我便感觸不已……", "意外", "鑰匙", "錯過了的機會",
"那句話，我實在不該說……", "色彩", "煙火", "藥", "放下", "追逐", "原來，這只是一場誤會",
"缺憾", "無悔的抉擇", "勇氣", "傘", "自此之後，我明白到原來父母的愛總是體現在小事上。",
"一件令我後悔不已的事", "一次尷尬的經歷", "沿途有你", "這一次，我實在感到無地自容。",
"這一次，我明白到，原來幫助他人的同時，也幫助了自己。",
"我的鄰居張先生是一位很苛刻的人，經常會為些『小事』而投訴他人。但今天我發現，他這樣做是有原因的……",
"獨處的一天", "這一刻，我終於舒了一口氣。", "記一次被誤解的經歷", "一次與別人言歸于好的經歷",
"自此之後，我感到自己真的長大了。", "自此之後，我明白到幸福原來可以很簡單。", "記一次苦盡甘來的經歷。",
"這件事讓我體會到喜出望外的滋味。", "路標", "足印", "遺憾", "鎖", "面具", "心結", "門",
"影子", "禁區", "等待", "根", "最後，我選擇了放棄", "自那一刻，我解開了心結",
"自此之後，我明白猶豫會使人一事無成。", "原來我沒有忘記那一頓飯。", "我在大自然之中找到快樂。",
"熱鬧過後，我卻感到失落。", "看著逐漸遠去的背影，我感到很內疚。", "今天我流淚了，但我並非感到難過。",
"自此之後，我找到了動力", "經歷了這次風波，我長大了。",
"經過這件事，我才明白到一心是我的知己，是真正了解我的人。", "自此之後，我學會放下無謂的面子。",
"這一次，我再沒有遺憾", "重遊舊地所見有感", "失而復得", "這條街雖然老舊，但卻充滿人情味。",
"這句話，我會記上一輩子。", "門", "來日方長", "得不償失", "隱藏", "微笑以對",
"熱鬧過後，我卻感到失落。", "夢想看似不切實際，但其實很有意義", "夢想看似很有意義，其實不切實際",
"今天我沒有帶手提電話外出，因而有不一樣的經歷和體會。",
"今天發生了一件事情，當時我曾經想力陳己見，最後選擇了沉默。我認為沉默是必要的。",
"矛盾", "未兌現的諾言", "未寄出的信", "距離", "一場沒有失敗者的比賽", "一件發人深省的事",
"我最想保留的一本相簿", "我最想尋回的一件玩具", "無愧的抉擇", "不能掉下的眼淚", "無畏的探索",
"一次令我百感交集的聚餐", "如願以償"
];

// 預設議論題目列表（請在此處輸入您的題庫）
const argumentTopics = [
'所謂「天行有常，立身有本。」意思是大自然運行有既定的規律，人立身處世有一定的原則。試談談你對「立身有本」的看法。',
'旁觀',
'有人認為「人生在世，必須講究儀式。」你同意嗎？試撰文一篇，論述你的看法。',
'舞台',
'根',
'古人說：「君子不以人廢言。」意思是：君子不會因為某人的德行不好而不採納他的善意規勸。在現今社會，你是否同意「君子不以人廢言」？試談談你的看法。',
'計算',
'有人說：「在現今社會中，我們難以活出真我。」你同意嗎。談談你的看法。',
'俗語說「有競爭才有進步」，也有人說「競爭無用」。試寫作文章一篇，談談你對「競爭無用」的看法。',
'山頂',
'「種子」雖是平常事物，卻可以引起聯想，或牽動思緒，又或啟發思考。試以「種子」為題，就個人體會寫作文章一篇。',
'有人認為「挫敗更有利孩子成長。」你同意嗎？試撰文一篇，論述你的看法。',
'疤痕',
'試以「談玩物喪志」或「談玩物養志」為題，寫作文章一篇。',
'泰然處之',
'古語有云「天下皆知取之為取，而莫知與之為取。」意思是世人都知道索取可以獲得，而不知道給予也可以獲得。試談談你對這句話的看法。',
'談嚴苛',
'談寬容',
'談憤怒',
'待候',
'有人認為：「與其追求成功，不如追求幸福。」你同意嗎？試撰寫文章一篇，論述你的看法。',
'矛盾',
'有人認為：「保持距離能令關係長久。」你同意嗎？試撰文一篇，論述你的看法。',
'有人說：「近朱者赤，近墨者黑。」你同意嗎？為甚麼？',
'試以「當科技文明消失後」為題，寫一篇評論，反思科技發展帶來的影響。',
'成功路上無捷徑，試談談你的看法。',
'個人電子產品的普及化，有人認為是生活的進步，有人認為是生活的倒退。你較認同哪一種觀點？試談談你的看法。',
'有人認為即使心中不快，亦要以笑面對人；有人認為應以真性情對人，不應掩飾心中的感受，你較贊同哪一方？試談談你的看法。',
'鑰匙',
'貧乏與富足',
'論意外',
'試談談你對「聽天由命」這種處世態度的看法。',
'「天賜食於鳥，卻不投食於巢。」上天賜予鳥類覓食的本能，而不把食物投到鳥巢。意思是人需要通過努力，才能有所得。你認同嗎?試談談你的看法。',
'色彩',
'談藝術的價值',
'藥',
'有人說：「每次付出應該先計算回報。」你同意這種處事態度嗎？',
'論公德心的重要性',
'有人認為中學生應多參與課外活動，發展興趣；有人則認為應專注學業，爭取好成績。你較認同哪種說法？試談談你的看法。',
'你同意「品德比學問更重要」嗎？試寫一篇議論文，談談你的看法。',
'談競爭',
'談缺憾',
'談得失',
'談勇氣',
'得不償失',
'爺爺：「我當鐘錶匠超過50年，畢生專注這門手藝，能做到分毫不差。」允行：「我是品味生活的咖啡師，亦是書寫人生的作家，更是培育後進的武術教練。」各人對人生有不同追求。有人認為：「與其一生專精一事，不如發展多元人生。」你同意嗎？試撰文一篇，論述你的看法。',
'微笑以對',
'有人認為「傳統往往是創新的包袱」。試談談你對這句話的看法。',
'足印',
'古人說：「獨學而無友，則孤陋而寡聞。」意思是獨自學習，沒有朋友互相切磋解難，人便會淺陋而見識不廣。在現今的學習生活中，你是否同意「獨學而無友，則孤陋而寡聞」？試試談你的看法。',
'「不做第一，也不做最後。」試談談你對這種處世態度的看法。',
'試以「陽光與陰影」為題，寫作一篇文章。',
'「孩子不是等待被填滿的瓶子，而是盼望化作燃燒的火焰。」試就個人對這句話的體會 ，以「成長」為題，寫作一篇文章。',
'「今早媽媽打掃的時候，瞄一瞄玻璃窗外鄰居晾曬的衣服，便批評道：『看，那新鄰居真馬虎！衣服還是污漬斑斑，洗得一點也不乾淨。』女兒聽後，一言不發，走到窗前仔細打量，隨即抹掉窗上的灰塵，說道：『這不就乾淨了嗎？』媽媽恍然大悟，不乾淨的不是別人的衣服，而是自己的窗子。」試就這個故事對你的啓發，寫作一篇文章，談談如何消除偏見。',
'「一個寒冷的冬天，幾隻刺蝟擠在一起取暖。由於牠們身上長滿了短刺，彼此戳痛了對方，所以不得不散開。可是，寒冷的天氣又驅使牠們擠在一起，同樣的事情重複發生，牠們終於明白；不要太近，也不要太遠，最好彼此保持一定的距離。」這個故事的道理仍然貫穿在我們的現實生活中，試就此寫一篇文章。',
'個人私隱比公眾知情權更重要，你同意嗎？談談你的看法。',
'香港是一個物質生活十分富庶的地方，可是在多個國際性的調查中，「快樂指數」的排名並不高。有人認為富庶的物質生活反令人難以快樂；也有人認為富庶的物質生活是快樂的基礎。這兩種看法，你比較認同哪一種？試談談你的看法。',
'面對不同意見，有人認為應據理力爭，堅守立場；有人認為應彼此包容，求同存異。上述兩種態度，哪一種較為理想？試談談你的看法。',
'有人認為父母教養子女，應該給予空間，讓子女自由發展；有人認為應該給予明確的指導，讓子女依從。上述教養子女的方法，哪一種較為理想？試談談你的看法。',
'有人說：「與其追隨潮流，不如展現個人風格。」你對這句話有什麼看法？',
'有人說：「棒下出孝子，嚴師出高徒。」也有人說：「獎賞是教育的恩物。」你對這兩種說法有什麼意見？',
'現今社會，許多人認為財富與社會地位成正比，財富愈多，社會地位愈高。你的看法如何？',
'有人認為讚賞是成功的最大推動力，你同意嗎？試作文一篇，談談你的看法。',
'有人說：「豐裕的物質生活就是最美好的生活。」你同意嗎？試談談你的看法。',
'獲取知識是通往成功的唯一途徑，你同意嗎？試談談你的看法。',
'談談青年人應如何克服困難',
'「律己以嚴，待人以寬。」談談你對這話的看法。',
'「成功是恆心的基石」談談你對這話的看法。',
'論「家有一老，如有一寶」',
'送禮之我見',
'鄉村發展為工業區，原來的天然景物受到破壞。有人說：「有破壞才有建設。」也有人說：「這種建設破壞了人們生活的情趣。」你的看法又怎樣？試說出你個人的意見。'
];

let lastTopic = localStorage.getItem("lastTopic") || "";
let lastArgumentTopic = localStorage.getItem("lastArgumentTopic") || "";

// 範疇定義
const categories = {
"片段描寫": {
commentNote: "必須用繁體字。針對題目及用家提供的寫作內容進行點評，需嚴謹分析文章是否在字面及邏輯上扣題!important，結合情節內容，評估文句是否具文學性（即具聯想空間、引人共鳴與細味）。扣題是基本要求，即使扣題高分，若立意與取材普通，分數不高。立意需深刻、不落俗套，具哲理或共鳴；取材需獨特、豐富且貼切，避免常見題材（如『考試不合格』、『溫習』，最高6分）。立意與取材需視刻劃是否細膩。若結構段重點或情節漏空，無需評論或提及。扣題要求：1. 必須嚴謹評估寫作內容是否在字面與邏輯上直接呼應題目!important，情節詳略剪裁突顯與題目及結構段重點的關係。2. 不可自行補足情節與題目的關係。若文中未明確點出關係，視為不扣題。3. 題目如《成長》，需在字面、邏輯及詳略上突出『成長』關係，文中宜多次提及『成長』或近義詞。若偏向其他主題（如《影子》），視為不扣題。4. 帶物象題目（如《種子》）需靈活處理，抓住物象特徵發揮，接受間接象徵式扣題，無需過分聚焦實物本身，並非一定要刻劃該實物，接受暗扣。5. 題目含多個關鍵詞時，優先抓住主要關鍵詞，次要關鍵詞可放輕。6. 只有帶物象題目（如《痕跡》）必須接受用象徵、比喻等間接扣題的高階寫作，當文章運用這種方法扣題，字面扣題的要求則可以放寬。!important。 7. 用語必須貼近生活，不要讓用家輕易知道你有固定的點評範疇。為了讓用家容易理解，不可提及字面、邏輯、立意、取材、密度、文學性、間接扣題等字眼，不要運用術語，點評時必須概括和歸納情節，再加分析。!important 點評結構（三部分，各自120字以內）：1. 點評：聚焦一至兩項關鍵問題，先評扣題及詳略剪裁是否適切，再評文句（示現敘事、文句密度）。若結構段重點或情節與題目關係薄弱，需明確指出。若扣題與剪裁均不當，無需詳評文句。若整體表現優秀，可適當稱讚，但扣題邏輯仍需嚴謹把關。2. 建議：針對點評中的問題提出具體改進建議。3. 改寫範例：若離題，改寫需包含扣題小段，直接呼應題目或結構段重點，不基於原文離題內容改寫，改寫範例不要超過150字。文句要求：1. 交替運用小物件、動作、對話及內心獨白，融情入景、融情入物。2. 提高文句密度（詞匯深、多變，物象豐富，實詞比例高，虛詞如『的』、『地』、『得』比例低），但避免過密（如連用小物件主語）。適時以人物為主語，加入虛詞或內心獨白調節節奏，張弛有度。3. 控制詳略節奏，詳寫與題目相關部分，略寫次要內容。文句密度為好文筆標準，需納入考量。其他：- 點評需精簡、一語中的，僅點出最關鍵的問題。"
},
"大綱": {
commentNote: "必須用繁體字。點評時，必須就上述生成的題目點評大綱內容是否扣題，假如大綱離題，範例便不必根據離題內容改寫。此外，點評應分為三個部份：點評、建議、改寫範例。在寫作大綱時，學生應展示他們組織思路和結構故事的能力。評分時，請注意大綱的邏輯性、條理性以及是否包含了故事的起承轉合或三線結構（即所謂「散敘」，有以下三點要注意：其一，三線的分類範疇相同；其二，三線或有層遞關係，或能從三個角度呈現同一個主題；其三，三線的情節發展不能過於相似；其四，所分之角度能突顯與主題相關的立意。「三線」例子如下：題目為「勇氣」，則可用「年少時的勇氣」為一線、「年青時的勇氣」為二線、「年老時的勇氣」為三線；又如以「重遊舊地所見有感」，則可用在故鄉的不同「地」所見作三線分類，例如老屋、後山等。必須確保每條線的「結構段重點」清晰點明三線的分類範疇、想突顯題目的甚麼要點、與題目如何扣連等，以及「合」能統攝總結全文立意）。要逐部分分析每個結構段與題目的關係有多大，並在點評中明確指出。此外，在「改寫後的大綱」,其「結構段重點」必須交代該部份與題目之間的邏輯關係，即怎樣做到扣題。此外，由於是應試文章，因此改寫後的大綱避免過份具理論哲學性及文學性，以至於脫離了現實和日常生活，亦圍繞人在經歷的情感和體悟設定，必須減少概念模糊的術語，例如「情感載體」及「時空的共創」，請用日常化用語描述。此外，「改寫後的大綱」不宜只圍繞一件事敘寫，這樣會容易寫得太抽象，應適時加插人物與人物之間的回憶或其他經歷，令文章看起來更具體實在。此外，大綱不是全篇文章，最重要的是在點評時分析其結構段及情節大要的思路是否扣緊題目，方向是否合理、正確。假如整體表現真的不錯，沒有大問題，在點評時稱讚即可，不必吹毛求疵地批評。"
},
"敘事物象": {
commentNote: "必須用繁體字。在「敘事物象」中，學生需要運用豐富的物象來增強故事的生動性和真實感。物象應與題目、取材和故事背景緊密相關，並且能夠有效地表達人物的情感和故事的主題。請確保生成的物象不重複，並且排版清晰易讀。此外，每個物象都必須由兩個字構成。"
},
"閱讀": {
commentNote: "必須用繁體字。點評時，需評估答題方向是否合理、文本依據是否充實具體、闡釋推論是否嚴謹、主題句是否清晰。文本依據應語譯、概括歸納而非直接引用原文，除非題目中有『摘錄』字眼。改寫範例應使答案更圓足，並且非常嚴謹地根據文本依據擬定及作推論，必須只圍繞一個觀點分析，但若學生答題方向錯誤，則不跟從錯誤方向改寫。在「改寫範例」前，加入答題步驟及思路，描述各部分方向，步驟因題制宜，可能包括【鋪墊】、【回應】、【文本依據】、【闡釋】，靈活運用。每個步驟以【步驟名】標題加分行內容呈現，排版整齊。表格中只包含文字和標點，不含『---』等符號。每個步驟之間要隔一空行。假如是4分或以上的題目，改寫範例必須具體和詳盡，要有180字或以上。",
guideNote: "必須用繁體字。輸出分為「### 答題指引」和「### 答題詞匯」兩部分。「答題指引」請生成三道問題，引導思考，每個問題佔一行。「答題詞匯」請生成十五個由兩個字構成的詞彙，每個詞彙佔一行。請確保所有內容都以純文字列表呈現，不要使用任何Markdown表格語法。"
},
"課外書籍": {
	
chatNote: "必須用繁體字，多用EMOJI，偶爾可以用一下網絡用語。【角色設定：幽默陳SIR】你現在是跟學生亦師亦友的角色。請用**極度活潑、親切、粵語口語**的語氣回應。**必須大量使用 Emoji** (如 😂, 🤔, 🔥, 👀)，語氣要像在咖啡廳跟朋友閒聊一樣輕鬆。可以適度使用網絡用語，不要說教，要展現你的幽默感。",
seriousChatNote: "必須用繁體字，用語貼近日常生活，回應不要理論化，不要用網絡用語，也不要用EMOJI。"
},
"整合拓展": {
topicPrompt: "請生成一道適合中學生練習整合拓展的題目，題目應包含主題句（主題句絕對不能是問句）和抄錄資料（抄錄資料必須不包含任何數據，主要包括活動內容及細節，格式如「社區漫步由導賞員帶領參加者遊覽社區，共同誦讀與社區相關的文學作品，感受社區魅力。」不得包含引號或人物對話，而且不得超過30字），並符合以下文類和取材範圍。文類：書信、評論、建議書、演講辭、報告、專題文章。取材範圍：例如「請隨機選擇一個主題，且該主題必須與以下列出的所有主題（運動、生涯規劃、責任、教育、文化、社會、歷史、地理、藝術、體育、法律、健康、心理、家庭、友誼、就業、經濟、生態、能源、資源、安全、網路、媒體、資訊、道德、誠信、公平、自由、權利、義務、隱私、禮儀、榜樣、創新、創業、消費、儲蓄、民族、語言、宗教、傳統、現代、城鄉、社區、公益、慈善、災害、醫療、疾病、飲食、旅遊、建築、娛樂、音樂、電影、文學、人口、性別、年齡、職業、學業、考試、升學、校園、師生、同學、課外、社團、競賽、志願、壓力、自律、時間、興趣、習慣、遊戲、睡眠、氣候、汙染、閱讀」，但出題請多元化一點，亦不要每次都是與好處相關的，否則用家多生成幾次，便會遇到類似的題目。要求：1. 主題句簡潔，20字以內。2. 抄錄資料為一段文字，不超過100字。3. 輸出格式為：主題句：...\n抄錄資料：...\n4. 內容簡潔明了，避免冗長。5. 題目多樣化，避免重複。",
commentNote: "必須用繁體字。點評時，需評估「整合拓展」是否能闡釋「抄錄資料」與「主題句」的邏輯關係。需判斷：1.「拓展」方向是否正確（即是否能論證主題句）；2.推論是否嚴謹；3.是否具體不空泛。「點評」時，若方向不正確，需指出並建議如何修訂，需指導緊扣主題句，亦須分析主題句和題目任務的關係是否緊密，例如題目任務為提出建議，但主題句焦點卻是描述問題，則屬於不妥當。「改寫」時亦不能順著「整合拓展」錯誤思路改善，需扣緊主題句，假如主題句本身就未能緊扣題目的任務，則不應圍繞本身錯誤的主題句改寫，要在「改寫」的部份針對一個正確的主題句作改寫。此外，改寫部份不宜分為太多角度論述，這樣會令闡釋較零散，須就最多2個角度深入分析、闡釋。改寫部份不得超過180字，且不得虛構資料，包括數據及調查，不要自擬「根據調查」之類，只可根據抄錄資料補充合理細節，「改寫」部份不要重複用家輸入的「抄錄資料」，會白白浪費空間。此外，「改寫」亦要嚴謹對應主題句及抄錄資料關係，例如主題句描述活動問題，則在「改寫」的部份不宜聚焦在改善措施，必須注意詳略、輕重，才能突顯主題句。此外，「改寫」亦要留意題目任務，不要在「改寫」時會順著用家詳略不當或錯誤的「整合拓展」思路改寫。此外，「改寫」部份不要太數據化，例如做計算及分析數據等，這部份最重要是交代事理的邏輯關係。點評分為三部分：### 點評、### 建議、### 改寫。改寫必須在160至180字以上。",
guideNote: "必須用繁體字。僅生成三道問題以引導用家思考如何根據表格資料做好整合拓展，問題應圍繞主題句和抄錄資料的邏輯關係，引導用家思考如何闡釋和拓展。請不要運用歐化句及詞匯，例如「關聯性」、「實效性」，這些字詞意義不明確，但用生活化一點、具體一點的字詞生成問題。輸出分為一個部分：### 指引問題。指引問題以問題形式呈現，每個問題佔一行。"
},
"議論": {
outlineCommentNote: "必須用繁體字。點評時，必須就上述生成或輸入的題目點評大綱內容是否扣題。必須從以下角度點評：1. 論點是否清晰明確，一語中的，能直接呼應題目；2. 議論的立意，是取決於觀點是否深入成熟；3. 議論的取材，是取決於論據是否充實，涵蓋古今中外，以及其論據是否適用於論述這道題目；4. 即使扣題分數很高，但立意和取材分數低，其「內容」和「結構」分為最高只能得5分；5. 用家提供的論據與論點是否密切相關；6. 段內論據的詳略有幾種模式：兩個詳的論據，或一詳數略，或數略，因應段落論述需要而定，以製造變化；7. 論證方向是否合理，能合理解釋論據與論點的關係；8. 全文脈絡是否分明。點評時要用日常生活化的語言，不要用術語去解釋、點評或給建議，一定要用日常生活的語言。即使運用「陳SIR語氣」，「改寫後的大綱」都必須正經嚴肅，不要運用EMOJI，但「改寫說明」可以維持本來的「陳SIR語氣」風格。此外，假如全文有六段或以上，則應在第二段或末二的段落做駁論，點評、建議及改寫後的大綱都要注意這點。此外，不要列點和運用「*」等符號，必須以段落和完整句子方式生成改寫後的大綱。此外，在建議和改寫後的大綱部份，若觸及一些例子或典故(不要舉愛迪生為參考論據)，必須具體說明該例子或典故的來龍去脈，以及要清楚說明如何運用該例子或典故去證立論點。此外，無論點評、建議或改寫後的大綱，用語都必須生活化，要摒棄過於抽象和理論的表達。此外，點評應分為三個部份：點評、建議、改寫範例。只選取最重要的一至兩點評論，應先聚焦在論點、論據和論證的質量，其次方為結構。點評內容要精簡、一語中的。若大綱離題，改寫後的大綱不必根據離題內容改寫。",

writingCommentNote: "必須用繁體字。點評時，必須就用家提供的內容去點評，不要捏造用家沒有輸入的內容作點評。須評估文章是否符合以下標準：1. 論點清晰明確，一語中的，能直接呼應題目；2. 議論的立意，是取決於觀點是否深入成熟；3. 議論的取材，是取決於論據是否充實，涵蓋古今中外，以及其論據是否適用於論述這道題目；4. 即使扣題分數很高，但立意和取材分數低，其「內容」和「結構」分為最高只能得5分；5. 論證嚴謹，能具體解釋論據與論點的關係；6. 注意文句密度及修辞運用。點評時要用日常生活化的語言，不要用術語去解釋、點評或給建議，一定要用日常生活的語言。點評分為三部分：### 點評、### 建議、### 改寫範例。即使運用「陳SIR語氣」，「改寫範例」都必須正經嚴肅地表述，不要運用EMOJI。「改寫範例」應以純段落方式表述，不要運用EMOJI，不要附有【原文段落】及【改寫段落】等標題。點評、建議及改寫都要在200字以內。",

guideNote: "必須用繁體字。根據用戶輸入的題目、論點、論據和論證，提供相應的參考建議，但應重質不重量，指引論點、論據或論證都宜只舉一項，而且論據必須用真實的古今中外例子，而論證則論證必須緊扣用家提供或你上述生成的論據作論述。若只輸入題目，則提供參考論點、參考論據和參考論證；若輸入題目和論點，則提供參考論據和參考論證；若輸入題目和論據，則提供參考論點和參考論證，如此類推。不要舉愛迪生為參考論據。參考論證不得少於150字。輸出分為相應部分：### 參考論點、### 參考論據、### 參考論證（視用戶輸入情況而定）。每部分以段落形式呈現。用語要日常生活化，不要用術語。"
}
};

// === 修訂：動漫卡片選擇邏輯 (包含音效) ===

// === 修訂：動漫卡片選擇邏輯 (包含音效 + 延遲動畫) ===

// 1. 選取所有新的卡片元素
const categoryCards = document.querySelectorAll('.anime-card');
const clickSound = document.getElementById('ui-click-sound');

// 2. 為每個卡片添加點擊事件
categoryCards.forEach(card => {
    card.addEventListener('click', function() {
        // A. 播放清脆音效
        if (clickSound) {
            clickSound.currentTime = 0; 
            clickSound.volume = 1.0;    
            clickSound.play().catch(e => console.log("音效播放被瀏覽器阻擋:", e));
        }

        // B. 立即添加視覺效果 (讓卡片變色/發光)
        // 先移除其他卡片的 active，避免多選視覺錯亂
        categoryCards.forEach(c => c.classList.remove('active'));
        this.classList.add('active');

        // C. 獲取目標 Container ID
        const containerId = this.id.replace('Btn', 'Container');
        
        // D. 【關鍵修改】設置延遲，讓動畫跑完 500ms 後才切換畫面
        setTimeout(() => {
            showContainer(containerId, this);
        }, 500); // 這裡設定 500 毫秒，你可以根據需要調整 (例如 300 或 800)
    });
});


// === 沉浸式場景設定 ===
const scenes = {
    'home': 'https://i.ibb.co/xtsrPW6M/image.png', // 原本的主頁背景
    'writingContainer': '範疇一.png', // 寫作：書桌與筆
    'readingContainer': '範疇二.png', // 閱讀：圖書館
    'argumentContainer': '範疇三.png', // 議論：法院/木槌
    'expandContainer': '範疇四.png', // 拓展：協作/網絡
    'booksContainer': '範疇五.png' // 書籍：舒適閱讀角
};

// === 更新版：進入功能容器 (含自動置頂) ===
// === 更新版：進入功能容器 (含自動置頂 + 隱藏歷史紀錄) ===
function showContainer(containerId, clickedButton) {
    hideAllSaveHtmlButtons(); 
    
    // 1. 切換背景圖片 (支援圖片或純色)
    const bg = scenes[containerId];
    if (bg) {
        if (bg.startsWith('#') || bg.startsWith('rgb')) {
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = bg;
        } else {
            document.body.style.backgroundImage = `url('${bg}')`;
            document.body.style.backgroundColor = ''; 
        }
    }

    // 2. 隱藏主選單元素
    document.querySelector('.title-container').style.display = 'none';
    document.getElementById('hitokoto-container').style.display = 'none';
    document.getElementById('mainMenuBox').style.display = 'none'; 
    document.getElementById('toolsBox').style.display = 'none';    
    
    // === 【新增】隱藏 DSE 倒數 ===
    const dseBox = document.getElementById('dse-countdown-box');
    if (dseBox) dseBox.style.display = 'none';
    // ===========================

    // 3. 修改這部分：隱藏左上角的圓形返回按鈕
    document.getElementById('homeBtn').style.display = 'none'; 
    document.getElementById('sideMenuHomeBtn').style.display = 'flex';

    // 4. 清除狀態與隱藏其他容器
    const allCards = document.querySelectorAll('.anime-card');
    allCards.forEach(card => card.classList.remove('active'));
    if (clickedButton) clickedButton.classList.add('active');

    clearAllTopicStates();

    const containers = ['writingContainer', 'readingContainer', 'booksContainer', 'expandContainer', 'argumentContainer'];
    containers.forEach(id => document.getElementById(id).style.display = "none");

    // ★★★ 新增：確保歷史紀錄隱藏 ★★★
    const historyContainer = document.getElementById('historyContainer');
    if (historyContainer) historyContainer.style.display = 'none';

    // 5. 強制滾動到頁面最頂端
    window.scrollTo({ top: 0, behavior: 'instant' });

    // 6. 顯示目標容器 (淡入動畫)
    const targetContainer = document.getElementById(containerId);
    if (targetContainer) {
        targetContainer.style.display = "block";
        targetContainer.style.opacity = '0';
        targetContainer.style.transform = 'translateY(20px)';
        
        // 觸發重繪 (Reflow) 確保 transition 生效
        void targetContainer.offsetWidth; 

        targetContainer.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
        targetContainer.style.opacity = '1';
        targetContainer.style.transform = 'translateY(0)';
    }

    // 7. 初始化特定功能
    if (containerId === "writingContainer") { toggleWritingType(); loadOutline(); }
    else if (containerId === "readingContainer") { toggleReadingFunction(); }
    else if (containerId === "expandContainer") { toggleExpandFunction(); }
    else if (containerId === "booksContainer") { loadBooksChat(); }
    else if (containerId === "argumentContainer") { toggleArgumentType(); }
}


// === 更新版：返回主頁函式 ===
function returnToHome() {
    // 1. 恢復主頁背景
    document.body.style.backgroundImage = `url('${scenes['home']}')`;

    // 2. 確保懸浮編輯視窗被關閉
    const outlineModal = document.getElementById('outline-editor-modal');
    if (outlineModal) {
        outlineModal.style.display = 'none';
    }
    if (typeof currentEditingElement !== 'undefined') {
        currentEditingElement = null;
    }

    // 3. ★★★ 關鍵修正：加入 'historyContainer' 到隱藏列表 ★★★
    const containers = ['writingContainer', 'readingContainer', 'booksContainer', 'expandContainer', 'argumentContainer', 'historyContainer'];
    containers.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = "none";
    });

    // 4. ★★★ 額外修正：強制關閉歷史詳情模態視窗 ★★★
    const historyModal = document.getElementById('historyModal');
    if (historyModal) {
        historyModal.style.display = 'none';
    }

    // 5. ★★★ 額外修正：重置歷史紀錄介面至第一層 (範疇選擇)，避免下次打開時停留在舊紀錄 ★★★
    const histL1 = document.getElementById('historyLevel1Wrapper');
    const histL2 = document.getElementById('historyLevel2');
    const histL3 = document.getElementById('historyLevel3');
    const histBread = document.getElementById('historyBreadcrumb');
    
    if (histL1) histL1.style.display = 'flex'; // 恢復顯示第一層
    if (histL2) histL2.style.display = 'none';
    if (histL3) histL3.style.display = 'none';
    if (histBread) histBread.style.display = 'none'; // 隱藏麵包屑

    // 6. 顯示主頁元素
    document.querySelector('.title-container').style.display = 'block';
    document.getElementById('hitokoto-container').style.display = 'block';
    document.getElementById('mainMenuBox').style.display = 'block';
    document.getElementById('toolsBox').style.display = 'block';

    // 7. 重新顯示 DSE 倒數
    const dseBox = document.getElementById('dse-countdown-box');
    if (dseBox) dseBox.style.display = 'flex';

    // 8. 隱藏返回按鈕
    document.getElementById('sideMenuHomeBtn').style.display = 'none';
    document.getElementById('homeBtn').style.display = 'none';

    // 9. 移除所有卡片 active 狀態
    document.querySelectorAll('.anime-card').forEach(card => card.classList.remove('active'));

    // 10. 強制隱藏「工具一覽」
    const toolsContainer2 = document.getElementById('toolsContainer2');
    if (toolsContainer2) {
        toolsContainer2.style.display = 'none';
        document.body.style.overflow = 'auto';
    }

    // 11. 收起側邊選單
    const sideMenu = document.getElementById('sideMenu');
    if (sideMenu && sideMenu.classList.contains('active')) {
        sideMenu.classList.remove('active');
        document.getElementById('sideMenuToggle').classList.remove('active');
    }

    // 12. 隱藏所有儲存按鈕
    hideAllSaveHtmlButtons();

    // 13. 強制滾動到頂部
    window.scrollTo({ top: 0, behavior: 'instant' });
    
    // 14. 確保舊版工具箱隱藏
    const toolsBox = document.getElementById('toolsBox');
    if (toolsBox) {
        toolsBox.style.display = 'none'; 
    }
}
// 新增此函式：用於顯示議論的自訂題目介面
// 新增此函式：用於顯示議論的自訂題目介面 (已修訂：加入 Toggle 開關邏輯)
function showArgumentCustomTopicInput(buttonElement) { 
    // --- 1. Toggle 邏輯 ---
    if (buttonElement && buttonElement.classList.contains('active')) {
        buttonElement.classList.remove('active');
        
        const customTopicArea = document.getElementById("argumentCustomTopicArea");
        customTopicArea.style.display = "none";
        customTopicArea.innerHTML = "";
        
        const topicResult = document.getElementById("argumentTopicResult");
        topicResult.style.display = "none";
        topicResult.innerHTML = "";
        
        localStorage.removeItem("argumentCurrentTopic");
        return;
    }

    // --- 2. 正常開啟邏輯 ---
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    const customTopicArea = document.getElementById("argumentCustomTopicArea");
    const topicResult = document.getElementById("argumentTopicResult");

    topicResult.innerHTML = "";
    topicResult.style.display = "none";
    localStorage.removeItem("argumentCurrentTopic");

    customTopicArea.innerHTML = `
    <input type="text" id="argumentCustomTopic" class="no-modal-editor" placeholder="請輸入自訂題目">
    <button class="btn-icon-confirm" onclick="setArgumentCustomTopic()" title="確認題目">
    <i class="fas fa-check"></i>
    </button>
    `;
    customTopicArea.style.display = "block";
}

// 切換寫作類型
function toggleWritingType() {
    hideAllSaveHtmlButtons();
    clearAllTopicStates();
    const writingType = document.getElementById("writingType").value;
    const contentContainer = document.getElementById("writingContentContainer");

    // 獲取所有相關區域
    const writingGuideArea = document.getElementById("writingGuideArea");
    const outlineStructureArea = document.getElementById("outlineStructureArea");
    const narrativeElementsArea = document.getElementById("narrativeElementsArea");
    const topicSelectionArea = document.getElementById("topicSelectionArea");
    const writingArea = document.getElementById("writingArea");
    const submitWritingBtn = document.getElementById("submitWritingBtn");

    // 重置狀態
    document.getElementById("writingGradingResult").innerHTML = "";
    document.getElementById("writingChatHistory").style.display = "none";

    if (writingType) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return;
    }

    // 預設隱藏所有特定區域
    writingGuideArea.style.display = "none";
    outlineStructureArea.style.display = "none";
    narrativeElementsArea.style.display = "none";
    topicSelectionArea.style.display = "none"; 
    writingArea.style.display = "none"; 

    if (writingType === "guide") {
        writingGuideArea.style.display = "block";
        // 解題指引不使用通用的寫作區域
    } 
    else if (writingType === "大綱") {
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        outlineStructureArea.style.display = "block";
        document.getElementById("outlineTableArea").style.display = "block";
        generateOutlineTable();
        loadOutline();
        
        document.getElementById("writingContent").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "block";
        document.getElementById("writingTone").style.display = "block";
        document.getElementById("outlineButtons").style.display = "flex"; 
        document.getElementById("writingReviewerLabel").style.display = "none";
        document.getElementById("writingReviewer").style.display = "none";
        document.getElementById("reviewScopeArea").style.display = "none";
        submitWritingBtn.style.display = "block";
    } 
    else if (writingType === "敘事物象") {
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        narrativeElementsArea.style.display = "block";
        
        document.getElementById("writingContent").style.display = "none";
        document.getElementById("outlineTableArea").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "none";
        document.getElementById("writingTone").style.display = "none";
        document.getElementById("outlineButtons").style.display = "none";
        document.getElementById("writingReviewerLabel").style.display = "none";
        document.getElementById("writingReviewer").style.display = "none";
        document.getElementById("reviewScopeArea").style.display = "none";
        submitWritingBtn.style.display = "block";
    } 
    else { // 片段描寫
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        document.getElementById("writingContent").style.display = "block";
        
        document.getElementById("outlineTableArea").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "block";
        document.getElementById("writingTone").style.display = "block";
        document.getElementById("outlineButtons").style.display = "none";
        document.getElementById("writingReviewerLabel").style.display = "block";
        document.getElementById("writingReviewer").style.display = "block";
        document.getElementById("reviewScopeArea").style.display = "block";
        submitWritingBtn.style.display = "block";
    }
}


// 原 showCustomTopicInput() 函式
// 原 showCustomTopicInput() 函式 (已修訂：加入 Toggle 開關邏輯)
function showCustomTopicInput(buttonElement) {
    // --- 1. Toggle 邏輯：如果按鈕已經是 Active 狀態，則關閉它 ---
    if (buttonElement && buttonElement.classList.contains('active')) {
        // 移除 Active 狀態
        buttonElement.classList.remove('active');
        
        // 隱藏輸入區
        const customTopicArea = document.getElementById("customTopicArea");
        customTopicArea.style.display = "none";
        customTopicArea.innerHTML = ""; // 清空內容
        
        // 隱藏結果區 (因為取消了選擇)
        const topicResult = document.getElementById("topicResult");
        topicResult.style.display = "none";
        topicResult.innerHTML = "";
        
        // 清除相關 LocalStorage
        localStorage.removeItem("currentTopic");
        localStorage.removeItem("currentFocus");
        localStorage.removeItem("currentPlot");
        
        return; // 結束函式
    }

    // --- 2. 正常開啟邏輯 ---
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    const writingType = document.getElementById("writingType").value;
    const customTopicArea = document.getElementById("customTopicArea");
    const topicResult = document.getElementById("topicResult");

    topicResult.innerHTML = "";
    topicResult.style.display = "none";
    localStorage.removeItem("currentTopic");
    localStorage.removeItem("currentFocus");
    localStorage.removeItem("currentPlot");

    if (writingType === "片段描寫") {
        customTopicArea.innerHTML = `
        <table>
        <tr><th colspan="2">自訂題目與重點</th></tr>
        <tr><td colspan="2"><input type="text" id="customTitle" class="no-modal-editor" placeholder="請輸入自訂題目"></td></tr>
        <tr><td>扣題方向</td><td>情節大要</td></tr>
        <tr><td><textarea id="customFocus" class="no-modal-editor" rows="3" placeholder="請輸入扣題方向"></textarea></td>
        <td><textarea id="customPlot" class="no-modal-editor" rows="3" placeholder="請輸入情節大要"></textarea></td></tr>
        </table>
        <button class="btn-icon-confirm" onclick="setCustomTopic()" title="確認題目">
        <i class="fas fa-check"></i>
        </button>
        `;
    } else { 
        customTopicArea.innerHTML = `
        <input type="text" id="customTopic" class="no-modal-editor" placeholder="請輸入自訂題目">
        <button class="btn-icon-confirm" onclick="setCustomTopic()" title="確認題目">
        <i class="fas fa-check"></i>
        </button>
        `;
    }
    customTopicArea.style.display = "block";
}

// 保存大綱
function saveOutline() {
const structure = document.getElementById("structure").value;
const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
const outlineData = parts.map((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
const focus = document.getElementById(focusId)?.value.trim() || "";
const plot = document.getElementById(plotId)?.value.trim() || "";
return { part, focus, plot };
});
localStorage.setItem("outlineData", JSON.stringify(outlineData));
localStorage.setItem("outlineStructure", structure);
alert("大綱已儲存");
}

// 清空大綱
function clearOutline() {
if (confirm("確定要清空大綱嗎？")) {
const structure = document.getElementById("structure").value;
const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
parts.forEach((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
if (document.getElementById(focusId)) document.getElementById(focusId).value = "";
if (document.getElementById(plotId)) document.getElementById(plotId).value = "";
});
localStorage.removeItem("outlineData");
localStorage.removeItem("outlineStructure");
}
}

// 加載大綱
function loadOutline() {
const savedStructure = localStorage.getItem("outlineStructure");
const savedData = localStorage.getItem("outlineData");
if (savedStructure && savedData) {
document.getElementById("structure").value = savedStructure;
generateOutlineTable();
try {
const parsedData = JSON.parse(savedData);
parsedData.forEach((item, index) => {
const focusId = savedStructure + "Focus" + (index + 1);
const plotId = savedStructure + "Plot" + (index + 1);
const focusElement = document.getElementById(focusId);
const plotElement = document.getElementById(plotId);
if (focusElement) focusElement.value = item.focus;
if (plotElement) plotElement.value = item.plot;
});
} catch (e) {
console.error("Error parsing outlineData:", e);
}
}
}

// 保存課外書籍對話
function saveBooksChat() {
// 只在有聊天記錄時才儲存
if (chatHistory.length > 0) {
const booksTone = document.getElementById("booksTone").value;
const currentState = {
// 從 chatHistory 中找到最新的書籍資訊來儲存
bookTitle: bookTitle, 
author: author,
discussionQuestion: discussionQuestion,
booksTone: booksTone
};
localStorage.setItem("booksChatHistory", JSON.stringify(chatHistory));
localStorage.setItem("booksChatState", JSON.stringify(currentState));
alert("對話已儲存");
} else {
alert("沒有對話紀錄可儲存。");
}
}

function clearBooksChat() {
if (confirm("確定要清空對話及紀錄嗎？")) {
// 清空 UI
document.getElementById("chatHistory").innerHTML = "";
document.getElementById("chatHistory").style.display = "none";
document.getElementById("chatInputContainer").style.display = "none";
document.getElementById("initialDiscussionForm").style.display = "block"; // 顯示初始表單
document.getElementById("booksButtons").style.display = "none"; // <-- 新增這一行


// 清空表單欄位
document.getElementById("bookTitle").value = "";
document.getElementById("author").value = "";
document.getElementById("discussionQuestion").value = "";
document.getElementById("userInput").value = "";

// 清空 localStorage
localStorage.removeItem("booksChatHistory");
localStorage.removeItem("booksChatState");

// 重置 JS 變數
chatHistory = [];
bookTitle = "";
author = "";
discussionQuestion = "";
booksTone = "";
}
}


function loadBooksChat() {
const savedChatJSON = localStorage.getItem("booksChatHistory");
const savedStateJSON = localStorage.getItem("booksChatState");
const initialForm = document.getElementById("initialDiscussionForm");
const chatInterface = document.getElementById("chatInputContainer");
const chatHistoryDiv = document.getElementById("chatHistory");
const saveBtn = document.getElementById('save-books-html-btn');

if (savedChatJSON && savedStateJSON) {
// --- 有儲存紀錄的模式 ---
initialForm.style.display = "none"; // 隱藏初始表單
chatInterface.style.display = "flex"; // 顯示聊天輸入介面
chatHistoryDiv.style.display = "flex"; // 顯示聊天紀錄
document.getElementById("booksButtons").style.display = "flex"; // <-- 新增這一行
saveBtn.style.display = 'flex'; // 顯示儲存按鈕

chatHistoryDiv.innerHTML = '';
chatHistory = JSON.parse(savedChatJSON);
const state = JSON.parse(savedStateJSON);

// 從 state 恢復全域變數
bookTitle = state.bookTitle || "";
author = state.author || "";
discussionQuestion = state.discussionQuestion || "";
booksTone = state.booksTone || "serious";

// 恢復語氣選擇
document.getElementById("booksTone").value = booksTone;

// 重新渲染聊天紀錄
chatHistory.forEach(item => {
renderMessage(item.sender, item.message);
});

} else {
// --- 沒有儲存紀錄的模式 (初始狀態) ---
initialForm.style.display = "block"; // 顯示初始表單
chatInterface.style.display = "none"; // 隱藏聊天輸入介面
chatHistoryDiv.style.display = "none"; // 隱藏聊天紀錄
saveBtn.style.display = 'none'; // 隱藏儲存按鈕
}
}


/**
* 更新最後一條 AI 訊息的內容（從 "正在回應..." 到實際的回應）。
* 這個新版本能處理帶有頭像和氣泡的複雜 HTML 結構。
* @param {string} newMessage - 從 API 獲取到的新訊息內容。
*/
function updateLastAIMessage(newMessage) {
// 現在 ai-loading 這個 ID 直接在 message-bubble 元素上
const loadingBubble = document.getElementById("ai-loading"); 

if (loadingBubble) {
// 直接更新氣泡的內容
loadingBubble.innerHTML = newMessage;
// 移除 ID
loadingBubble.id = ""; 

// 同步數據
if (chatHistory.length > 0) {
chatHistory[chatHistory.length - 1].message = newMessage;
}
} else {
addMessageToHistory("ai", newMessage);
}
}


// 切換閱讀功能
function toggleReadingFunction() {
    hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
    clearAllTopicStates();
    const readingFunction = document.getElementById("readingFunction").value;
    
    // 新增：處理「訓練」選項，直接跳轉
    if (readingFunction === "training") {
        window.location.href = "https://kenchan20141.github.io/interpretation/";
        return;  // 立即返回，避免執行後續邏輯
    }
    
    const contentContainer = document.getElementById("readingInputArea");
    if (readingFunction) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return; // 如果沒有選擇，則停止執行
    }
    
    const studentAnswerArea = document.getElementById("studentAnswerArea");
    const readingToneLabel = document.getElementById("readingToneLabel");
    const readingTone = document.getElementById("readingTone");
    if (readingFunction === "comment") {
        studentAnswerArea.style.display = "block";
        readingToneLabel.style.display = "block";
        readingTone.style.display = "block";
    } else {
        studentAnswerArea.style.display = "none";
        readingToneLabel.style.display = "none";
        readingTone.style.display = "none";
    }
}


// 請用這個新版本的函式，替換掉您原本的 toggleExpandFunction
function toggleExpandFunction() {
hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
clearAllTopicStates(); // 這行很好，保持不變

const expandFunction = document.getElementById("expandFunction").value;
const contentContainer = document.getElementById("expandContentContainer");

if (expandFunction) {
contentContainer.style.display = "block";
} else {
contentContainer.style.display = "none";
return;
}

const expandWritingArea = document.getElementById("expandWritingArea");
const expandGuideArea = document.getElementById("expandGuideArea");
const expandTopicSelectionArea = document.getElementById("expandTopicSelectionArea");
const expandToneLabel = document.getElementById("expandToneLabel");
const expandTone = document.getElementById("expandTone");

// 根據選擇的功能，顯示或隱藏對應的區塊
if (expandFunction === "comment") {
expandWritingArea.style.display = "block";
expandGuideArea.style.display = "none";
expandTopicSelectionArea.style.display = "block"; // 顯示我們新的按鈕區塊
expandToneLabel.style.display = "block";
expandTone.style.display = "block";

// 確保自訂題目輸入區預設是隱藏的
const customInputArea = document.getElementById("expandCustomTopicInputArea");
if(customInputArea) {
customInputArea.style.display = 'none';
customInputArea.innerHTML = '';
}

} else { // "guide"
expandWritingArea.style.display = "none";
expandGuideArea.style.display = "block";
expandTopicSelectionArea.style.display = "none";
expandToneLabel.style.display = "none";
expandTone.style.display = "none";
}
}
// 新增此函式：用於顯示整合拓展的自訂題目介面
// 新增此函式：用於顯示整合拓展的自訂題目介面 (已修訂：加入 Toggle 開關邏輯)
function showExpandCustomTopicInput(buttonElement) {
    // --- 1. Toggle 邏輯 ---
    if (buttonElement && buttonElement.classList.contains('active')) {
        buttonElement.classList.remove('active');
        
        const customTopicArea = document.getElementById("expandCustomTopicInputArea");
        customTopicArea.style.display = "none";
        customTopicArea.innerHTML = "";
        
        const topicResult = document.getElementById("expandTopicResult");
        topicResult.style.display = "none";
        topicResult.innerHTML = "";
        
        localStorage.removeItem("expandCurrentTitle");
        localStorage.removeItem("expandCurrentTheme");
        localStorage.removeItem("expandCurrentData");
        
        return;
    }

    // --- 2. 正常開啟邏輯 ---
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    const customTopicArea = document.getElementById("expandCustomTopicInputArea");
    const topicResult = document.getElementById("expandTopicResult");

    topicResult.innerHTML = "";
    topicResult.style.display = "none";
    localStorage.removeItem("expandCurrentTitle");
    localStorage.removeItem("expandCurrentTheme");
    localStorage.removeItem("expandCurrentData");

    // 動態生成自訂題目的輸入表格和確認按鈕
    customTopicArea.innerHTML = `
    <table>
    <tr><th>題目</th><td><input type="text" id="expandCustomTitle" class="no-modal-editor" placeholder="請輸入題目"></td></tr>
    <tr><th>主題句</th><td><textarea id="expandCustomTheme" class="no-modal-editor" rows="2" placeholder="請輸入主題句"></textarea></td></tr>
    <tr><th>抄錄資料</th><td><textarea id="expandCustomData" class="no-modal-editor" rows="3" placeholder="請輸入抄錄資料"></textarea></td></tr>
    </table>
    <button class="btn-icon-confirm" onclick="setExpandCustomTopic()" title="確認題目">
    <i class="fas fa-check"></i>
    </button>
    `;
    customTopicArea.style.display = "block";
}


// 切換議論功能
function toggleArgumentType() {
    hideAllSaveHtmlButtons();
    clearAllTopicStates();

    const argumentType = document.getElementById("argumentType").value;
    const contentContainer = document.getElementById("argumentContentContainer");

    // ======= 【核心修訂】獲取所有新增的元素 =======
    const reviewScopeArea = document.getElementById("argumentReviewScopeArea");
    const gradingResultDiv = document.getElementById("argumentGradingResult");
    const chatHistoryDiv = document.getElementById("argumentChatHistory");
    const chatInputContainer = document.getElementById("argumentChatInputContainer");

    // 在切換時，重置並隱藏所有結果與聊天介面
    gradingResultDiv.innerHTML = "";
    chatHistoryDiv.innerHTML = "";
    chatHistoryDiv.style.display = "none";
    chatInputContainer.style.display = "none";
    reviewScopeArea.style.display = "none";
    // ==========================================

    if (argumentType) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return;
    }

    const outlineArea = document.getElementById("argumentOutlineArea");
    const writingArea = document.getElementById("argumentWritingArea");
    const guideArea = document.getElementById("argumentGuideArea");
    const topicSelectionArea = document.getElementById("argumentTopicSelectionArea");

    if (argumentType === "outline") {
        outlineArea.style.display = "block";
        writingArea.style.display = "none";
        guideArea.style.display = "none";
        topicSelectionArea.style.display = "block";
        generateArgumentOutlineTable();
    } else if (argumentType === "writing") {
        outlineArea.style.display = "none";
        writingArea.style.display = "block";
        guideArea.style.display = "none";
        topicSelectionArea.style.display = "block";
        reviewScopeArea.style.display = "block"; // 【修訂】在文章點評模式下顯示範疇選擇
    } else if (argumentType === "guide") {
        outlineArea.style.display = "none";
        writingArea.style.display = "none";
        guideArea.style.display = "block";
        topicSelectionArea.style.display = "none";
    }
}

// 生成議論題目
async function generateArgumentTopic(buttonElement) { 
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

const customTopicArea = document.getElementById("argumentCustomTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("argumentTopicResult");
topicResult.style.display = 'block';

let selectedTopic;
do {
selectedTopic = argumentTopics[Math.floor(Math.random() * argumentTopics.length)];
} while (selectedTopic === lastArgumentTopic && argumentTopics.length > 1);
lastArgumentTopic = selectedTopic;

localStorage.setItem("lastArgumentTopic", lastArgumentTopic);
topicResult.innerHTML = "<strong>" + selectedTopic + "</strong>";
localStorage.setItem("argumentCurrentTopic", selectedTopic);
}




// 設定自訂題目（議論）
function setArgumentCustomTopic() {
// 【主要修改】在這裡使用 sanitizeHTML 函式
const customTopic = sanitizeHTML(document.getElementById("argumentCustomTopic").value.trim());
if (!customTopic) {
alert("請輸入自訂題目");
return;
}

const topicResult = document.getElementById("argumentTopicResult");
topicResult.innerHTML = "<strong>" + customTopic + "</strong>"; // <- 現在安全了
localStorage.setItem("argumentCurrentTopic", customTopic);

// 【核心修訂】強制讓題目結果區塊顯示出來
topicResult.style.display = "block"; 

// 隱藏並清空輸入區域
const customTopicArea = document.getElementById("argumentCustomTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";
}
// 生成議論大綱表格
function generateArgumentOutlineTable() {
const savedData = localStorage.getItem("argumentOutlineData");
let outlineData = [];
if (savedData) {
try {
outlineData = JSON.parse(savedData);
} catch (e) {
console.error("Error parsing argumentOutlineData:", e);
}
}
if (outlineData.length === 0) {
outlineData = [
{ part: "起", point: "", evidence: "" },
{ part: "結構段一", point: "", evidence: "" },
{ part: "結構段二", point: "", evidence: "" },
{ part: "結構段三", point: "", evidence: "" },
{ part: "合", point: "", evidence: "" }
];
}
let tableHTML = "<div class='table-container'><table id='argumentOutlineTable'><tr><th>部份</th><th>論點</th><th>論據及論證</th></tr>";
outlineData.forEach((item, index) => {
tableHTML += `<tr><td>${item.part}</td><td><textarea id="argumentPoint${index}" rows="3">${item.point}</textarea></td><td><textarea id="argumentEvidence${index}" rows="3">${item.evidence}</textarea></td></tr>`;
});
tableHTML += "</table></div>";
document.getElementById("argumentOutlineTableArea").innerHTML = tableHTML;
}

function addArgumentStructureSegment() {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
let structureSegmentCount = 0;
for (let i = 1; i < rows.length - 1; i++) { // 跳過表頭和「合」
if (rows[i].cells[0].innerText.startsWith("結構段")) {
structureSegmentCount++;
}
}
const newSegmentNumber = structureSegmentCount + 1;
const chineseNumbers = ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十"];
const segmentName = `結構段${chineseNumbers[newSegmentNumber - 1] || newSegmentNumber}`;
const newRowIndex = rows.length - 1; // 在「合」之前插入
const newRow = table.insertRow(newRowIndex);
const cell1 = newRow.insertCell(0);
const cell2 = newRow.insertCell(1);
const cell3 = newRow.insertCell(2);
cell1.innerText = segmentName;
cell2.innerHTML = `<textarea id="argumentPoint${newRowIndex - 1}" rows="3"></textarea>`;
cell3.innerHTML = `<textarea id="argumentEvidence${newRowIndex - 1}" rows="3"></textarea>`;
}

// 保存議論大綱
function saveArgumentOutline() {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
const outlineData = [];
for (let i = 1; i < rows.length; i++) { // 跳過表頭
const part = rows[i].cells[0].innerText;
const pointTextarea = rows[i].cells[1].querySelector("textarea");
const evidenceTextarea = rows[i].cells[2].querySelector("textarea");
const point = pointTextarea ? pointTextarea.value.trim() : "";
const evidence = evidenceTextarea ? evidenceTextarea.value.trim() : "";
outlineData.push({ part, point, evidence });
}
localStorage.setItem("argumentOutlineData", JSON.stringify(outlineData));
alert("大綱已儲存");
}

// 清空議論大綱
function clearArgumentOutline() {
if (confirm("確定要清空大綱嗎？")) {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
for (let i = 1; i < rows.length; i++) {
document.getElementById(`argumentPoint${i - 1}`).value = "";
document.getElementById(`argumentEvidence${i - 1}`).value = "";
}
localStorage.removeItem("argumentOutlineData");
}
}

	// 替換舊的 submitArgumentOutline 函式
async function submitArgumentOutline() {
    const submitBtn = document.getElementById('submitArgumentOutlineBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    try {
        const topic = localStorage.getItem("argumentCurrentTopic");
        if (!topic) { alert("請先設定題目"); return; }
        
        const table = document.getElementById("argumentOutlineTable");
        const rows = table.rows;
        let outlineContent = [];
        let outlineRawText = "";

        for (let i = 1; i < rows.length; i++) {
            const part = rows[i].cells[0].innerText;
            const pointTextarea = rows[i].cells[1].querySelector("textarea");
            const evidenceTextarea = rows[i].cells[2].querySelector("textarea");
            const point = pointTextarea ? pointTextarea.value.trim() : "";
            const evidence = evidenceTextarea ? evidenceTextarea.value.trim() : "";
            if (!point || !evidence) { alert("請填寫所有大綱表格"); return; }
            outlineContent.push({ part, point, evidence });
            outlineRawText += `[${part}] 論點：${point} / 論據：${evidence}\n`;
        }

        const tone = document.getElementById("argumentOutlineTone").value;
        
        // ★★★ 語氣指令 ★★★
        let toneInstruction = "請用嚴肅正經的語氣進行點評和建議。";
        if (tone === "chen") {
            toneInstruction = `
            【重要語氣指令】：
            1. 在「=== 點評及建議 ===」和「=== 改寫說明 ===」部分：你必須扮演陳SIR，使用**輕鬆、幽默**的口吻，並**大量使用 Emoji** (如 😂, 🤔, ✨, 🔥)，表示揶揄時會用🤌這個EMOJI。
            2. 在「=== 改寫後的大綱 ===」部分：為了確保學習參考價值，這部分**必須保持絕對嚴肅、學術的風格**，僅提供高質素的內容，**嚴禁使用 Emoji**。`;
        }

        const note = categories["議論"].outlineCommentNote;
        const prompt = `請根據以下大綱內容進行點評和建議，並提供改寫後的大綱。
        ${toneInstruction}
        要求：
        1. 在「=== 點評及建議 ===」部分，為每個結構段提供點評和建議。使用「[part]」標記每個結構段的開始，例如「[起]」，然後在下一行「點評：」後跟點評內容，再下一行「建議：」後跟建議內容。
        2. 在「=== 改寫後的大綱 ===」部分，為每個結構段提供改寫後的「論點」和「論據及論證」。使用「[part]」標記每個結構段的開始，然後在下一行「論點：」後跟內容，再下一行「論據及論證：」後跟內容。
        3. 在「=== 改寫說明 ===」部分，提供不超過兩點的改寫說明，每點以「1. 」和「2. 」開始。
        4. 請確保內容簡潔明了，不可以顯示「--- ###」。不要使用Markdown表格。
        題目：${topic}
        用戶輸入的大綱：
        | 部份 | 論點 | 論據及論證 |
        |------|------|------------|
        ${outlineContent.map(item => `| ${item.part} | ${item.point} | ${item.evidence} |`).join("\n")}
        教學筆記：${note}`;

        showLoading("陳SIR 正在審視大綱...");

        const response = await callAPI(prompt, 0);
        
        currentContextContent = outlineRawText;
        currentContextReview = response;

        // 解析 Response
        const sections = response.split(/=== (.+?) ===/).filter(s => s.trim());
        const commentIndex = sections.indexOf("點評及建議");
        const rewriteIndex = sections.indexOf("改寫後的大綱");
        const explanationIndex = sections.indexOf("改寫說明");
        const commentPart = commentIndex !== -1 ? sections[commentIndex + 1] : "";
        const rewritePart = rewriteIndex !== -1 ? sections[rewriteIndex + 1] : "";
        const explanationPart = explanationIndex !== -1 ? sections[explanationIndex + 1].trim() : "";

        function parseCommentPart(commentPart) {
            const comments = {};
            const regex = /\[(.+?)\]\s*點評：\s*(.+?)(?=\s*建議：|\s*\[|$)/gs;
            const suggestionRegex = /\[(.+?)\]\s*點評：.+?\s*建議：\s*(.+?)(?=\s*\[|$)/gs;
            let match;
            while ((match = regex.exec(commentPart)) !== null) {
                const part = match[1];
                comments[part] = comments[part] || {};
                comments[part].comment = match[2].trim();
            }
            while ((match = suggestionRegex.exec(commentPart)) !== null) {
                const part = match[1];
                comments[part] = comments[part] || {};
                comments[part].suggestion = match[2].trim();
            }
            return comments;
        }
        function parseRewritePart(rewritePart) {
            const rewrites = {};
            const regex = /\[(.+?)\]\s*論點：\s*(.+?)(?=\s*論據及論證：|\s*\[|$)/gs;
            const evidenceRegex = /\[(.+?)\]\s*論點：.+?\s*論據及論證：\s*(.+?)(?=\s*\[|$)/gs;
            let match;
            while ((match = regex.exec(rewritePart)) !== null) {
                const part = match[1];
                rewrites[part] = rewrites[part] || {};
                rewrites[part].point = match[2].trim();
            }
            while ((match = evidenceRegex.exec(rewritePart)) !== null) {
                const part = match[1];
                rewrites[part] = rewrites[part] || {};
                rewrites[part].evidence = match[2].trim();
            }
            return rewrites;
        }
        
        const comments = parseCommentPart(commentPart);
        const rewrites = parseRewritePart(rewritePart);

        let commentTableHTML = `<h3>陳SIR點評及建議：</h3><div class="table-container"><table id="argumentCommentTable"><tr><th style="width:10%">部份</th><th style="width:15%">論點</th><th style="width:20%">論據及論證</th><th style="width:27.5%">點評</th><th style="width:27.5%">建議</th></tr>`;
        outlineContent.forEach(item => {
            const comment = comments[item.part]?.comment || "未生成點評";
            const suggestion = comments[item.part]?.suggestion || "未生成建議";
            commentTableHTML += `<tr><td>${item.part}</td><td>${item.point}</td><td>${item.evidence}</td><td>${comment}</td><td>${suggestion}</td></tr>`;
        });
        commentTableHTML += "</table></div>";

        let rewriteTableHTML = `<h3>改寫後的大綱：</h3><div class="table-container"><table id="argumentRewriteTable"><tr><th style="width:15%">部份</th><th style="width:40%">論點</th><th style="width:45%">論據及論證</th></tr>`;
        outlineContent.forEach(item => {
            const rewrite = rewrites[item.part] || { point: "未生成論點", evidence: "未生成論據及論證" };
            rewriteTableHTML += `<tr><td>${item.part}</td><td>${rewrite.point || "未生成論點"}</td><td>${rewrite.evidence || "未生成論據及論證"}</td></tr>`;
        });
        rewriteTableHTML += "</table></div>";

        let explanationHTML = '';
        if (explanationPart) {
            const points = explanationPart.split(/\s*(?=\d\.\s*)/).filter(p => p.trim());
            explanationHTML = `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫說明</h3>`;
            points.forEach(point => {
                const match = point.match(/^(\d)\.\s*(.*)$/s);
                if (match) {
                    const number = match[1];
                    const text = match[2];
                    explanationHTML += `<div class="explanation-point"><div class="explanation-number">${number}</div><div class="explanation-text">${text}</div></div>`;
                }
            });
            explanationHTML += `</div></div>`;
        }

        openResultCanvas("議論文大綱建議");
        const resultContainer = document.getElementById("resultCanvasBody");
        const fullAiResultHtml = commentTableHTML + rewriteTableHTML + explanationHTML + getCanvasChatHTML('argument_outline');
        resultContainer.innerHTML = fullAiResultHtml;
        resultContainer.style.width = "100%";
        
    
        
        let userInputHistoryStr = `題目：${topic}`;
        saveToHistory(
            "議論", 
            "大綱點評", 
            topic, 
            userInputHistoryStr, 
            fullAiResultHtml 
        );

    } catch (error) {
        console.error("提交議論大綱時出錯:", error);
        alert("點評生成失敗，請重試");
    } finally {
        submitBtn.disabled = false;
        hideLoading();
    }
}

async function submitArgumentWriting() {
    const submitBtn = document.getElementById('submitArgumentWritingBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    const gradingResultDiv = document.getElementById("argumentGradingResult");
    const chatHistoryDiv = document.getElementById("argumentChatHistory");
    const chatInputContainer = document.getElementById("argumentChatInputContainer");
    if(gradingResultDiv) gradingResultDiv.innerHTML = "";
    if(chatHistoryDiv) chatHistoryDiv.style.display = "none";
    if(chatInputContainer) chatInputContainer.style.display = "none";
    argumentChatHistoryData = [];

    try {
        const reviewerSelect = document.getElementById('argumentReviewer');
        const selectedReviewerText = reviewerSelect.options[reviewerSelect.selectedIndex].text;
        currentReviewerName = selectedReviewerText.replace(/\s*\(預設\)\s*/, '');

        const topic = localStorage.getItem("argumentCurrentTopic");
        if (!topic) {
            alert("請先設定題目");
            submitBtn.disabled = false;
            return;
        }
        const content = document.getElementById("argumentWritingContent").value.trim();
        if (!content) {
            alert("請輸入您的文章");
            submitBtn.disabled = false;
            return;
        }
        currentArgumentArticle = content;

        const tone = document.getElementById("argumentWritingTone").value;
        const note = categories["議論"].writingCommentNote;
        const reviewer = document.getElementById('argumentReviewer').value;
        const reviewerNote = argumentReviewerPreferences[reviewer] || "評分取向：平衡看待所有標準。";
        let prompt = "";

        const selectedScopes = Array.from(document.querySelectorAll('input[name="argumentReviewScope"]:checked')).map(cb => cb.value);
        const isFullReview = selectedScopes.includes("全部") || selectedScopes.length === 0;

        showLoading(`${currentReviewerName} 正在細閱文章...`);

        if (isFullReview) {
            let toneInstruction = "請使用嚴肅正經的語氣。";
            if (tone === "chen") {
                toneInstruction = `
                【重要語氣指令】：
                1. 對於 <critique> (點評) 和 <suggestions> (建議) 部分：必須使用**輕鬆、幽默**的口吻，並**大量使用 Emoji** (如 😎, 🔥, 👎, 🧐)，表示揶揄時會用🤌這個EMOJI，就像陳SIR在跟學生面對面說話一樣。
                2. 對於 <rewrite_example> (改寫範例) 部分：必須切換回**嚴肅、學術的風格**，這部分是示範給學生看的範文，**嚴禁使用 Emoji**。`;
            }

            const argumentScoreFirstPrompt = `你將扮演一位極其嚴謹且客觀的中文科AI評卷員。你的工作流程被嚴格限定為「先評分，後解釋」。

### 你的工作流程與思維框架 (必須嚴格遵守，不得顛倒)

1.  **首要任務：量化評分**: 你的第一個動作是，根據下方提供的詳細「評分準則」，對文章的各個維度進行獨立的、客觀的數字評分 (0-10分)。你必須將所有分數結果，完整地填寫在 <grading_json> 標籤內。**此步驟必須在撰寫任何文字評語之前完成。**

2.  **次要任務：撰寫理據**: 在你完成 <grading_json> 的所有評分後，你的第二個動作是，根據你剛剛給出的分數，去撰寫 <critique>, <suggestions>, 和 <rewrite_example> 的內容。你的所有文字評語，都**必須**是為了**解釋和支撐**你已經給出的分數。

### 核心評分準則 (用於步驟一的量化評分)
- **偏題的後果**: 一旦判定為「偏題」，在評分時，「扣題」分數 **絕不能高於4分**，「內容」和「結構」的總分也 **不能高於4分**。

---
### 你的輸出格式 (必須嚴格遵守此結構與順序)

<grading_json>
{
"content": [0-10的整數],
"expression": [0-10的整數],
"structure": [0-10的整數],
"radar": {
"立意": [0-10], "取材": [0-10], "扣題": [0-10],
"詳略": [0-10], "詞彙": [0-10], "文學性": [0-10]
}
}
</grading_json>

<critique>
[根據你在 <grading_json> 中給出的分數，以數字編號列點方式，撰寫2-3點核心評論來解釋這些分數的由來。**格式嚴格要求**：1. 必須使用流暢的**完整句子**。2. **嚴禁**使用冒號小標題（如「論證：...」）。3. **嚴禁**使用括號作總結或公式化表述（如「（論點+論據）」）。請直接將評價融入完整的段落文字中。]
</critique>

<suggestions>
[針對 <critique> 中指出的問題，提出具體的改善建議。**格式嚴格要求**：1. 必須使用**完整句子**。2. **嚴禁**使用冒號小標題。3. **嚴禁**使用括號表述。請用自然流暢的語言給予指導。]
</suggestions>

<rewrite_example>
[這部分是**必須**的。請選取文章中論證較薄弱或表達不佳的一個段落，提供一段約150字內的高質素改寫範例，展示更高分的作品應有的水準。]
</rewrite_example>`;

            prompt = `${toneInstruction}
            請嚴格按照以下「先評分，後解釋」的流程，對學生的議論文進行點評。
            ${argumentScoreFirstPrompt}
            ---
            ### 待點評的資料
            題目：${topic}
            文章：${content}
            教學筆記：${note}
            閱卷員評分取向：${reviewerNote}`;

            const response = await callReadingAPI(prompt);
            
            currentContextContent = content;
            currentContextReview = response;

            // 生成評分報告 (displayFullCommentWithGrading 內部會自動加入一個聊天室)
            await displayFullCommentWithGrading('argumentGradingResult', response, null, 'argument', content);
            
            // ★★★ 已移除多餘的 append ChatHTML 代碼 ★★★
            
         

        } else {
            // (聚焦式點評邏輯 - 不變)
            const scopeDefinitions = `
- **謀篇**: 嚴謹地對比題目《${topic}》與文章的字面內容。
- **論點**: 嚴謹地對比題目《${topic}》與文章的字面內容。
- **論據**: 嚴謹地對比題目《${topic}》與文章的字面內容。
- **論證**: 嚴謹地對比題目《${topic}》與文章的字面內容。
- **文筆**: 嚴謹地對比題目《${topic}》與文章的字面內容。
`;
            let scopeInstruction = `你是一名高度專業的寫作分析員，你的任務極其專一。
            **黃金法則**: 你的點評和建議中的 **每一個字**，都必須 **僅僅** 與用戶選擇的範疇相關：**【${selectedScopes.join("、")}】**。`;

            let toneInstruction = "請使用嚴肅正經的語氣。";
            if (tone === "chen") {
                toneInstruction = `請用幽默詼諧、適時揶揄的語氣進行點評和建議，**必須使用大量Emoji** (如 😎, 🔥, 👎)，表示揶揄時會用🤌這個EMOJI，就像陳SIR在跟學生面對面說話一樣。`;
            }

            prompt = `${toneInstruction}
            ${scopeInstruction}
            ### **你的任務與輸出格式**
            你的輸出必須包含以下兩個XML標籤，不得有其他內容。
            <critique>
            [根據「黃金法則」，給出1-2點核心評論。]
            </critique>
            <suggestions>
            [針對點評中提出的問題，提出具體的改善建議。]
            </suggestions>
            ---
            ### **待點評的資料**
            題目：${topic}
            文章：${content}`;

            const response = await callAPI(prompt, 0);
            
            currentContextContent = content;
            currentContextReview = response;

            const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
            const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
            let initialReviewHTML = `<h3>${currentReviewerName}聚焦點評：</h3>`;
            if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
            if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
            if (!critiqueMatch && !suggestionsMatch) {
                initialReviewHTML += "<p>抱歉，無法生成點評。</p>";
            }

            openResultCanvas("聚焦點評結果");
            const resultBody = document.getElementById("resultCanvasBody");
            
            // ★★★ 手動追加 Chat ★★★
            resultBody.innerHTML = initialReviewHTML + getCanvasChatHTML('argument_writing');
         
        }

    } catch (error) {
        console.error("提交文章時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : "點評生成失敗，請重試");
    } finally {
        submitBtn.disabled = false;
        hideLoading();
    }
}


// 【新增】用於儲存解題指引對話的上下文
let currentGuideTopic = '';
let currentGuideAnalysis = '';
let writingGuideChatHistoryData = [];
	
// 【新增】用於儲存文章點評對話的上下文

// 【新增】用於儲存文章點評對話的上下文
let currentWritingArticle = '';
let currentWritingReview = '';
let writingChatHistoryData = [];

// ======= 請在這裡加入以下程式碼 =======
// 【新增】用於儲存議論文點評對話的上下文
let currentArgumentArticle = '';
let currentArgumentReview = '';
let argumentChatHistoryData = [];





// 【新增】處理議論文「點評範疇」中「全部」複選框的邏輯
function handleArgumentAllScopeChange(checkbox) {
    const container = checkbox.closest('div');
    const otherCheckboxes = container.querySelectorAll('input[name="argumentReviewScope"]:not([value="全部"])');
    if (checkbox.checked) {
        otherCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
        });
    } else {
        otherCheckboxes.forEach(cb => {
            cb.disabled = false;
        });
    }
}
// ======= 加入結束 =======

// 【新增】用於儲存當前閱卷員的姓名
let currentReviewerName = "陳SIR"; // 預設為陳SIR

// 【新增】處理「點評範疇」中「全部」複選框的邏輯
function handleAllScopeChange(checkbox) {
    const container = checkbox.closest('div');
    const otherCheckboxes = container.querySelectorAll('input[name="reviewScope"]:not([value="全部"])');
    if (checkbox.checked) {
        otherCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
        });
    } else {
        otherCheckboxes.forEach(cb => {
            cb.disabled = false;
        });
    }
}

// 提交議論指引
async function submitArgumentGuide() {
const submitBtn = document.getElementById('submitArgumentGuideBtn');
submitBtn.disabled = true; // 禁用按鈕
	hideAllSaveHtmlButtons();

try {
const topic = document.getElementById("argumentGuideTopic").value.trim();
const point = document.getElementById("argumentGuidePoint").value.trim();
const evidence = document.getElementById("argumentGuideEvidence").value.trim();
const argument = document.getElementById("argumentGuideArgument").value.trim();
if (!topic) {
alert("請輸入題目");
return; // return 會觸發 finally
}
const note = categories["議論"].guideNote;
let prompt = `請根據以下輸入提供參考建議。要求：
1. 若只輸入題目，則提供參考論點、參考論據和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
2. 若輸入題目和論點，則提供參考論據和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
3. 若輸入題目和論據，則提供參考論點和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
4. 輸出分為相應的部分：### 參考論點、### 參考論據、### 參考論證
5. 每個部分以段落形式呈現
題目：${topic}
論點：${point || "無"}
論據：${evidence || "無"}
論證：${argument || "無"}
教學筆記：${note}`;
showLoading("陳SIR 正在思考...");

// 【核心修訂】改用閱讀專用的 API 函式
const guide = await callReadingAPI(prompt);
 // 設定聊天室上下文
        currentContextContent = `題目：${topic}\n論點：${point}\n論據：${evidence}\n論證：${argument}`;
        currentContextReview = guide;

        const guideParts = guide.split("###").map(part => part.trim()).filter(part => part);
        let guideHTML = "<h3>陳SIR指引：</h3><table>";
        guideParts.forEach(part => {
            const [title, ...content] = part.split("\n").filter(line => line.trim());
            guideHTML += `<tr><th><strong>${title}</strong></th></tr><tr><td>${content.join("<br>")}</td></tr>`;
        });
        guideHTML += "</table>";

        // ★★★ 加入聊天室 ★★★
        guideHTML += getCanvasChatHTML('argument_guide');

        openResultCanvas("議論文寫作指引");
        document.getElementById("resultCanvasBody").innerHTML = guideHTML;

        // 儲存 (移除聊天室)
        const historyHTML = guideHTML.split('<div class="canvas-chat-container">')[0];
        saveToHistory("議論", "指引", topic, `題目：${topic}\n論點：${point}\n論據：${evidence}\n論證：${argument}`, historyHTML);
        
    
    } catch (error) {
        console.error("提交指引時出錯:", error);
        alert("指引生成失敗，請重試");
    } finally {
        submitBtn.disabled = false; 
        hideLoading();
    }
}

// 通用 API 調用函數 (加入 50 秒超時)
async function callAPI(prompt, temperature = null) {
	// ★★★ 新增：額度檢查 ★★★
    if (!checkGuestUsage()) {
        // 中斷執行並拋出錯誤，讓外層 catch 處理
        throw new Error("Guest usage limit exceeded"); 
    }
    let attempts = 0;
    const maxAttempts = API_KEYS.length;
    // 每次調用都從一個隨機的索引開始
    let currentApiKeyIndex = Math.floor(Math.random() * API_KEYS.length);
    const TIMEOUT_MS = 100000; // 設定 50 秒超時

    while (attempts < maxAttempts) {
        // 定義超時控制器
        const controller = new AbortController();
		globalAbortController = controller; // ★★★ 加入這一行：綁定全域控制器
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

        try {
            const requestBody = {
                model: MODEL,
                messages: [{
                    role: "user",
                    content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
                }],
                max_tokens: 15000
            };

            if (temperature !== null) {
                requestBody.temperature = temperature;
            }

            const response = await fetch(API_URL, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${API_KEYS[currentApiKeyIndex]}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody),
                signal: controller.signal // 綁定中斷訊號
            });

            clearTimeout(timeoutId); // 成功收到回應，清除計時器

            if (response.status === 429) {
                console.warn(`通用 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
                currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
                attempts++;
                continue;
            }

            if (!response.ok) {
                throw new Error(`API 調用失敗: ${response.statusText}`);
            }

            const data = await response.json();
            let content = data.choices[0].message.content.trim();
            content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

            if (!content) {
                throw new Error("API 回應無效或過濾後無內容");
            }

            return content;

        } catch (error) {
            // 清除計時器以防萬一
            clearTimeout(timeoutId);
            
            console.error(`使用通用 API Key ${currentApiKeyIndex} 時出錯 (嘗試 ${attempts + 1}/${maxAttempts}):`, error);
            
            // 無論是網絡錯誤、API錯誤還是超時(AbortError)，都切換下一個 Key
           currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
            attempts++;
            
            if (attempts >= maxAttempts) {
                // ★★★ 新增這一行：觸發失敗計數與檢查 ★★★
                trackApiCycleFailure(); 
                
                throw new Error("所有 API 密鑰均無法使用或連線超時");
            }
        }
    }
}

// =======================================================
// === 【全新增設】Llama-3 驗證模型專用 API 呼叫函式 ===
// =======================================================
const LLAMA3_API_KEYS = [
   "pk_D77NeM4n6GnNCYbo",
"pk_c17y17tQ3BY71cpd",
"pk_Ax3rRTHkrdTQVIGD",
"pk_dGVqEggn4T4dwQI3",
"pk_YIFWnDFts0quviE0"
];
const LLAMA3_API_URL = "https://gen.pollinations.ai/v1/chat/completions";
const LLAMA3_MODEL = "gemini"; // 指定新的驗證模型

// =======================================================
// === 【全新增設】Llama-3 驗證模型專用 API 呼叫函式 (加入 50 秒超時) ===
// =======================================================
async function callLlama3API(prompt, temperature = null) {
    let attempts = 0;
    const maxAttempts = LLAMA3_API_KEYS.length;
    let currentApiKeyIndex = Math.floor(Math.random() * LLAMA3_API_KEYS.length);
    const TIMEOUT_MS = 100000; // 設定 50 秒超時

    while (attempts < maxAttempts) {
        // 定義超時控制器
        const controller = new AbortController();
		globalAbortController = controller; // ★★★ 加入這一行：綁定全域控制器
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

        try {
            const requestBody = {
                model: LLAMA3_MODEL,
                messages: [{
                    role: "user",
                    content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
                }],
                max_tokens: 15000
            };

            if (temperature !== null) {
                requestBody.temperature = temperature;
            }

            const response = await fetch(LLAMA3_API_URL, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${LLAMA3_API_KEYS[currentApiKeyIndex]}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody),
                signal: controller.signal // 綁定中斷訊號
            });

            clearTimeout(timeoutId); // 成功收到回應，清除計時器

            if (response.status === 429) {
                console.warn(`Llama3 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
                currentApiKeyIndex = (currentApiKeyIndex + 1) % LLAMA3_API_KEYS.length;
                attempts++;
                continue;
            }

            if (!response.ok) {
                throw new Error(`Llama3 API 調用失敗: ${response.statusText}`);
            }

            const data = await response.json();
            let content = data.choices[0].message.content.trim();
            content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

            if (!content) {
                throw new Error("Llama3 API 回應無效或過濾後無內容");
            }

            return content;

        } catch (error) {
            // 清除計時器以防萬一
            clearTimeout(timeoutId);

            console.error(`使用 Llama3 API Key ${currentApiKeyIndex} 時出錯 (嘗試 ${attempts + 1}/${maxAttempts}):`, error);
            
            // 無論是網絡錯誤、API錯誤還是超時(AbortError)，都切換下一個 Key
            currentApiKeyIndex = (currentApiKeyIndex + 1) % LLAMA3_API_KEYS.length;
            attempts++;
            
            if (attempts >= maxAttempts) {
                // ★★★ 新增這一行 ★★★
                trackApiCycleFailure(); 
                
                throw new Error("所有 Llama3 API 密鑰均無法使用或連線超時");
            }
        }
    }
}

/**
 * 【全新函式】應用 Llama-3 驗證模型的內容與結構分數差距規則。
 * 規則：內容分和結構分的分差值不能高於1分。
 * 執行方式：如果分差大於1，則將較高的分數下調至「較低分+1」。
 * @param {object} scores - 從 Llama-3 模型解析出的原始評分物件。
 * @returns {object} - 經過規則調整後的評分物件。
 */
const applyContentStructureRule = (scores) => {
    // 建立一個分數物件的深層複本，避免影響原始數據
    let s = JSON.parse(JSON.stringify(scores));

    // 檢查 content 和 structure 分數是否存在
    if (s.content !== undefined && s.structure !== undefined) {
        const contentScore = s.content;
        const structureScore = s.structure;
        const difference = Math.abs(contentScore - structureScore);

        // 如果分數差距大於 1，則觸發調整機制
        if (difference > 1) {
            console.log(`觸發 Llama-3 內容/結構分差值規則：內容=${contentScore}, 結構=${structureScore}, 差值=${difference}`);
            
            // 判斷哪個分數較高，並將其下調
            if (contentScore > structureScore) {
                s.content = structureScore + 1; // 將內容分下調至「結構分+1」
                console.log(`調整後內容分數: ${s.content}`);
            } else { // structureScore > contentScore
                s.structure = contentScore + 1; // 將結構分下調至「內容分+1」
                console.log(`調整後結構分數: ${s.structure}`);
            }
        }
    }
    // 返回調整後（或無需調整）的分數物件
    return s;
};




/**
* Creates a beautiful bulleted list HTML from raw text content.
* @param {string} title - The title for the card (e.g., '點評', '建議').
* @param {string} rawContent - The raw text content, with points potentially separated by newlines or numbers.
* @returns {string} - The formatted HTML string.
*/
function createBulletedListHTML(title, rawContent) {
    // 【核心修訂】在處理文字前，先移除所有星號(*) Markdown 符號
    rawContent = rawContent.replace(/\*/g, '');

    // Attempt to split by numbered points first, e.g., "1. ...", "2. ..."
    let points = rawContent.split(/\s*(?=\d+\.\s*)/).map(p => p.trim()).filter(p => p);

    // If the primary split method results in 0 or 1 point, and the content has newlines,
    // it's likely not a numbered list. Fall back to splitting by newline.
    if (points.length <= 1 && rawContent.includes('\n')) {
        const newlinePoints = rawContent.split('\n').map(p => p.trim()).filter(p => p);
        // Only use the newline split if it gives us more than one point.
        if (newlinePoints.length > 1) {
            points = newlinePoints;
        }
    }

    // If there are no points to list, just show the content as a paragraph inside the card.
    if (points.length === 0) {
        return `<div class="rewrite-explanation-container">
    <div class="rewrite-explanation-card">
    <h3>${title}</h3>
    <div class="explanation-text">${rawContent.replace(/\n/g, '<br>')}</div>
    </div>
    </div>`;
    }

    let explanationHTML = `<div class="rewrite-explanation-container">
    <div class="rewrite-explanation-card">
    <h3>${title}</h3>`;

    points.forEach((point, index) => {
        let number = index + 1;
        let text = point;

        // Check if the point already starts with a number and a dot.
        const match = point.match(/^(\d+)\.?\s*(.*)$/s);
        if (match) {
            number = match[1]; // Use the number from the text.
            text = match[2]; // Use the text after the number.
        }

        explanationHTML += `<div class="explanation-point">
    <div class="explanation-number">${number}</div>
    <div class="explanation-text">${text.replace(/\n/g, '<br>')}</div>
    </div>`;
    });

    explanationHTML += `</div></div>`;
    return explanationHTML;
}



// 原 generateTopic() 函式
// 原 generateTopic() 函式 (已修訂：只生成題目，不調用 LLM)
function generateTopic(buttonElement) { 
    if (buttonElement) {
        updateButtonActiveState(buttonElement);
    }

    // 隱藏自訂題目輸入區，確保介面乾淨
    const customTopicArea = document.getElementById("customTopicArea");
    customTopicArea.style.display = "none";
    customTopicArea.innerHTML = "";

    const topicResult = document.getElementById("topicResult");
    topicResult.style.display = 'block';

    // 隨機抽選題目
    let selectedTopic;
    do {
        selectedTopic = topics[Math.floor(Math.random() * topics.length)];
    } while (selectedTopic === lastTopic && topics.length > 1);
    
    lastTopic = selectedTopic;
    localStorage.setItem("lastTopic", lastTopic);

    // 直接顯示題目 (不區分寫作類型，統一處理)
    topicResult.innerHTML = "<strong>" + selectedTopic + "</strong>";
    
    // 儲存狀態
    localStorage.setItem("currentTopic", selectedTopic);
    
    // 關鍵：清空之前的重點和情節設定，以免影響這次的評分
    localStorage.setItem("currentFocus", "");
    localStorage.setItem("currentPlot", "");
}

	
// 設定自訂題目（寫作）
function setCustomTopic() {
const writingType = document.getElementById("writingType").value;
const topicResult = document.getElementById("topicResult");

if (writingType === "片段描寫") {
// 【核心修訂】只檢查題目是否已輸入
const title = sanitizeHTML(document.getElementById("customTitle").value.trim());
if (!title) {
alert("請至少輸入自訂題目");
return;
}

// 獲取（可能是空的）重點和情節
const focus = document.getElementById("customFocus").value.trim();
const plot = document.getElementById("customPlot").value.trim();

// 即使 focus 和 plot 是空的，也正常生成顯示表格
// 這樣使用者可以清楚地看到他們輸入了什麼，沒輸入什麼
topicResult.innerHTML = `
<strong>${title}</strong>
<table>
<tr><th>結構段重點</th><th>情節大要</th></tr>
<tr><td>${focus || '<i>（未提供）</i>'}</td><td>${plot || '<i>（未提供）</i>'}</td></tr>
</table>
`;

// 儲存到 localStorage，空值也一併儲存
localStorage.setItem("currentTopic", title);
localStorage.setItem("currentFocus", focus);
localStorage.setItem("currentPlot", plot);

} else { 
const customTopic = sanitizeHTML(document.getElementById("customTopic").value.trim());
if (!customTopic) {
alert("請輸入自訂題目");
return;
}
topicResult.innerHTML = "<strong>" + customTopic + "</strong>";
localStorage.setItem("currentTopic", customTopic);
}

topicResult.style.display = 'block';

const customTopicArea = document.getElementById("customTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";
}
// 生成大綱表格
function generateOutlineTable() {
const structure = document.getElementById("structure").value;
let parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
let tableHTML = "<div class='table-container'><table><tr><th>部份</th><th>結構段重點</th><th>情節大要</th></tr>";
parts.forEach((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
tableHTML += `<tr><td>${part}</td><td><textarea id="${focusId}" rows="3"></textarea></td><td><textarea id="${plotId}" rows="3"></textarea></td></tr>`;
});
tableHTML += "</table></div>";
document.getElementById("outlineTableArea").innerHTML = tableHTML;
}





// ==========================================
// === 修訂：解題指引聊天室互動函數 (修復失憶問題) ===
// ==========================================
async function continueWritingGuideDiscussion() {
    const continueBtn = document.getElementById('continueWritingGuideBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("writingGuideUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const chatHistoryDiv = document.getElementById('writingGuideChatHistory');
    
    // 1. 顯示使用者訊息
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    chatHistoryDiv.appendChild(userMessageBubble);
    
    // 2. 將使用者訊息存入歷史紀錄
    writingGuideChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("writingGuideUserInput").value = "";
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 3. 顯示 AI 正在回應
    const aiMessageBubble = document.createElement('div');
    aiMessageBubble.className = 'message-bubble ai-message';
    aiMessageBubble.textContent = `陳SIR正在回應...`;
    chatHistoryDiv.appendChild(aiMessageBubble);
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 4. 準備對話歷史文字 (去除 HTML 標籤，讓 AI 讀得更清楚)
    // 這裡我們把之前的對話整理成純文字格式
    const conversationHistoryForPrompt = writingGuideChatHistoryData.map(item => {
        const role = item.sender === 'user' ? '學生' : '陳SIR';
        // 簡單去除 HTML 標籤以防干擾 Prompt
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = item.message;
        const cleanMessage = tempDiv.textContent || tempDiv.innerText || "";
        return `${role}: ${cleanMessage}`;
    }).join('\n');

    // 5. 準備 Prompt (核心修正：加入指引上下文)
    const prompt = `
    【角色設定】
    你是一位高中中文科老師「陳SIR」，你剛剛為學生分析了作文題目：「${currentGuideTopic}」。
    你的語氣親切、有見地，善於用具體的例子或生活化的比喻來引導學生深入思考，而不是只給空泛的理論。

    【背景資料：你剛才生成的解題指引內容】
    (請基於此內容回答學生的問題，不要忘記你剛剛提出的觀點)
    ---
    ${currentGuideAnalysis}
    ---

    【我們剛才的對話紀錄】
    ${conversationHistoryForPrompt}

    【學生的最新追問】
    ${userInputText}

    【你的任務】
    請針對學生的最新追問進行回應。
    1. 必須緊扣你剛才生成的「解題指引」內容（例如你提到的情感特質或故事種子）。
    2. 不要使用括號解釋你的目的。
    3. 請用完整句子回應，字數控制在 200 字以內。
    `;

   try {
    const aiResponse = await callAPI(prompt);
    // 添加這段檢查代碼
    if (!aiResponse || typeof aiResponse !== 'string') {
        throw new Error('API 傳回無效回應');
    }
    
    // 6. 更新 UI (將 Markdown 粗體轉為 HTML)
    let formattedResponse = aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    formattedResponse = formattedResponse.replace(/\n/g, '<br>');
    aiMessageBubble.innerHTML = formattedResponse;
    
    // 存入歷史
    writingGuideChatHistoryData.push({ sender: 'ai', message: aiResponse });
} catch (error) {
    console.error("繼續指引討論時出錯:", error);
    aiMessageBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，陳SIR無法回應。😅`;
} finally {
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    continueBtn.disabled = false;
}
}


// ==========================================
// === 修訂：解題指引提交函數 (含追問聊天室功能) ===
// ==========================================
async function submitWritingGuide() {
    const submitBtn = document.getElementById('submitWritingGuideBtn');
    const inputTopic = document.getElementById('writingGuideTopicInput').value.trim();
    
    // 隱藏頁面上的舊元素，以免混亂
    const resultContainerOnPage = document.getElementById('writingGuideResultContainer');
    if (resultContainerOnPage) resultContainerOnPage.style.display = "none";

    if (!inputTopic) {
        alert("請輸入題目！");
        return;
    }

    submitBtn.disabled = true;
    showLoading("陳SIR 正在拆解題目...");
    
    const prompt = `你是一位深諳中國文學的寫作顧問。使用者輸入題目：「${inputTopic}」。

請模仿以下【示例】的風格、深度和語氣，為這個題目撰寫「題眼分析」及「寫作方向」。
在「題眼分析」，用語要求準確、理性、非文學化，而在「寫作方向」，你的輸出必須文學化、感性。
**嚴禁**使用「你好」、「我們來看看」等開場白，直接輸出內容。
**嚴禁**使用 1. 2. 3. 等數字列表，請嚴格遵守下方的【輸出格式】標籤。

【任務要求】
1. **題眼分析**：
   - 分析題眼的意思，做非文學性、貼近日常生活的釋義，約150-200字。
2. **寫作方向**：
   - 提供 3 個具體的「故事種子」。
   - 每個種子包含：標題、情境（具體畫面）、張力（為何扣連題目）。

【輸出格式 (請嚴格遵守分隔符)】
[INTRO]
(這裡填寫題眼分析與詞語關係分析...)
[SEED]
(故事種子標題 1)
情境：(具體畫面描述...)
張力：(解釋為何扣題...)
[SEED]
(故事種子標題 2)
情境：(具體畫面描述...)
張力：(解釋為何扣題...)
[SEED]
(故事種子標題 3)
情境：(具體畫面描述...)
張力：(解釋為何扣題...)
`;

    try {
        // 使用閱讀專用 API (通常較穩定) 或通用 API
        const response = await callReadingAPI(prompt);
        
        // ★★★ 關鍵：設定全域變數，供畫布聊天室的 AI 讀取 ★★★
        currentContextContent = `題目：${inputTopic}`; 
        currentContextReview = response; // 讓 AI 知道它剛剛分析了什麼

        // === 解析邏輯 ===
        // 1. 解析 Intro
        let introContent = "";
        const introSplit = response.split('[INTRO]');
        if (introSplit.length > 1) {
            introContent = introSplit[1].split('[SEED]')[0].trim();
        }

        // 2. 解析 Seeds
        const seedParts = response.split('[SEED]').slice(1).map(p => p.trim());

        // === 組裝 HTML ===
        let finalHTML = `<h3>陳SIR 解題指引：${inputTopic}</h3>`;

        // 加入題眼分析區塊
        finalHTML += `
        <div class="guide-section-header" style="border-left: 5px solid #4A90E2; color: #4A90E2;">
            <h3><i class="fas fa-search"></i> 題眼分析</h3>
        </div>`;
        
        if (introContent) {
            finalHTML += `<div class="guide-intro-card"><p>${introContent.replace(/\n/g, '<br>')}</p></div>`;
        }

        // 加入寫作方向區塊
        finalHTML += `
        <div class="guide-section-header" style="border-left: 5px solid #28a745; color: #28a745; margin-top: 30px;">
            <h3><i class="fas fa-compass"></i> 寫作方向</h3>
        </div>`;

        if (seedParts.length > 0) {
            finalHTML += `<div class="guide-grid-3">`; // 開始 Grid 容器
            
            seedParts.forEach(part => {
                const lines = part.split('\n').filter(l => l.trim());
                const title = (lines[0] || "故事種子").replace(/\*\*/g, '');
                const contentText = lines.slice(1).join('\n');
                let situation = "內容解析中...";
                let contradiction = "內容解析中...";
                const cleanContent = contentText.replace(/\*\*/g, ''); 
                
                const parts = cleanContent.split(/(?:張力|矛盾)[:：]/);
                if (parts.length > 1) {
                    situation = parts[0].replace(/^(?:情境|情景)[:：]\s*/, '').trim();
                    contradiction = parts[1].trim();
                } else {
                    situation = cleanContent;
                    contradiction = "";
                }

                finalHTML += `
                <div class="guide-card seed-card">
                    <div class="seed-header">${title}</div>
                    <div class="seed-body">
                        <p><strong><i class="fas fa-image"></i> 情境：</strong></p>
                        <p>${situation.replace(/\n/g, '<br>')}</p>
                        <hr style="border:0; border-top:1px dashed #ddd; margin: 10px 0;">
                        <p><strong><i class="fas fa-bolt"></i> 張力：</strong></p>
                        <p>${contradiction.replace(/\n/g, '<br>')}</p>
                    </div>
                </div>`;
            });
            
            finalHTML += `</div>`; // 結束 Grid 容器
        }

        // ★★★ 關鍵：加入畫布聊天室介面 ★★★
        // 這會自動生成對話框，並且 sendCanvasMessage 會讀取上面的 currentContext 變數
        finalHTML += getCanvasChatHTML('narrative_guide');

        // === 打開畫布並寫入內容 ===
        openResultCanvas("解題指引");
        const resultContainer = document.getElementById("resultCanvasBody");
        resultContainer.innerHTML = finalHTML;

        // === 儲存歷史紀錄 ===
        // 儲存時移除聊天室 HTML，以免歷史紀錄過長
        const historyHTML = finalHTML.split('<div class="canvas-chat-container">')[0]; 
        saveToHistory("敘事抒情", "解題指引", inputTopic, `題目：${inputTopic}`, historyHTML);
        
        // 顯示儲存按鈕 (如果有的話)
        hideAllSaveHtmlButtons();
   


    } catch (error) {
        console.error("解題指引生成失敗:", error);
        alert("生成失敗，請稍後再試。");
    } finally {
        submitBtn.disabled = false;
        hideLoading();
    }
}



	
// ==========================================
// === 修訂：寫作提交函數 (含敘事物象 UI 美化) ===
// ==========================================
async function submitWriting() {
    const submitBtn = document.getElementById('submitWritingBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    // 強制隱藏舊版頁面上的聊天室元素
    const writingGradingResultDiv = document.getElementById("writingGradingResult");
    const writingChatHistoryDiv = document.getElementById("writingChatHistory");
    const writingChatInputContainerDiv = document.getElementById("writingChatInputContainer");
    if(writingGradingResultDiv) writingGradingResultDiv.innerHTML = "";
    if(writingChatHistoryDiv) writingChatHistoryDiv.style.display = "none";
    if(writingChatInputContainerDiv) writingChatInputContainerDiv.style.display = "none";
    writingChatHistoryData = [];

    try {
        const reviewerSelect = document.getElementById('writingReviewer');
        if (reviewerSelect) {
            const selectedReviewerText = reviewerSelect.options[reviewerSelect.selectedIndex].text;
            currentReviewerName = selectedReviewerText.replace(/\s*\(預設\)\s*/, '');
        } else {
            currentReviewerName = "陳SIR";
        }

        const writingType = document.getElementById("writingType").value;
        const topic = localStorage.getItem("currentTopic");
        if (!topic) {
            alert("請先設定題目");
            submitBtn.disabled = false;
            return;
        }

        let content = "";
        let prompt = "";
        const tone = document.getElementById("writingTone").value;

        // ==========================================
        // 模式一：大綱點評
        // ==========================================
        if (writingType === "大綱") {
            const structure = document.getElementById("structure").value;
            const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
            
            let outlineRawText = ""; 
            
            const outlineData = parts.map((part, index) => {
                const focusId = structure + "Focus" + (index + 1);
                const plotId = structure + "Plot" + (index + 1);
                const focus = document.getElementById(focusId)?.value.trim() || "";
                const plot = document.getElementById(plotId)?.value.trim() || "";
                if (!focus || !plot) throw new Error("請填寫所有大綱表格");
                
                outlineRawText += `[${part}] 重點：${focus} \n 情節：${plot}\n`;
                return { part, focus, plot };
            });

            const note = categories["大綱"].commentNote;
            
            let toneInstruction = "請用嚴肅正經的語氣進行點評和建議。";
            if (tone === "chen") {
                toneInstruction = `
                【重要語氣指令】：
                1. 在「=== 點評及建議 ===」和「=== 改寫說明 ===」部分：你必須扮演陳SIR，使用**輕鬆、幽默**的口吻，並**大量使用 Emoji** (如 😂, 🤔, ✨, 🔥)，表示揶揄時會用🤌這個EMOJI，語氣要像朋友聊天。
                2. 在「=== 改寫後的大綱 ===」部分：為了確保學習參考價值，這部分**必須保持絕對嚴肅、學術的風格**，僅提供高質素的內容，**嚴禁使用 Emoji**。`;
            }

            prompt = `請根據以下大綱內容進行點評和建議，並提供改寫後的大綱。
            ${toneInstruction}

            要求：
            1. 在「=== 點評及建議 ===」部分，為每個結構段提供點評和建議。使用「[part]」標記每個結構段的開始，例如「[起]」，然後在下一行「點評：」後跟點評內容，再下一行「建議：」後跟建議內容。
            2. 在「=== 改寫後的大綱 ===」部分，為每個結構段提供改寫後的「結構段重點」和「情節大要」。使用「[part]」標記每個結構段的開始，然後在下一行「結構段重點：」後跟內容，再下一行「情節大要：」後跟內容。
            3. 在「=== 改寫說明 ===」部分，提供不超過兩點的改寫說明，每點以「1. 」和「2. 」開始。
            4. 請確保內容簡潔明了，不可以顯示「--- ###」。
            
            題目：${topic}
            大綱結構：${structure === "fourPart" ? "起承轉合" : "三線（起、一線、二線、三線、合）"}
            用戶輸入的大綱：
            | 部份 | 結構段重點 | 情節大要 |
            |------|------------|----------|
            ${outlineData.map(item => `| ${item.part} | ${item.focus} | ${item.plot} |`).join("\n")}
            教學筆記：${note}`;
            
            showLoading("陳SIR 正在點評大綱..."); 
            const response = await callAPI(prompt, 0);
            
            currentContextContent = outlineRawText;
            currentContextReview = response;

            displayOutlineComment(response, outlineData);

            const structureName = structure === "fourPart" ? "起承轉合" : "三線";
            let userContentForHistory = `題目：${topic}\n結構：${structureName}`;
            
            // 儲存 HTML 時已經包含了聊天室結構 (由 displayOutlineComment 生成)，這裡直接儲存
            saveToHistory(
                "敘事抒情", 
                "大綱點評", 
                topic, 
                userContentForHistory, 
                document.getElementById("resultCanvasBody").innerHTML
            );
        } 
        // ==========================================
        // 模式二：敘事物象 (★ UI 美化修訂 ★)
        // ==========================================
        else if (writingType === "敘事物象") {
            content = document.getElementById("narrativeElements").value.trim();
            const note = categories["敘事物象"].commentNote;
            prompt = `請根據以下題目和取材/故事背景生成五十個不重複且相關的物象。要求：
1. 物象必須與題目和取材/故事背景緊密相關。
2. 物象應多樣化且生動，能夠增強故事的真實感和情感表達。
3. 請以列表形式呈現，每個物象佔一行。
4. 請確保物象不重複且排版整齊。
題目：${topic}
取材/故事背景：${content || "無具體背景，根據題目生成"}
教學筆記：${note}`;
            
            showLoading("陳SIR 正在生成物象...");
            const response = await callAPI(prompt, 0);
            
            // ★★★ 設定聊天室上下文 ★★★
            currentContextContent = `題目：${topic}\n背景：${content}`;
            currentContextReview = response;

            // 清理並分割數據
            const elements = response.split("\n")
                                     .map(item => item.replace(/^\d+\.|^-\s*/, '').trim())
                                     .filter(item => item);
            
            // ★★★ 使用 .vocab-grid 網格樣式 (與閱讀指引一致) ★★★
            let elementsHTML = `<div class="rewrite-explanation-container">
                <div class="rewrite-explanation-card">
                    <h3>生成的物象（${elements.length}項）：</h3>
                    <div class="vocab-grid">`;
            
            elements.forEach(element => {
                elementsHTML += `<div class="vocab-item">${element}</div>`;
            });
            
            elementsHTML += `</div></div></div>`; 

            // ★★★ 加入聊天室介面 ★★★
            elementsHTML += getCanvasChatHTML('narrative_elements');

            openResultCanvas("生成的敘事物象");
            document.getElementById("resultCanvasBody").innerHTML = elementsHTML;
            
            // 儲存時移除聊天室 HTML (以免歷史紀錄過長)
            const historyHTML = elementsHTML.split('<div class="canvas-chat-container">')[0];
            saveToHistory("敘事抒情", "敘事物象", topic, `題目：${topic}\n取材：${content}`, historyHTML);
        } 
        // ==========================================
        // 模式三：文章點評 (保持不變)
        // ==========================================
        else { 
            content = document.getElementById("writingContent").value.trim();
            if (!content) {
                alert("請先輸入寫作內容");
                submitBtn.disabled = false;
                return;
            }
            
            const selectedScopes = Array.from(document.querySelectorAll('input[name="reviewScope"]:checked')).map(cb => cb.value);
            const isFullReview = selectedScopes.includes("全部") || selectedScopes.length === 0;

            if (isFullReview) {
                showLoading(`${currentReviewerName} 正在點評...`); 

                const focus = localStorage.getItem("currentFocus");
                const plot = localStorage.getItem("currentPlot");
                const note = categories["片段描寫"].commentNote;
                const reviewer = document.getElementById('writingReviewer').value;
                const reviewerNote = narrativeReviewerPreferences[reviewer] || "評分取向：平衡看待所有標準。";
                
                let toneInstruction = "請使用嚴肅正經的語氣。";
                if (tone === "chen") {
                    toneInstruction = `
                    【重要語氣指令】：
                    1. 對於 <critique> (點評) 和 <suggestions> (建議) 部分：必須使用**輕鬆、幽默**的口吻，並**大量使用 Emoji** (如 😎, 🔥, 👎, 🧐)，表示揶揄時會用🤌這個EMOJI，就像陳SIR在跟學生面對面說話一樣。
                    2. 對於 <rewrite_example> (改寫範例) 部分：必須切換回**嚴肅、優美、高分的文學風格**，這部分是示範給學生看的範文，**嚴禁使用 Emoji**，也請勿使用口語。`;
                }

                const narrativeScoreFirstPrompt = `你將扮演一位極其嚴謹且客觀的中文科AI評卷員。你的工作流程被嚴格限定為「先評分，後解釋」。

### 你的工作流程 (必須嚴格遵守，不得顛倒)

1.  **首要任務：量化評分**: 你的第一個動作是，根據下方提供的詳細「評分準則」，對文章的各個維度進行獨立的、客觀的數字評分 (0-10分)。你必須將所有分數結果，完整地填寫在 <grading_json> 標籤內。**此步驟必須在撰寫任何文字評語之前完成。**

2.  **次要任務：撰寫理據**: 在你完成 <grading_json> 的所有評分後，你的第二個動作是，根據你剛剛給出的分數，去撰寫 <critique>, <suggestions>, 和 <rewrite_example> 的內容。你的所有文字評語，都**必須**是為了**解釋和支撐**你已經給出的分數。

### 核心評分準則 (用於步驟一的量化評分)
- **偏題的後果**: 如果文章內容與題目無關，在評分時，「扣題」分數 **絕不能高於4分**，「內容」和「結構」的總分也 **不能高於4分**。

---
### 你的輸出格式 (必須嚴格遵守此結構與順序)

<grading_json>
[**分數量化步驟**：根據「核心評分準則」，客觀地為以下所有項目評分。]
{
"content": [0-10的整數],
"expression": [0-10的整數],
"structure": [0-10的整數],
"radar": {
"立意": [0-10], "取材": [0-10], "扣題": [0-10],
"詳略": [0-10], "詞彙": [0-10], "文學性": [0-10]
}
}
</grading_json>

<critique>
[根據你在 <grading_json> 中給出的分數，以數字編號列點方式，撰寫2-3點核心評論來解釋這些分數的由來。**格式嚴格要求**：1. 必須使用流暢的**完整句子**。2. **嚴禁**使用冒號小標題（如「立意方面：...」）。3. **嚴禁**使用括號作總結或公式化表述（如「（個人經歷+反思）」）。請直接將評價融入完整的段落文字中。]
</critique>

<suggestions>
[針對 <critique> 中指出的問題，提出具體的改善建議。**格式嚴格要求**：1. 必須使用**完整句子**。2. **嚴禁**使用冒號小標題。3. **嚴禁**使用括號表述。請用自然流暢的語言給予指導。]
</suggestions>

<rewrite_example>
[提供一段約150字內的高質素改寫範例，展示更高分的作品應有的水準。]
</rewrite_example>`;

                prompt = `${toneInstruction}
                請嚴格按照以下「先評分，後解釋」的流程，對學生的敘事抒情文進行點評。
                ${narrativeScoreFirstPrompt}
                ---
                ### 待點評的資料
                題目：${topic}
                結構段重點：${focus}
                情節大要：${plot}
                寫作內容：${content}
                教學筆記：${note}
                閱卷員評分取向：${reviewerNote}`;
                
                const [originalApiResponse, llama3ApiResponse] = await Promise.all([callAPI(prompt, 0), callLlama3API(prompt, 0)]);
                
                // 設定聊天室上下文
                currentContextContent = content;
                currentContextReview = originalApiResponse; 

                // 生成評分報告 (displayFullCommentWithGrading 內部會自動加入一個聊天室)
                await displayFullCommentWithGrading('writingGradingResult', originalApiResponse, llama3ApiResponse, 'narrative', content);
                
          

            } else {
                // 聚焦式點評 (改用 Canvas 顯示並加入 Chat)
                showLoading(`${currentReviewerName} 正在點評...`); 

                const scopeDefinitions = `
- **扣題**: 嚴謹地對比題目《${topic}》及文章內容，點評文章在情節和主旨上是否緊密圍繞題目關鍵詞展開。
- **立意**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再評估文章的主題思想是否深刻、新穎。
- **取材**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再檢視所選取的事例、情節是否典型、生動、具體。
- **詳略**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再分析文章的敘事節奏，核心情節是否得到充分的細節描寫。
- **文筆**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再評論文章的語言運用是否精準、生動，遣詞造句是否流暢。
`;

                let scopeInstruction = `
你是一名高度專業的寫作分析員，你的任務極其專一。
---
### **黃金法則**
你必須嚴格遵守此法則，不得有任何例外：
1.  **絕對聚焦**: 你的點評和建議中的 **每一個字**，都必須 **僅僅** 與用戶選擇的以下範疇相關：**【${selectedScopes.join("、")}】**。
2.  **明確禁止**: 你被 **嚴格禁止** 提及任何其他寫作方面。
3.  **後果**: 如果你的回應中包含了任何未被選定的範疇，整個回應將被視為失敗。

### **各範疇的定義**
${scopeDefinitions}
---`;

                let toneInstruction = "請使用嚴肅正經的語氣。";
                if (tone === "chen") {
                    toneInstruction = `請用幽默詼諧、適時揶揄的語氣進行點評和建議，**必須使用大量Emoji** (如 😎, 🔥, 👎)，表示揶揄時會用🤌這個EMOJI，就像陳SIR在跟學生面對面說話一樣。`;
                }

                prompt = `${toneInstruction}
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[在建議部分，同樣要遵循「黃金法則」。如果所選範疇表現優秀，你可以說「在這方面處理得很好，沒什麼好建議了，繼續保持吧！😎」。]
</suggestions>
---
### **待點評的資料**
題目：${topic}
寫作內容：${content}`;

                const response = await callAPI(prompt, 0);
                
                currentContextContent = content;
                currentContextReview = response;

                const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
                const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
                let initialReviewHTML = `<h3>${currentReviewerName}聚焦點評：</h3>`;
                
                if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
                if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
                
                if (!critiqueMatch && !suggestionsMatch) {
                    initialReviewHTML += "<p>抱歉，無法生成點評。</p>";
                }

                openResultCanvas("聚焦點評結果");
                const resultBody = document.getElementById("resultCanvasBody");
                
                // ★★★ 手動追加 Chat ★★★
                resultBody.innerHTML = initialReviewHTML + getCanvasChatHTML('narrative_writing');
                
              
            }
        }
    } catch (error) {
        console.error("提交寫作時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : (error.message || "點評生成失敗，請重試"));
    } finally {
        submitBtn.disabled = false;
        hideLoading();
    }
}


// 輔助函式，用於顯示大綱的評論 (從 submitWriting 中提取出來)
// 輔助函式，用於顯示大綱的評論 (敘事抒情 - V3)
function displayOutlineComment(response, content) {
    const sections = response.split(/=== (.+?) ===/).filter(s => s.trim());
    const commentIndex = sections.indexOf("點評及建議");
    const rewriteIndex = sections.indexOf("改寫後的大綱");
    const explanationIndex = sections.indexOf("改寫說明");
    const commentPart = commentIndex !== -1 ? sections[commentIndex + 1] : "";
    const rewritePart = rewriteIndex !== -1 ? sections[rewriteIndex + 1] : "";
    const explanationPart = explanationIndex !== -1 ? sections[explanationIndex + 1].trim() : "";

    function parseCommentPart(commentPart) {
        const comments = {};
        const regex = /\[(.+?)\]\s*點評：\s*(.+?)(?=\s*建議：|\s*\[|$)/gs;
        const suggestionRegex = /\[(.+?)\]\s*點評：.+?\s*建議：\s*(.+?)(?=\s*\[|$)/gs;
        let match;
        while ((match = regex.exec(commentPart)) !== null) {
            const part = match[1];
            comments[part] = comments[part] || {};
            comments[part].comment = match[2].trim();
        }
        while ((match = suggestionRegex.exec(commentPart)) !== null) {
            const part = match[1];
            comments[part] = comments[part] || {};
            comments[part].suggestion = match[2].trim();
        }
        return comments;
    }

    function parseRewritePart(rewritePart) {
        const rewrites = {};
        const regex = /\[(.+?)\]\s*結構段重點：\s*(.+?)(?=\s*情節大要：|\s*\[|$)/gs;
        const plotRegex = /\[(.+?)\]\s*結構段重點：.+?\s*情節大要：\s*(.+?)(?=\s*\[|$)/gs;
        let match;
        while ((match = regex.exec(rewritePart)) !== null) {
            const part = match[1];
            rewrites[part] = rewrites[part] || {};
            rewrites[part].focus = match[2].trim();
        }
        while ((match = plotRegex.exec(rewritePart)) !== null) {
            const part = match[1];
            rewrites[part] = rewrites[part] || {};
            rewrites[part].plot = match[2].trim();
        }
        return rewrites;
    }
    const comments = parseCommentPart(commentPart);
    const rewrites = parseRewritePart(rewritePart);

    let commentTableHTML = `<h3>陳SIR點評及建議：</h3><div class="table-container"><table id="commentTable"><tr><th style="width:10%;">部份</th><th style="width:15%;">結構段重點</th><th style="width:20%;">情節大要</th><th style="width:27.5%;">點評</th><th style="width:27.5%;">建議</th></tr>`;
    content.forEach(item => {
        const comment = comments[item.part]?.comment || "未生成點評";
        const suggestion = comments[item.part]?.suggestion || "未生成建議";
        commentTableHTML += `<tr><td>${item.part}</td><td>${item.focus}</td><td>${item.plot}</td><td>${comment}</td><td>${suggestion}</td></tr>`;
    });
    commentTableHTML += "</table></div>";

    let rewriteTableHTML = `<h3>改寫後的大綱：</h3><div class="table-container"><table id="rewriteTable"><tr><th style="width:15%;">部份</th><th style="width:42.5%;">結構段重點</th><th style="width:42.5%;">情節大要</th></tr>`;
    content.forEach(item => {
        const rewrite = rewrites[item.part] || { focus: "未生成結構段重點", plot: "未生成情節大要" };
        rewriteTableHTML += `<tr><td>${item.part}</td><td>${rewrite.focus || "未生成結構段重點"}</td><td>${rewrite.plot || "未生成情節大要"}</td></tr>`;
    });
    rewriteTableHTML += "</table></div>";

    let explanationHTML = '';
    if (explanationPart) {
        const points = explanationPart.split(/\s*(?=\d\.\s*)/).filter(p => p.trim());
        explanationHTML = `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫說明</h3>`;
        points.forEach(point => {
            const match = point.match(/^(\d)\.\s*(.*)$/s);
            if (match) {
                const number = match[1];
                const text = match[2];
                explanationHTML += `<div class="explanation-point"><div class="explanation-number">${number}</div><div class="explanation-text">${text}</div></div>`;
            }
        });
        explanationHTML += `</div></div>`;
    }
    
    openResultCanvas("敘事大綱點評結果");
    const resultContainer = document.getElementById("resultCanvasBody");
    resultContainer.innerHTML = commentTableHTML + rewriteTableHTML + explanationHTML + getCanvasChatHTML('narrative_outline');
}

// 替換舊的 submitReading 函式 (修正歷史紀錄儲存問題)
async function submitReading() {
    const submitBtn = document.getElementById('submitReadingBtn');
    submitBtn.disabled = true; 
    hideAllSaveHtmlButtons();

    let readingFunction = "";
    let passage = "";
    let question = "";
    let studentAnswer = "";
    let finalHTML = ""; 
    let guideHTML = ""; 

    try {
        readingFunction = document.getElementById("readingFunction").value;
        passage = document.getElementById("readingPassage").value.trim();
        question = document.getElementById("readingQuestion").value.trim();

        if (readingFunction === "comment") {
            studentAnswer = document.getElementById("studentAnswer").value.trim();
            if (!passage || !question || !studentAnswer) {
                alert("請填寫所有閱讀輸入");
                return;
            }
            // 設定聊天室上下文 (點評)
            currentContextContent = `篇章：${passage.substring(0, 100)}...\n題目：${question}\n答案：${studentAnswer}`;
        } else {
            if (!passage || !question) {
                alert("請填寫閱讀篇章和題目");
                return; 
            }
            // 設定聊天室上下文 (指引)
            currentContextContent = `篇章：${passage.substring(0, 100)}...\n題目：${question}`;
        }

        let toneNote = "";
        if (readingFunction === "comment") {
            const tone = document.getElementById("readingTone").value;
            if (tone === "chen") {
                toneNote = "請用輕鬆隨意的語氣進行點評，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。";
            } else {
                toneNote = "請用嚴肅正經的語氣進行點評。";
            }
        }

        const note = readingFunction === "comment" ? categories["閱讀"].commentNote : categories["閱讀"].guideNote;

        let prompt = "";
        if (readingFunction === "comment") {
            prompt = `請根據以下閱讀篇章、題目和學生的答案進行點評。要求：
1. 評估答題方向是否合理
2. 評估文本依據是否充實具體
3. 評估闡釋推論是否嚴謹
4. 評估主題句是否清晰
5. 在「### 點評」部分，請務必以數字編號的列點方式臚列你的評論，每個點評另起新行。你可以根據文章內容提出任意數量的點評，必須超過一點，但絕對不得超過三點，每點字數不要太長。
6. 在「### 答題步驟及思路」中，描述各部分方向，步驟因題制宜，不超出120字。只有【鋪墊】、【主題句】、【文本依據】、【闡釋】四種標題，每個步驟之間都必須隔兩行空行，步驟中不得列點。
7. 在「### 改寫範例」中，提供改寫後的答案，使答案更圓足（若答題方向錯誤，則不跟從錯誤方向）
8. 不要使用任何表格或Markdown格式。
9. 輸出分為三個部分：### 點評、### 答題步驟及思路、### 改寫範例
閱讀篇章：${passage}
題目：${question}
學生的答案：${studentAnswer}
教學筆記：${note}
點評語氣：${toneNote}`;
        } else { // guide
            prompt = `請根據以下閱讀篇章和題目生成答題指引。要求：
1. 輸出必須包含「### 答題指引」和「### 答題詞匯」兩個部分。
2. 在「### 答題指引」部分，請生成三道引導性問題，每道問題都以數字和句號（例如「1.」）開頭，並另起新行。
3. 在「### 答題詞匯」部分，生成十五個由兩個字構成的相關詞彙，每個詞彙另起新行。
4. 所有內容均以純文字列表形式呈現，不要使用任何表格或Markdown格式。
閱讀篇章：${passage}
題目：${question}
教學筆記：${note}`;
        }

        showLoading("陳SIR 正在分析篇章...");
        const result = await callReadingAPI(prompt);
        currentContextReview = result; // 儲存 AI 回應供聊天室使用

        if (readingFunction === "comment") {
            const parts = result.split("###").map(part => part.trim()).filter(part => part);
            finalHTML = "<h3>陳SIR點評：</h3>";

            parts.forEach(part => {
                const lines = part.split("\n").filter(line => line.trim());
                const title = lines.shift() || "";
                const content = lines.join("\n");

                if (title.includes("點評")) {
                    finalHTML += createBulletedListHTML(title, content);
                } 
                else if (title.includes("答題步驟及思路")) {
                    finalHTML += `<div class="rewrite-explanation-container">
                    <div class="rewrite-explanation-card">
                    <h3>${title}</h3>
                    <div class="steps-container">`;
                    const steps = content.split(/\s*(?=【.*?】)/).filter(s => s.trim());
                    steps.forEach(stepText => {
                        const match = stepText.match(/^(【.*?】)(.*)$/s);
                        if (match) {
                            const stepTitle = match[1].trim();
                            const stepContent = match[2].trim().replace(/\n/g, '<br>');
                            finalHTML += `<div class="step-card">
                            <div class="step-title">${stepTitle}</div>
                            <div class="step-content">${stepContent}</div>
                            </div>`;
                        }
                    });
                    finalHTML += `</div></div></div>`;
                }
                else if (title.includes("改寫")) {
                    const cleanContent = content.replace(/\*/g, '');
                    finalHTML += `<div class="rewrite-explanation-container">
                        <div class="rewrite-explanation-card">
                            <h3>${title}</h3>
                            <div class="rewrite-content">${cleanContent.replace(/\n/g, '<br>')}</div>
                        </div>
                    </div>`;
                }
                else {
                    finalHTML += `<div class="rewrite-explanation-container">
                    <div class="rewrite-explanation-card">
                    <h3>${title}</h3>
                    <div class="explanation-text">${content.replace(/\n/g, '<br>')}</div>
                    </div>
                    </div>`;
                }
            });
            
            // ★★★ 加入聊天室 (點評) ★★★
            finalHTML += getCanvasChatHTML('reading_comment');

            openResultCanvas("閱讀理解點評");
            document.getElementById("resultCanvasBody").innerHTML = finalHTML;
            
            // 儲存時移除聊天室 HTML
            const historyHTML = finalHTML.split('<div class="canvas-chat-container">')[0];
            saveToHistory("閱讀", "點評", question, `篇章：${passage}\n題目：${question}\n答案：${studentAnswer}`, historyHTML);
         

        } else { // guide
            const guideParts = result.split("###").map(part => part.trim()).filter(part => part);
            guideHTML = "<h3>陳SIR指引：</h3>";

            guideParts.forEach(part => {
                const lines = part.split("\n").filter(line => line.trim());
                const title = lines.shift() || "";
                
                guideHTML += `<div class="rewrite-explanation-container">
                <div class="rewrite-explanation-card">
                <h3>${title}</h3>`;

                if (title.includes("答題指引")) {
                    lines.forEach((item, index) => {
                        const match = item.match(/^(\d+)\.?\s*(.*)$/);
                        const number = match ? match[1] : index + 1;
                        const text = match ? match[2].trim() : item;
                        guideHTML += `<div class="explanation-point">
                        <div class="explanation-number">${number}</div>
                        <div class="explanation-text">${text}</div>
                        </div>`;
                    });
                    guideHTML += `</div></div>`;
                } 
                else if (title.includes("答題詞匯")) {
                    guideHTML += `<div class="vocab-grid">`;
                    lines.forEach(item => {
                        const cleanItem = item.replace(/^\d+\.|^-\s*/, '').trim();
                        if (cleanItem) {
                            guideHTML += `<div class="vocab-item">${cleanItem}</div>`;
                        }
                    });
                    guideHTML += `</div></div></div>`;
                } else {
                    guideHTML += `<p class="explanation-text">${lines.join('<br>')}</p></div></div>`;
                }
            });
            
            // ★★★ 加入聊天室 (指引) ★★★
            guideHTML += getCanvasChatHTML('reading_guide');

            openResultCanvas("閱讀理解指引");
            document.getElementById("resultCanvasBody").innerHTML = guideHTML;
            
            // 儲存時移除聊天室 HTML
            const historyHTML = guideHTML.split('<div class="canvas-chat-container">')[0];
            saveToHistory("閱讀", "指引", question, `篇章：${passage}\n題目：${question}`, historyHTML);
            document.getElementById('save-reading-html-btn').style.display = 'flex';
        }

    } catch (error) {
        console.error("提交閱讀時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : "生成失敗，請重試");
    } finally {
        submitBtn.disabled = false;
        hideLoading();
    }
}

// 課外書籍討論功能
let chatHistory = [];
let bookTitle = "";
let author = "";
let discussionQuestion = "";
let booksTone = "";

// 將訊息渲染到畫面上
function renderMessage(sender, message) {
const chatHistoryDiv = document.getElementById("chatHistory");
const element = document.createElement("div");

if (sender === "info") {
element.className = "discussion-info";
element.innerHTML = message;
} else {
element.className = `message-bubble ${sender}-message`;
element.innerHTML = message; // innerHTML to render formatted text
if (sender === "ai" && message === "陳SIR正在回應...") {
element.id = "ai-loading";
}
}
chatHistoryDiv.appendChild(element);
chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
}

// 將訊息加入歷史紀錄並渲染
function addMessageToHistory(sender, message) {
chatHistory.push({ sender, message });
renderMessage(sender, message);
}


async function startDiscussion() {
const startBtn = document.getElementById('startDiscussionBtn');
startBtn.disabled = true;

try {
bookTitle = sanitizeHTML(document.getElementById("bookTitle").value.trim());
author = sanitizeHTML(document.getElementById("author").value.trim());
discussionQuestion = sanitizeHTML(document.getElementById("discussionQuestion").value.trim());
booksTone = document.getElementById("booksTone").value;

if (!bookTitle || !author || !discussionQuestion) {
alert("請填寫書名、作者和討論問題");
return;
}

// 隱藏初始表單，顯示聊天介面
document.getElementById("initialDiscussionForm").style.display = "none";
document.getElementById("chatHistory").style.display = "flex";
document.getElementById("chatInputContainer").style.display = "flex";
document.getElementById("booksButtons").style.display = "flex";



chatHistory = []; // 開始新討論時清空歷史紀錄

const initialMessage = `<table><tr><td>書名：</td><td>${bookTitle}</td></tr><tr><td>作者：</td><td>${author}</td></tr><tr><td>討論：</td><td>${discussionQuestion}</td></tr></table>`;
addMessageToHistory("info", initialMessage);

await sendInitialMessage();

} catch (error) {
console.error("開始討論時出錯:", error);
} finally {
startBtn.disabled = false;
}
}

async function sendInitialMessage() {
let toneNote = booksTone === "serious" ? categories["課外書籍"].seriousChatNote : categories["課外書籍"].chatNote;
const prompt = `我是一位高中生，正在閱讀《${bookTitle}》，作者是${author}。我想討論的問題是：${discussionQuestion}。請用日常的語言回應我，不要過於理論化，言簡意賅地分析並給出例子，然後引導我深入思考。你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。。請不要使用括號解釋你的目的，永遠不要列點回應，也不要提及你會追問我。請用完整句子回應。每次回應不多於150字。教學筆記：${toneNote}`;
addMessageToHistory("ai", "陳SIR正在回應...");
try {
const aiResponse = await callReadingAPI(prompt);
updateLastAIMessage(aiResponse);
} catch (error) {
console.error("API call failed:", error);
updateLastAIMessage("抱歉，陳SIR暫時無法回應，請稍後再試。");
}
}


// =================================================================================
// === 請複製此處開始的完整函數 ===
// =================================================================================
async function continueArgumentDiscussion() {
    const continueBtn = document.getElementById('continueArgumentBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("argumentUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const chatHistoryDiv = document.getElementById('argumentChatHistory');
    
    // 1. 顯示使用者訊息
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    chatHistoryDiv.appendChild(userMessageBubble);
    
    // 2. 將使用者訊息存入歷史紀錄
    argumentChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("argumentUserInput").value = "";
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 3. 顯示「正在回應」
    const aiLoadingBubble = document.createElement('div');
    aiLoadingBubble.className = 'message-bubble ai-message';
    aiLoadingBubble.textContent = `${currentReviewerName}正在回應...`;
    chatHistoryDiv.appendChild(aiLoadingBubble);
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 4. 準備完整的對話歷史給 AI
    const conversationHistoryForPrompt = argumentChatHistoryData.map(item => {
        const speaker = item.sender === 'user' ? '我的追問' : '你的上一輪回應';
        // 清理 message 中的 HTML 標籤，讓 prompt 更乾淨
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = item.message;
        const cleanMessage = tempDiv.textContent || tempDiv.innerText || "";
        return `${speaker}: ${cleanMessage}`;
    }).join('\n---\n');


    const tone = document.getElementById("argumentWritingTone").value;
    let toneNote = tone === "chen" ? categories["課外書籍"].chatNote : categories["課外書籍"].seriousChatNote;
    
    // 5. 建立包含完整上下文的 Prompt
    const prompt = `我是一位高中生，你正在點評我的議論文。
    ---
    我的原文：
    ${currentArgumentArticle}
    ---
    這是我們到目前為止的完整對話紀錄：
    ${conversationHistoryForPrompt}
    ---
    請針對我最新的追問，用日常的語言簡潔地回應我，不要過於理論化，必須詳細分析並給出例子。請不要使用括號解釋你的目的。回應字數不要超過180字。
    教學筆記：${toneNote}`;
    
    try {
        const aiResponse = await callReadingAPI(prompt);
        
        // 6. 更新 AI 回應並存入歷史紀錄
        // 步驟一：將 Markdown 的 **粗體** 語法轉換為 HTML 的 <strong> 標籤
let formattedResponse = aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

// 步驟二：處理換行符
formattedResponse = formattedResponse.replace(/\n/g, '<br>');

// 步驟三：將處理好的 HTML 內容放入聊天氣泡
aiLoadingBubble.innerHTML = formattedResponse;
        argumentChatHistoryData.push({ sender: 'ai', message: aiResponse });

    } catch (error) {
        console.error("繼續議論文討論時出錯:", error);
        aiLoadingBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，${currentReviewerName}無法回應。😅`;
    } finally {
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        continueBtn.disabled = false;
    }
}
// =================================================================================
// === 請複製到此處結束 ===
// =================================================================================


// 【新增】處理文章點評後續討論的函數
async function continueWritingDiscussion() {
    const continueBtn = document.getElementById('continueWritingBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("writingUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const writingChatHistoryDiv = document.getElementById('writingChatHistory');
    
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    writingChatHistoryDiv.appendChild(userMessageBubble);
    
    writingChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("writingUserInput").value = "";
    writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;

    const tone = document.getElementById("writingTone").value;
    let toneNote = tone === "chen" ? categories["課外書籍"].chatNote : categories["課外書籍"].seriousChatNote;
    
    const prompt = `我是一位高中生，你剛剛點評了我的文章。
    ---
    我的原文：${currentWritingArticle}
    ---
    你的上一輪點評：${currentWritingReview}
    ---
    我的追問是：${userInputText}
    ---
    請針對我的追問，用日常的語言回應我，不要過於理論化，必須詳細分析並給出例子，然後引導我深入思考。請不要使用括號解釋你的目的，也不要提及你會追問我。請用完整句子回應。回應字數不要超過180字。
    教學筆記：${toneNote}`;
    
    // 顯示「正在回應」
    const aiMessageBubble = document.createElement('div');
    aiMessageBubble.className = 'message-bubble ai-message';
    // --- 【核心修訂】使用全域變數來顯示動態名稱 ---
    aiMessageBubble.textContent = `${currentReviewerName}正在回應...`;
    writingChatHistoryDiv.appendChild(aiMessageBubble);
    writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;

    try {
        const aiResponse = await callReadingAPI(prompt);
        
        aiMessageBubble.innerHTML = aiResponse.replace(/\n/g, '<br>');
        writingChatHistoryData.push({ sender: 'ai', message: aiResponse });

    } catch (error) {
        console.error("繼續討論時出錯:", error);
        aiMessageBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，${currentReviewerName}無法回應。😅`;
    } finally {
        writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;
        continueBtn.disabled = false;
    }
}


async function continueDiscussion() {
const continueBtn = document.getElementById('continueBtn');
continueBtn.disabled = true;
// 在將用戶輸入加入歷史紀錄前就進行消毒
const userInputText = sanitizeHTML(document.getElementById("userInput").value.trim());
if (!userInputText) {
alert("請輸入您的回應");
continueBtn.disabled = false;
return;
}

addMessageToHistory("user", userInputText);
document.getElementById("userInput").value = "";

let toneNote = booksTone === "serious" ? categories["課外書籍"].seriousChatNote : categories["課外書籍"].chatNote;
const prompt = `我是一位高中生，正在與你討論《${bookTitle}》中的問題。我的上一條信息是：${userInputText}。請用日常的語言回應我，不要過於理論化，必須詳細分析並給出例子，然後引導我深入思考。你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。。請不要使用括號解釋你的目的，也不要提及你會追問我。請用完整句子回應。回應字數不要超過180字。教學筆記：${toneNote}`;

addMessageToHistory("ai", "陳SIR正在回應...");

try {
const aiResponse = await callReadingAPI(prompt);
updateLastAIMessage(aiResponse);
} catch (error) {
console.error("繼續討論時出錯:", error);
updateLastAIMessage(error.message === "所有 API 密鑰均無法使用" ? "今日 API 調用次數已用完。😓" : "抱歉，陳SIR無法回應。😅");
} finally {
continueBtn.disabled = false;
}
}

// --- 新增：處理彈出視窗的邏輯 ---
const newTopicModal = document.getElementById('newTopicModal');
const newTopicBtn = document.getElementById('newTopicBtn');
const closeNewTopicModal = document.getElementById('closeNewTopicModal');
const modalStartDiscussionBtn = document.getElementById('modalStartDiscussionBtn');

newTopicBtn.addEventListener('click', () => {
newTopicModal.style.display = 'flex';
});

closeNewTopicModal.addEventListener('click', () => {
newTopicModal.style.display = 'none';
});

window.addEventListener('click', (event) => {
if (event.target == newTopicModal) {
newTopicModal.style.display = 'none';
}
});

modalStartDiscussionBtn.addEventListener('click', async () => {
const newBookTitle = document.getElementById("modalBookTitle").value.trim();
const newAuthor = document.getElementById("modalAuthor").value.trim();
const newDiscussionQuestion = document.getElementById("modalDiscussionQuestion").value.trim();

if (!newBookTitle || !newAuthor || !newDiscussionQuestion) {
alert("請填寫所有欄位");
return;
}

// 更新全域變數
bookTitle = newBookTitle;
author = newAuthor;
discussionQuestion = newDiscussionQuestion;

// 清空舊的聊天歷史和 UI
document.getElementById("chatHistory").innerHTML = '';
chatHistory = [];

// 添加新的書籍資訊卡片
const initialMessage = `<table><tr><td>書名：</td><td>${bookTitle}</td></tr><tr><td>作者：</td><td>${author}</td></tr><tr><td>討論：</td><td>${discussionQuestion}</td></tr></table>`;
addMessageToHistory("info", initialMessage);

// 關閉彈出視窗
newTopicModal.style.display = 'none';

// 清空彈出視窗的輸入
document.getElementById("modalBookTitle").value = '';
document.getElementById("modalAuthor").value = '';
document.getElementById("modalDiscussionQuestion").value = '';

// 發送初始訊息
await sendInitialMessage();
});


// =================================================================================
// === 【全新】點評範疇 UI/UX 互動邏輯 ===
// =================================================================================
function setupScopeUI(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const allCheckbox = container.querySelector('input[value="全部"]');
    const otherCheckboxes = container.querySelectorAll('input:not([value="全部"])');

    // 負責更新所有標籤樣式的核心函數
    const updateUI = () => {
        // 更新 "全部" 標籤的樣式
        const allLabel = allCheckbox.parentElement;
        if (allCheckbox.checked) {
            allLabel.classList.add('active');
        } else {
            allLabel.classList.remove('active');
        }

        // 更新其他所有標籤的樣式
        otherCheckboxes.forEach(cb => {
            const label = cb.parentElement;
            if (cb.checked) {
                label.classList.add('active');
            } else {
                label.classList.remove('active');
            }

            if (cb.disabled) {
                label.classList.add('disabled');
            } else {
                label.classList.remove('disabled');
            }
        });
    };

    // 為 "全部" 複選框添加事件監聽
    allCheckbox.addEventListener('change', () => {
        if (allCheckbox.checked) {
            // 如果 "全部" 被選中，取消選中並禁用其他所有選項
            otherCheckboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
            });
        } else {
            // 如果 "全部" 被取消選中，啟用其他所有選項
            otherCheckboxes.forEach(cb => {
                cb.disabled = false;
            });
        }
        updateUI(); // 更新介面
    });

    // 為其他複選框添加事件監聽
    otherCheckboxes.forEach(cb => {
        cb.addEventListener('change', () => {
            // 如果任何一個其他選項被選中，則取消選中 "全部"
            if (cb.checked) {
                allCheckbox.checked = false;
            }
            updateUI(); // 更新介面
        });
    });
    
    // 頁面加載時，立即根據初始狀態更新一次UI
    updateUI();
}

// 在 DOM 加載完成後，為兩個點評範疇區塊初始化 UI 邏輯
document.addEventListener('DOMContentLoaded', () => {
    setupScopeUI('reviewScopeArea');
    setupScopeUI('argumentReviewScopeArea');
});
	

// 替換舊的 generateExpandTopic 函式
async function generateExpandTopic(buttonElement) {
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

// 隱藏自訂題目輸入區，確保介面乾淨
const customTopicArea = document.getElementById("expandCustomTopicInputArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("expandTopicResult");
const prompt = categories["整合拓展"].topicPrompt;

topicResult.innerHTML = "陳SIR正在出題...";
topicResult.style.display = 'block';

try {
const topic = await callAPI(prompt);
const lines = topic.split("\n").map(line => line.trim()).filter(line => line);
const themeMatch = lines.find(line => line.startsWith("主題句："));
const dataMatch = lines.find(line => line.startsWith("抄錄資料："));
if (!themeMatch || !dataMatch) throw new Error("API 回應格式不正確");
const theme = themeMatch.replace("主題句：", "").trim();
const data = dataMatch.replace("抄錄資料：", "").trim();
if (!theme || !data) throw new Error("生成內容不完整");

topicResult.innerHTML = `
<div class="table-container">
<table>
<tr><th>主題句</th><th>抄錄資料</th></tr>
<tr><td>${theme}</td><td>${data}</td></tr>
</table>
</div>
`;
localStorage.setItem("expandCurrentTheme", theme);
localStorage.setItem("expandCurrentData", data);
// 清除可能存在的自訂題目 Title
localStorage.removeItem("expandCurrentTitle");

} catch (error) {
console.error("生成整合拓展題目時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("生成題目時出錯，請重試");
}
topicResult.innerHTML = "";
topicResult.style.display = 'none';
}
}


// 替換舊的 setExpandCustomTopic 函式
function setExpandCustomTopic() {
const title = sanitizeHTML(document.getElementById("expandCustomTitle").value.trim());
const theme = sanitizeHTML(document.getElementById("expandCustomTheme").value.trim());
const data = sanitizeHTML(document.getElementById("expandCustomData").value.trim());
if (!title || !theme || !data) {
alert("請輸入所有內容（題目、主題句、抄錄資料）");
return;
}

const topicResult = document.getElementById("expandTopicResult");
topicResult.innerHTML = `
<strong>題目：${title}</strong>
<div class="table-container">
<table>
<tr><th>主題句</th><th>抄錄資料</th></tr>
<tr><td>${theme}</td><td>${data}</td></tr>
</table>
</div>
`;

topicResult.style.display = 'block';

localStorage.setItem("expandCurrentTitle", title);
localStorage.setItem("expandCurrentTheme", theme);
localStorage.setItem("expandCurrentData", data);

// 確認後，隱藏並清空輸入區域
const customTopicArea = document.getElementById("expandCustomTopicInputArea");
customTopicArea.style.display = 'none';
customTopicArea.innerHTML = '';
}

// 更新字數計數
function updateCharCount() {
const content = document.getElementById("expandContent").value;
const remaining = 180 - content.length;
document.getElementById("charCount").textContent = `剩餘字數：${remaining >= 0 ? remaining : 0}`;
if (remaining < 0) {
document.getElementById("expandContent").value = content.substring(0, 180);
}
}

// ★★★ 請將補回的代碼貼在這裡 ★★★
async function submitExpand() {
    const expandFunction = document.getElementById("expandFunction").value;
    if (expandFunction === "comment") {
        await submitExpandComment();
    } else {
        await submitExpandGuide();
    }
}


// 提交整合拓展內容
async function submitExpandComment() {
    const submitBtn = document.getElementById('submitExpandBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    try {
        const title = localStorage.getItem("expandCurrentTitle");
        const theme = localStorage.getItem("expandCurrentTheme");
        const data = localStorage.getItem("expandCurrentData");
        const content = document.getElementById("expandContent").value.trim();
        
        if (!theme || !data || !content) {
            alert("請先設定題目並輸入整合拓展內容");
            return;
        }

        const tone = document.getElementById("expandTone").value;
        let toneNote = "";
        if (tone === "chen") {
            toneNote = "請用幽默詼諧、適時揶揄的語氣回應，**必須使用大量Emoji** 🤪✨，表示揶揄時會用🤌這個EMOJI，偶爾用網絡用語。"; // (省略部分以節省長度，保持原意)
        } else {
            toneNote = "請用嚴肅正經的語氣進行點評。";
        }

        const note = categories["整合拓展"].commentNote;
        const prompt = `請根據以下內容進行點評... (省略 prompt 內容，保持不變) ...
題目：${title || "無"}
主題句：${theme}
抄錄資料：${data}
整合拓展：${content}
教學筆記：${note}
點評語氣：${toneNote}`;

        showLoading("陳SIR 正在審視拓展方向...");
        const comment = await callAPI(prompt);
        
        // 設定聊天室上下文
        currentContextContent = `題目：${title}\n主題句：${theme}\n抄錄資料：${data}\n內容：${content}`;
        currentContextReview = comment;

        const commentParts = comment.split("###").map(part => part.trim()).filter(part => part);
        
        let finalHTML = "<h3>陳SIR點評：</h3>";
        
        commentParts.forEach(part => {
            const lines = part.split("\n").filter(line => line.trim());
            const sectionTitle = lines.shift() || "";
            const sectionContent = lines.join("\n");

            if (sectionTitle.includes("點評") || sectionTitle.includes("建議")) {
                finalHTML += createBulletedListHTML(sectionTitle, sectionContent);
            } else {
                const cleanContent = sectionContent.replace(/\*/g, '');
                finalHTML += `<div class="rewrite-explanation-container">
                    <div class="rewrite-explanation-card">
                        <h3>${sectionTitle}</h3>
                        <div class="rewrite-content">${cleanContent.replace(/\n/g, '<br>')}</div>
                    </div>
                </div>`;
            }
        });

        // ★★★ 加入聊天室 ★★★
        finalHTML += getCanvasChatHTML('expand_comment');

        openResultCanvas("整合拓展點評");
        document.getElementById("resultCanvasBody").innerHTML = finalHTML;
        
        // 儲存時移除聊天室 HTML
        const historyHTML = finalHTML.split('<div class="canvas-chat-container">')[0];
        saveToHistory("整合拓展", "點評", title, `題目：${title}\n主題句：${theme}\n抄錄資料：${data}\n內容：${content}`, historyHTML);
        
       

    } catch (error) {
        console.error("提交整合拓展點評時出錯:", error);
        alert("點評生成失敗，請重試");
    } finally {
        submitBtn.disabled = false;
        hideLoading();
    }
}


	
// 【修訂後】提交整合拓展指引
async function submitExpandGuide() {
    const submitBtn = document.getElementById('submitExpandGuideBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    try {
        const title = document.getElementById("expandGuideTitle").value.trim();
        const theme = document.getElementById("expandGuideTheme").value.trim();
        const data = document.getElementById("expandGuideData").value.trim();
        const expand = document.getElementById("expandGuideExpand").value.trim();
        
        if (!title || !theme || !data || !expand) {
            alert("請填寫所有輸入");
            return; 
        }

        const note = categories["整合拓展"].guideNote;
        const prompt = `請根據以下內容生成指引問題。要求：
1. 生成三道問題以引導用家思考如何根據表格資料做好整合拓展
2. 問題應圍繞主題句和抄錄資料的邏輯關係，引導用家思考如何闡釋和拓展
3. 輸出分為一個部分：### 指引問題
4. 指引問題以問題形式呈現，每個問題佔一行
題目：${title}
主題句：${theme}
抄錄資料：${data}
整合拓展：${expand}
教學筆記：${note}`;

        showLoading("陳SIR 正在思考指引...");
        
        // 呼叫 API
        const guide = await callAPI(prompt);
       // 設定聊天室上下文
        currentContextContent = `題目：${title}\n主題句：${theme}\n抄錄資料：${data}\n內容：${expand}`;
        currentContextReview = guide;

        const guideParts = guide.split("###").map(part => part.trim()).filter(part => part);
        let guideHTML = "<h3>陳SIR指引：</h3>";

        guideParts.forEach(part => {
            const lines = part.split("\n").filter(line => line.trim());
            const sectionTitle = lines.shift() || "指引問題";
            const questions = lines;

            guideHTML += `<div class="rewrite-explanation-container">
            <div class="rewrite-explanation-card">
            <h3>${sectionTitle}</h3>`;

            questions.slice(0, 3).forEach((question, index) => {
                const match = question.match(/^(\d+)\.?\s*(.*)$/);
                const number = match ? match[1] : index + 1;
                const text = match ? match[2].trim() : question;

                guideHTML += `<div class="explanation-point">
                <div class="explanation-number">${number}</div>
                <div class="explanation-text">${text}</div>
                </div>`;
            });

            guideHTML += `</div></div>`;
        });

        // ★★★ 加入聊天室 ★★★
        guideHTML += getCanvasChatHTML('expand_guide');

        openResultCanvas("整合拓展指引");
        document.getElementById("resultCanvasBody").innerHTML = guideHTML;
        
        // 儲存歷史紀錄 (移除聊天室)
        const historyHTML = guideHTML.split('<div class="canvas-chat-container">')[0];
        saveToHistory("整合拓展", "指引", title, `題目：${title}\n主題句：${theme}\n抄錄資料：${data}\n內容：${expand}`, historyHTML);
        
        

    } catch (error) {
        console.error("提交整合拓展指引時出錯:", error);
        alert("指引生成失敗，請重試");
    } finally {
        submitBtn.disabled = false; 
        hideLoading();
    }
}


// --- JavaScript for Tool 2 (語薈) & Modals ---
let debounceTimer;

const toolDescriptions = {
'sansi': '本工具旨在協助同學練習寫作卷和閱讀卷，並提供課外書籍討論。',
'sansi-v3': '「神思」備用版本，功能與主版本相同。',
'tizi': '由AI擬設閱讀卷及寫作卷的題目，為同學提供源源不絕的應試練習。',
'reading-pieces': '提供AI生成的文學片段，培養同學鑑賞文學的能力。',
'study': '具有根據探究問題生成圖解與文字分析的功能，培養同學深入研討專題的能力。',
'mensyu': '具有AI尋找文言篇章的功能，並輔以語譯及詞解，培養同學鑑賞文言文的能力。',
'wabisabi': '根據同學上傳的圖片，創作具有意境的句子。',
'book-overview': '提供大量書籍的內容概覽，助你快速了解書籍大意，選擇感興趣的讀物。',
'fanshui-narrative': '由AI生成敘事範文，可根據題目創作高質素的敘事文章以供參考。',
'fanshui-argument': '由AI生成議論範文，可根據題目創作結構嚴謹的議論文以供參考。',
'manuscript': '提供電子原稿紙，模擬真實寫作情境，並設有AI答惑功能。',
'words': '設有查考詞義、文章潤色及測驗功能，有助同學累積詞彙，斟字酌句。',
'slideshow': '將同學的文章轉換為幻燈片，以藝術方式展示同學作品。',
'yuyilu-f1': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中一版本。',
'yuyilu-f2': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中二版本。',
'yuyilu-f3': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中三版本。',
'yuyilu-f4': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中四版本。',
'yuyilu-f5': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中五版本。',
'yuyilu-f6': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中六版本。',
'timer': '設有倒計時功能，程式檢測到人聲會重置時計，是專心背書溫習的好幫手。',
'mensyu-2': '文言文翻譯及分析工具，助同學克服古文閱讀的障礙。',
'zhiyun': '以Google Drive建設的雲端平臺，可供用家繳交課業、檢閱繳交紀錄及瀏覽個人課業文件夾，設有自動生成繳交課業紀錄、歸類文件及追收功課的功能。',
'zhuoyu': '可在PDF及圖片檔案右邊作旁批或備註，方便批閱作文或做筆記。',
'quizbuzzer': '一個簡單易用的線上搶答器，適合課堂或活動中使用。',
'ocr': 'i2OCR 是免費的線上光學字元辨識 (OCR) 軟體，可從圖像或PDF文件中提取文字，方便將手寫稿轉為電子檔。',
'epub': '線上電子書(ePub)閱讀器，方便閱讀電子書，無需安裝任何軟件。',
'decibelmeter': '具有量度分貝的功能，專為課堂秩序管理設計。',
'chitutor': 'AI中文聊天室，專為中文學習而設，可以與AI討論各種中文問題。',
'histutor': 'AI歷史聊天室，專為歷史學習而設，可以與AI討論歷史事件和人物。',
'counseling': 'AI輔導聊天室，當同學感到困惑或需要傾訴時，可以在這裡找到慰藉。',
'self-learning': '提供大量自學中文的資源，包括教學影片、佳作及各卷筆記等。',
'lyrics': '一款結合節奏遊戲與歌詞測驗的中文語文工具，透過音樂互動培養同學的詞彙積累、文學鑑賞及語感能力，並支援線上對戰與排行榜，增添樂趣與競爭的學習體驗。',
	'friends': '【僅供創作社成員使用】允許用戶建立群組、匿名交友、投稿作品、留言討論，並透過遊戲互動增進語文學習的樂趣，培養同學的表達與社交能力。',
	'slowreading': '一款專注深度閱讀的工具，使用者可貼上文本並自訂翻頁秒數，系統將自動逐句播放，幫助讀者聚焦內容，提升閱讀的專注力。',
	'pulseqa': '一個簡潔高效的課堂問答計時工具。主持人可創建房間、設置問題與計時，學生則需要按時作答。'
};


function drawConnectors() {
const svg = document.getElementById('connector-svg');
const container = document.getElementById('mind-map');
if (!svg || !container) {
return;
}
svg.innerHTML = '';

if (window.getComputedStyle(container).display === 'none') {
return;
}

const getElementEdge = (el, side = 'top') => {
const rect = el.getBoundingClientRect();
const containerRect = container.getBoundingClientRect();
const center_x = rect.left - containerRect.left + rect.width / 2;
const center_y = rect.top - containerRect.top + rect.height / 2;

switch(side) {
case 'top': return { x: center_x, y: rect.top - containerRect.top };
case 'bottom': return { x: center_x, y: rect.bottom - containerRect.top };
case 'left': return { x: rect.left - containerRect.left, y: center_y };
case 'right': return { x: rect.right - containerRect.left, y: center_y };
default: return {x: center_x, y: center_y};
}
}

const connections = [
{ from: '[data-id="core-ai-node"]', to: '[data-id="foundation-tizi"]', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '[data-id="foundation-explore"]', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="foundation-tizi"]', to: '#writing .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="foundation-tizi"]', to: '#reading .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '#assignments .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '#support .category-title', fromSide: 'bottom', toSide: 'top' }
];

connections.forEach(conn => {
const fromEl = document.querySelector(conn.from);
const toEl = document.querySelector(conn.to);

if (fromEl && toEl) {
const fromPoint = getElementEdge(fromEl, conn.fromSide);
const toPoint = getElementEdge(toEl, conn.toSide);

const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
line.setAttribute('x1', fromPoint.x);
line.setAttribute('y1', fromPoint.y);
line.setAttribute('x2', toPoint.x);
line.setAttribute('y2', toPoint.y);
svg.appendChild(line);
}
});
}

// Listeners for Tool 2 (工具一覽展開邏輯)
document.getElementById('expandToolsBtn2').addEventListener('click', function() {
    // 1. ★★★ 強制關閉其他兩個全螢幕介面 ★★★
    document.getElementById('historyContainer').style.display = 'none';
    document.getElementById('studentCloudModal').style.display = 'none';

    // 2. 顯示語薈
    const container = document.getElementById('toolsContainer2');
    container.style.display = 'flex';
    document.body.style.overflow = 'hidden'; // 鎖定捲動
    document.querySelector('#toolsContainer2 .main-container').classList.add('loaded');
    
    // 3. 按鈕狀態調整
    document.getElementById('homeBtn').style.display = 'none';
    document.getElementById('sideMenuHomeBtn').style.display = 'flex';
    
    // 確保雲端按鈕顯示 (因為離開了雲端介面)
    const cloudBtn = document.getElementById('sideMenuCloudBtn');
    if (cloudBtn) cloudBtn.style.display = 'flex';
    
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(drawConnectors, 100);
});

// 工具一覽關閉邏輯
// 工具一覽關閉邏輯
document.getElementById('closeToolsBtn2').addEventListener('click', function() {
    // 同樣直接呼叫 returnToHome() 以確保主頁被正確還原，不會顯示白畫面
    returnToHome();
});

// '語弈錄' Interactivity for Tool 2
const yuyiluToggleTool2 = document.getElementById('yuyilu-toggle');
const yuyiluGradesTool2 = document.getElementById('yuyilu-grades');

if (yuyiluToggleTool2 && yuyiluGradesTool2) {
yuyiluToggleTool2.addEventListener('click', function(event) {
event.preventDefault();
yuyiluGradesTool2.classList.toggle('collapsed');
setTimeout(drawConnectors, 500);
});
}

// --- Preview Modal & Video Modal Logic ---
const previewModal = document.getElementById('previewModal');
const previewIframe = document.getElementById('previewIframe');
const previewCloseBtn = document.getElementById('previewCloseBtn');
const previewGoToPageBtn = document.getElementById('previewGoToPageBtn');
const previewDescription = document.getElementById('previewDescription');

const videoModal = document.getElementById('videoModal');
const videoIframe = document.getElementById('videoIframe');
const videoTourBtn = document.getElementById('video-tour-btn');

const chartLinks = document.querySelectorAll('#toolsContainer2 .node a:not([href="#"])');

chartLinks.forEach(link => {
link.addEventListener('click', function(event) {
event.preventDefault();
const url = this.getAttribute('href');
const toolId = this.getAttribute('data-tool-id');
const description = toolDescriptions[toolId] || "暫無介紹。";

previewIframe.setAttribute('src', url);
previewGoToPageBtn.setAttribute('href', url);
previewDescription.textContent = description;

previewModal.style.display = 'flex';
});
});

function closePreviewModal() {
previewModal.style.display = 'none';
previewIframe.setAttribute('src', 'about:blank');
}

previewCloseBtn.addEventListener('click', closePreviewModal);


videoTourBtn.addEventListener('click', () => {
videoIframe.src = "https://streamable.com/e/jzhzr1?loop=0&autoplay=1&muted=0";
videoModal.style.display = 'flex';
});

function closeVideoModal() {
videoModal.style.display = 'none';
videoIframe.src = '';
}

videoModal.addEventListener('click', closeVideoModal);


// Redraw connectors on resize
window.addEventListener('resize', () => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(drawConnectors, 100);
});



/// =======================================================
// === 通用懸浮視窗編輯器 (最終版 - 標題修正) ===
// =======================================================
document.addEventListener('DOMContentLoaded', function() {

// --- 為動態生成的「自訂題目」輸入框加上排除標記 (保持不變) ---

const originalShowCustomTopicInput = window.showCustomTopicInput;
window.showCustomTopicInput = function(buttonElement) {
originalShowCustomTopicInput(buttonElement);
const customTopicInput = document.getElementById('customTopic');
if (customTopicInput) {
customTopicInput.classList.add('no-modal-editor');
}
};

const originalShowArgumentCustomTopicInput = window.showArgumentCustomTopicInput;
window.showArgumentCustomTopicInput = function(buttonElement) {
originalShowArgumentCustomTopicInput(buttonElement);
const argumentCustomTopicInput = document.getElementById('argumentCustomTopic');
if (argumentCustomTopicInput) {
argumentCustomTopicInput.classList.add('no-modal-editor');
}
};

const originalShowExpandCustomTopicInput = window.showExpandCustomTopicInput;
window.showExpandCustomTopicInput = function(buttonElement) {
originalShowExpandCustomTopicInput(buttonElement);
const container = document.getElementById('expandCustomTopicInputArea');
if (container) {
container.querySelectorAll('input[type="text"], textarea').forEach(el => el.classList.add('no-modal-editor'));
}
};

// --- 懸浮視窗核心邏輯 (標題生成部分已重寫) ---

const modal = document.getElementById('outline-editor-modal');
const modalTextarea = document.getElementById('modal-textarea');
const modalTitle = document.getElementById('modal-title');
const modalSaveBtn = document.getElementById('modal-save-btn');
const modalCloseBtn = document.getElementById('modal-close-btn');

if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
console.error("懸浮視窗的 HTML 結構不完整或未找到！");
return;
}

let currentEditingElement = null;


// 範文庫資料 (放在這裡以便全域存取)
const textLibrary = {
    "version": "1.0",
    "texts": [
        { "title": "廉頗藺相如列傳", "content": "廉頗者，趙之良將也。趙惠文王十六年 ，廉頗為趙將伐齊 ，大破之，取陽晉，拜為上卿 ，以勇氣聞於諸侯。藺相如者，趙人也，為趙宦者令繆賢舍人 。\n\n趙惠文王時，得楚和氏璧 。秦昭王聞之，使人遺 趙王書，願以十五城請易璧。趙王與大將軍廉頗諸大臣謀：欲予秦，秦城恐不可得，徒見欺 ；欲勿予，即患秦兵之來。計未定，求人可使報秦者 ，未得。\n\n　　宦者令繆賢曰：「臣舍人藺相如可使 。」王問：「何以知之？」對曰：「臣嘗有罪，竊計欲亡走燕 ，臣舍人相如止臣，曰：『君何以知燕王？』臣語 曰：『臣嘗從大王與燕王會境上 ，燕王私握臣手，曰「願結友。」以此知之，故欲往。』相如謂臣曰：『夫趙彊而燕弱，而君幸於趙王 ，故燕王欲結於君。今君乃亡趙走燕，燕畏趙，其勢必不敢留君，而束君歸趙矣 。君不如肉袒伏斧質請罪 ，則幸得脫矣。』臣從其計，大王亦幸赦臣。臣竊以為其人勇士，有智謀，宜可使。」\n\n　　於是王召見，問藺相如曰：「秦王以十五城請易寡人之璧，可予不 ？」相如曰：「秦彊而趙弱，不可不許。」王曰：「取吾璧，不予我城，奈何？」相如曰：「秦以城求璧而趙不許，曲 在趙；趙予璧而秦不予趙城，曲在秦。均之二策 ，寧許以負秦曲 。」王曰：「誰可使者？」相如曰：「王必無人 ，臣願奉璧往使 。城入趙而璧留秦；城不入，臣請完璧歸趙 。」趙王於是遂遣相如奉璧西入秦。\n\n　　秦王坐章台見相如 ，相如奉璧奏秦王 。秦王大喜，傳以示美人及左右 ，左右皆呼萬歲。相如視秦王無意償趙城，乃前曰：「璧有瑕 ，請指示王。」王授璧，相如因持璧，卻立 ，倚柱，怒髮上衝冠 ，謂秦王曰：「大王欲得璧，使人發書至趙王，趙王悉召羣臣議，皆曰：『秦貪，負其彊 ，以空言求璧，償城恐不可得』。議不欲予秦璧。臣以為布衣之交尚不相欺 ，況大國乎！且以一璧之故逆彊秦之驩 ，不可。於是趙王乃齋戒 五日，使臣奉璧，拜送書於庭 。何者？嚴大國之威以修敬也 。今臣至，大王見臣列觀 ，禮節甚倨 ；得璧，傳之美人，以戲弄臣。臣觀大王無意償趙王城邑，故臣復取璧。大王必欲急 臣，臣頭今與璧俱碎於柱矣！」\n\n　　相如持其璧睨 柱，欲以擊柱。秦王恐其破璧，乃辭謝固請 ，召有司案圖 ，指從此以往十五都予趙 。\n\n　　相如度秦王特以詐佯為予趙城 ，實不可得，乃謂秦王曰：「和氏璧，天下所共傳寶也 。趙王恐，不敢不獻。趙王送璧時，齋戒五日，今大王亦宜齋戒五日，設九賓於廷 ，臣乃敢上璧。」秦王度之，終不可彊奪 ，遂許齋五日，舍相如廣成傳 。\n\n　　相如度秦王雖齋，決負約不償城，乃使其從者衣褐 ，懷其璧，從徑道 亡 ，歸璧於趙。\n\n　　秦王齋五日後，乃設九賓禮於廷，引趙使者藺相如。相如至，謂秦王曰：「秦自繆公 以來二十餘君，未嘗有堅明約束者也 。臣誠恐見欺於王而負趙，故令人持璧歸，間至趙矣 。且秦彊而趙弱，大王遣一介 之使至趙，趙立奉璧來；今以秦之彊而先割十五都予趙，趙豈敢留璧而得罪於大王乎？臣知欺大王之罪當誅，臣請就湯鑊 。唯大王與羣臣孰計議之 ！」\n\n　　秦王與羣臣相視而嘻 。左右或欲引相如去 ，秦王因 曰：「今殺相如，終不能得璧也，而絕秦趙之驩，不如因而厚遇之 ，使歸趙，趙王豈以一璧之故欺秦邪 ！」卒廷見相如 ，畢禮而歸之。\n\n　　相如既歸，趙王以為賢大夫，使不辱於諸侯 ，拜相如為上大夫 。\n\n　　秦亦不以城予趙，趙亦終不予秦璧。\n\n　　其後秦伐趙，拔石城。明年，復攻趙，殺二萬人。\n\n　　秦王使使者告趙王，欲與王為好會於西河外澠池 。趙王畏秦，欲毋行 。廉頗、藺相如計曰：「王不行，示趙弱且怯也。」趙王遂行，相如從。廉頗送至境，與王訣曰 ：「王行，度道里會遇之禮畢 ，還，不過三十日。三十日不還，則請立太子為王，以絕秦望。」王許之，遂與秦王會澠池。\n\n　　秦王飲酒酣 ，曰：「寡人竊聞趙王好音，請奏瑟 。」趙王鼓瑟。秦御史前書曰 ：「某年月日，秦王與趙王會飲，令趙王鼓瑟。」藺相如前曰：「趙王竊聞秦王善為秦聲，請奏盆缻秦王 ，以相娛樂。」秦王怒，不許。於是相如前進缻，因跪請秦王。秦王不肯擊缻。相如曰：「五步之內，相如請得以頸血濺大王矣 ！」左右欲刃相如 ，相如張目叱之，左右皆靡 。於是秦王不懌 ，為一擊缻。相如顧 召趙御史書曰：「某年月日，秦王為趙王擊缻。」秦之羣臣曰：「請以趙十五城為秦王壽 。」藺相如亦曰：「請以秦之咸陽 為趙王壽。」\n\n　　秦王竟酒 ，終不能加勝於趙。趙亦盛設兵以待秦，秦不敢動。\n\n　　既罷歸國，以相如功大，拜為上卿，位在廉頗之右。\n\n　　廉頗曰：「我為趙將，有攻城野戰之大功，而藺相如徒以口舌為勞 ，而位居我上，且相如素賤人 ，吾羞，不忍為之下 。」宣言曰：「我見相如，必辱之。」相如聞，不肯與會。相如每朝時，常稱病，不欲與廉頗爭列 。已而 相如出，望見廉頗，相如引車避匿 。\n\n　　於是舍人相與諫曰：「臣所以去親戚而事君者 ，徒慕君之高義也 。今君與廉頗同列，廉君宣惡言而君畏匿之，恐懼殊甚，且庸人尚羞之，況於將相乎！臣等不肖 ，請辭去。」藺相如固止之，曰：「公之視廉將軍孰與秦王 ？」曰：「不若也 。」相如曰：「夫以秦王之威，而相如廷叱之，辱其羣臣，相如雖駑 ，獨畏廉將軍哉？顧 吾念之，彊秦之所以不敢加兵於趙者，徒以吾兩人在也。今兩虎共鬥，其勢不俱生 。吾所以為此者，以先國家之急而後私讎也 。」\n\n　　廉頗聞之，肉袒 負荊 ，因賓客至藺相如門謝罪 。曰：「鄙賤之人，不知將軍寬之至此也 。」\n\n　　卒相與驩，為刎頸之交 。" },
        { "title": "山居秋暝", "content": "空山新雨後 ，天氣晚來秋。\n明月松間照，清泉石上流。\n竹喧歸浣女，蓮動下漁舟。 \n隨意春芳歇 ，王孫自可留 。" },
        { "title": "月下獨酌", "content": "花間一壺酒，獨酌無相親 。 \n舉杯邀明月，對影成三人 。\n月既不解 飲，影徒隨我身。\n暫伴月將 影，行樂須及春 。 \n我歌月徘徊 ，我舞影零亂 。 \n醒時同交歡 ，醉後各分散 。\n永結無情遊 ，相期邈雲漢 。" },
        { "title": "登樓", "content": "花近高樓傷客心， 萬方多難此登臨。 \n錦江春色來天地， 玉壘浮雲變古今。 \n北極朝廷終不改， 西山寇盜莫相侵。 \n可憐後主還祠廟， 日暮聊為〈梁甫吟〉。" },
        { "title": "師說", "content": "古之學者必有師。師者，所以傳道、受業 、解惑也。人非生而知之者 ，孰能無惑？惑而不從師，其為惑也終不解矣。\n\n生乎吾前，其聞道 也固 先乎吾，吾從而師之；生乎吾後，其聞道也亦先乎吾，吾從而師之。吾師道也，夫庸知 其年之先後生於吾乎？是故無貴無賤，無長無少，道之所存，師之所存也。\n\n嗟乎！師道之不傳也久矣！欲人之無惑也難矣！古之聖人，其出人也遠矣，猶且從師而問焉；今之眾人，其下聖人也亦遠矣，而恥學於師；是故聖益聖，愚益愚，聖人之所以為聖，愚人之所以為愚，其 皆出於此乎？\n\n愛其子，擇師而教之，於其身也，則恥師焉，惑矣！彼童子之師，授之書而習其句讀 者也，非吾所謂傳其道，解其惑者也。句讀之不知，惑之不解，或師焉，或不焉，小學而大遺，吾未見其明也。\n\n巫醫 、樂師，百工之人，不恥相師；士大夫之族，曰師、曰弟子云者，則群聚而笑之，問之，則曰：「彼與彼年相若也，道相似也。位卑則足羞，官盛則近諛 。」嗚呼！師道之不復可知矣。巫、醫、樂師、百工之人，君子 不齒 ，今其智乃反不能及，其可怪也歟！\n\n聖人無常師 ，孔子師郯子 、萇弘 、師襄 、老聃 。郯子之徒，其賢不及孔子。孔子曰：「三人行，則必有我師。」 是故弟子不必不如師，師不必賢於弟子，聞道有先後，術業有專攻，如是而已。\n\n李氏子蟠 ，年十七，好古文，六藝 經傳，皆通習之；不拘於時，學於余，余嘉其能行古道，作〈師說〉以貽 之。" },
        { "title": "岳陽樓記", "content": "慶曆四年春 ，滕子京 謫守巴陵郡 。越明年，政通人和，百廢具 興。乃重修岳陽樓，增其舊制，刻唐賢、今人詩賦於其上；屬 予作文以記之。\n\n予觀夫巴陵勝狀 ，在洞庭一湖。銜遠山，吞長江，浩浩湯湯 ，橫無際涯；朝暉夕陰，氣象萬千。此則岳陽樓之大觀也，前人之述備 矣。然則北通巫峽 ，南極瀟湘 ，遷客騷人 ，多會於此，覽物之情，得無異乎？\n\n若夫霪雨霏霏 ，連月不開；陰風怒號 ，濁浪排空；日星隱耀，山岳潛形；商旅不行，檣傾楫摧 ；薄暮冥冥 ，虎嘯猿啼。登斯樓也，則有去國 懷鄉，憂讒畏譏，滿目蕭然 ，感極而悲者矣。\n\n至若春和景明 ，波瀾不驚 ，上下天光，一碧萬頃；沙鷗翔集 ，錦鱗游泳，岸芷汀蘭 ，郁郁青青 。而或長煙一空 ，皓月千里，浮光躍金 ，靜影沉璧 ；漁歌互答，此樂何極！登斯樓也，則有心曠神怡 ，寵辱 皆忘，把酒臨風 ，其喜洋洋 者矣。\n\n嗟夫！予嘗求古仁人之心，或異二者之為 。何哉？不以物喜，不以己悲 。居廟堂之高 ，則憂其民；處江湖之遠 ，則憂其君。是進亦憂，退亦憂，然則何時而樂耶？其必曰：「先天下之憂而憂，後天下之樂而樂」歟！噫！微斯人 ，吾誰與歸 ！" },
        { "title": "始得西山宴遊記", "content": "自余為僇人 ，居是州，恒惴慄 。其隙也 ，則施施 而行，漫漫 而遊。日與其徒 上高山，入深林，窮迴溪 ，幽泉 怪石，無遠不到。到則披草 而坐，傾壺而醉。醉則更相枕 以臥，臥而夢。意有所極 ，夢亦同趣 。覺 而起，起而歸。以為凡是州之山有異態者，皆我有也，而未始知西山之怪特。\n\n今年九月二十八日，因坐法華西亭 ，望西山，始指異之 。遂命僕過湘江 ，緣染溪 ，斫榛莽 。焚茅茷 ，窮 山之高而止。\n\n攀援而登，箕踞而遨 ，則凡數州之土壤 ，皆在衽席 之下。其高下之勢，岈然窪然 ，若垤 若穴，尺寸千里 ，攢蹙累積 ，莫得遯隱 。縈青繚白 ，外與天際 ，四望如一。然後知是山之特出，不與培塿 為類。悠悠乎與顥氣 俱，而莫得其涯；洋洋 乎與造物者遊 ，而不知其所窮。\n\n引 觴滿酌，頹然 就醉，不知日之入。蒼然暮色 ，自遠而至，至無所見，而猶不欲歸。心凝形釋 ，與萬化冥合 。然後知吾嚮 之未始 遊，遊於是乎始，故為之文以志 。是歲元和四年 也。" },
        { "title": "念奴嬌‧赤壁懷古", "content": "大江東去，浪淘盡、千古風流人物。故壘西邊，人道是、三國周郎 赤壁。亂石穿空，驚濤拍岸，捲起千堆雪。江山如畫，一時多少豪傑！\n\n遙想公瑾當年，小喬 初嫁了，雄姿英發。羽扇綸巾 ，談笑間、檣櫓 灰飛煙滅。故國 神遊，多情應笑我，早生華髮 。人間如夢，一尊 還酹 江月。" },
        { "title": "青玉案", "content": "東風夜放花千樹，更吹落，星如雨。寶馬雕車香滿路。鳳簫聲動，玉壺光轉，一夜魚龍舞。 \n\n蛾兒雪柳黃金縷，笑語盈盈暗香去。眾裏尋他千百度；驀然迴首，那人卻在，燈火闌珊處。" },
        { "title": "聲聲慢", "content": "尋尋覓覓，冷冷清清，悽悽慘慘戚戚。乍暖還寒時候， 最難將息。 三杯兩盞淡酒，怎敵他，晚來風急？雁過也，正傷心，卻是舊時相識。\n\n滿地黃花堆積， 憔悴損，如今有誰堪摘？守著窗兒，獨自怎生得黑！梧桐更兼細雨，到黃昏、點點滴滴。這次第，怎一箇愁字了得！" },
        { "title": "逍遙遊", "content": "惠子 謂莊子曰：「魏王貽我大瓠之種 ，我樹之成而實五石 。以盛水漿，其堅不能自舉也 。剖之以為瓢 ，則瓠落無所容 。非不呺然 大也，吾為其無用而掊之 。」莊子曰：「夫子固拙於 用大矣！宋人有善為不龜手之藥者 ，世世以洴澼絖為事 。客聞之，請買其方百金。聚族而謀曰：『我世世為洴澼絖，不過數金；今一朝而鬻技百金 ，請與之。』客得之，以說 吳王。越有難 ，吳王使之將 ，冬與越人水戰，大敗越人，裂地 而封之。能不龜手一也 ；或以封，或不免於洴澼絖，則所用之異也 。今子有五石之瓠，何不慮以為大樽而浮於江湖 ，而憂其瓠落無所容，則夫子猶有蓬之心也夫 ！」\n\n惠子謂莊子曰：「吾有大樹，人謂之樗 ；其大本擁腫而不中繩墨 ，其小枝卷曲而不中規矩 。立之塗 ，匠者不顧。今子之言，大而無用，衆所同去也 。」莊子曰：「子獨不見狸狌乎 ？卑身而伏，以候敖者 ；東西跳梁，不辟高下 ，中於機辟，死於罔罟 。今夫斄牛，其大若垂天之雲 ；此能為大矣，而不能執鼠 。今子有大樹，患其無用，何不樹之於無何有之鄉 ，廣莫之野 ，彷徨乎無為其側，逍遙乎寢臥其下 ；不夭斤斧，物無害者 。無所可用，安所困苦哉 ？」" },
        { "title": "出師表", "content": "先帝創業未半 ，而中道崩殂 ；今天下三分 ，益州疲弊 ，此誠危急存亡之秋也﹗然侍衞之臣，不懈於內；忠志之士，忘身於外者 ，蓋追先帝之殊遇，欲報之於陛下也 。誠宜開張聖聽 ，以光先帝遺德 ，恢弘志士之氣 ﹔不宜妄自菲薄 ，引喻失義 ，以塞忠諫之路也 。\n\n宮中、府中，俱為一體 ；陟罰臧否 ，不宜異同。若有作姦、犯科，及為忠善者 ，宜付有司，論其刑賞 ，以昭陛下平明之治 ；不宜偏私，使內外異法也 。\n\n侍中、侍郎郭攸之、費禕、董允等 ，此皆良實，志慮忠純 ，是以先帝簡拔以遺陛下 。愚以為宮中之事，事無大小，悉以咨之 ，然後施行，必能裨補闕漏，有所廣益 。\n\n將軍向寵，性行淑均 ，曉暢軍事，試用於昔日，先帝稱之曰「能」，是以眾議舉寵為督 。愚以為營中之事，悉以咨之，必能使行陣和睦，優劣得所 。\n\n親賢臣，遠小人 ，此先漢所以興隆也﹔親小人，遠賢臣，此後漢所以傾頹也。先帝在時，每與臣論此事，未嘗不歎息痛恨於桓、靈也 ！侍中、尚書、長史、參軍 ，此悉貞良死節之臣，願陛下親之、信之，則漢室之隆，可計日而待也。\n\n臣本布衣，躬耕於南陽 ，苟全性命於亂世，不求聞達於諸侯 。先帝不以臣卑鄙，猥自枉屈 ，三顧臣於草廬之中，諮臣以當世之事；由是感激，遂許先帝以驅馳 。後值傾覆 ，受任於敗軍之際，奉命於危難之間，爾來二十有一年矣 。先帝知臣謹慎，故臨崩寄臣以大事也 。受命以來，夙夜憂歎，恐託付不效，以傷先帝之明 。故五月渡瀘，深入不毛 。今南方已定，兵甲已足，當獎率三軍，北定中原，庶竭駑鈍，攘除姦凶 ，興復漢室，還於舊都 。此臣所以報先帝而忠陛下之職分也。至於斟酌損益，進盡忠言，則攸之、禕、允之任也 。\n\n願陛下託臣以討賊興復之效；不效，則治臣之罪，以告先帝之靈。若無興德之言，則責攸之、禕、允等之慢，以彰其咎 。陛下亦宜自謀，以諮諏善道，察納雅言 ，深追先帝遺詔。臣不勝受恩感激。今當遠離，臨表涕零 ，不知所言 ！" },
        { "title": "六國論", "content": "六國破滅 ，非兵不利 ，戰不善 ，弊在賂秦 。賂秦而力虧 ，破滅之道 也。或曰：「六國互喪 ，率 賂秦耶？」曰：「不賂者以賂者喪。」蓋失強援 ，不能獨完 ，故曰「弊在賂秦」也。\n\n秦以攻取 之外，小則獲邑 ，大則得城，較秦之所得 與戰勝而得者，其實百倍；諸侯之所亡 與戰敗而亡者，其實亦百倍。則秦之所大欲，諸侯之所大患，固不在戰矣。思厥先祖父 ，暴霜露，斬荊棘 ，以有尺寸之地 。子孫視之不甚惜，舉以予人 ，如棄草芥 。今日割五城，明日割十城，然後得一夕安寢；起視四境，而秦兵又至矣。然則諸侯之地有限，暴秦之欲無厭 ，奉之彌 繁，侵之愈急，故不戰而強弱勝負已判 矣。至於顛覆 ，理固宜然。古人 云：「以地事秦，猶抱薪救火，薪不盡，火不滅。」 此言得之。 \n\n齊人未嘗賂秦，終繼五國遷滅 ，何哉？與嬴 而不助五國也。五國既喪，齊亦不免矣。燕趙之君，始有遠略 ，能守其土，義不賂秦 。是故燕雖小國而後亡，斯用兵之效 也。至丹以荊卿為計 ，始速禍 焉。趙嘗五戰于秦 ，二敗而三勝 ；後秦擊趙者再，李牧 連卻 之；洎牧以讒誅 ，邯鄲為郡 ，惜其用武而不終 也。\n\n且燕趙處秦革滅 殆盡之際，可謂智力孤危 ，戰敗而亡，誠不得已。向使三國各愛其地 ，齊人勿附於秦，刺客不行 ，良將 猶在，則勝負之數 ，存亡之理，當 與秦相較，或未易量 。\n\n嗚呼！以賂秦之地，封天下之謀臣；以事秦之心，禮 天下之奇才；幷力西嚮 ，則吾恐秦人食之不得下嚥 也。悲夫！有如此之勢，而為秦人積威 之所劫，日削月割，以趨於亡！為國者無使為積威之所劫哉！\n\n夫六國與秦皆諸侯，其勢弱於秦，而猶有可以不賂而勝之之勢；茍以天下之大，而從六國破亡之故事 ，是又在六國下矣！" },
        { "title": "勸學", "content": "君子曰：學不可以已 。青，取之於藍 ，而青於藍 ；冰，水為之，而寒於水。木直中繩 ，輮 以為輪，其曲中規 ；雖有槁暴 、不復挺 者，輮使之然也。故木受繩則直 ，金就礪 則利，君子博學而日參省 乎己，則知 明而行 無過矣。\n\n吾嘗終日而思矣，不如須臾 之所學也；吾嘗跂 而望矣，不如登高之博見也。登高而招，臂非加長也，而見者遠。順風而呼，聲非加疾 也，而聞者彰 。假輿馬者 ，非利足 也，而致 千里；假舟楫 者，非能水 也，而絕江河 。君子生非異 也，善假於物 也。\n\n積土成山，風雨興焉；積水成淵 ，蛟龍 生焉；積善成德，而神明 自得，聖心 備焉。故不積跬步 ，無以至千里；不積小流，無以成江海。騏驥 一躍，不能十步；駑馬十駕 ，功在不舍 。鍥 而舍之，朽木不折；鍥而不舍，金石可鏤 。螾 無爪牙之利，筋骨之強，上食埃土 ，下飲黃泉，用心一也。蟹六跪而二螯 ，非蛇蟺 之穴無可寄託者，用心躁 也。" },
        { "title": "論仁、論孝、論君子", "content": "論仁\n(1)子曰：「不仁者，不可以久處約 ，不可以長處樂。仁者安仁，知者利仁 。」（《里仁》第四）\n(2)子曰：「富與貴，是人之所欲也；不以其道得之，不處也 。貧與賤，是人之所惡也；不以其道得之 ，不去 也。君子去仁，惡乎成名 ？君子無終食之間違仁 ，造次必於是 ，顛沛必於是。」（《里仁》第四）\n(3)顏淵問仁。\n子曰：「克己復禮為仁 。一日克己復禮，天下歸仁焉。為仁由己，而由人乎哉 ？」\n顏淵曰：「請問其目 。」子曰：「非禮勿視，非禮勿聽，非禮勿言，非禮勿動 。」\n顏淵曰：「回雖不敏，請事斯語矣 。」（《顏淵》第十二）\n(4)子曰：「志士仁人，無求生以害仁，有殺身以成仁 。」（《衛靈公》第十五）\n\n論孝\n(5)孟懿子 問孝。子曰：「無違 。」\n樊遲御 ，子告之曰：「孟孫問孝於我，我對曰，無違。」\n樊遲曰：「何謂也？」子曰：「生事之以禮 ；死葬之以禮，祭之以禮 。」（《為政》第二）\n(6)子游 問孝。子曰：「今之孝者，是謂能養 。至於犬馬，皆能有養 ；不敬，何以別乎 ！」（《為政》第二）\n\n(7)子曰：「事父母幾諫 ，見志不從，又敬不違，勞而不怨 。」（《里仁》第四）\n(8)子曰：「父母之年，不可不知也。一則以喜，一則以懼 。」（《里仁》第四）\n\n論君子\n(9)子曰：「君子不重則不威 ；學則不固 。主忠信 。無友不如己者 。過則勿憚改 。」（《學而》第一）\n(10)子曰：「君子坦蕩蕩，小人長戚戚 。」（《述而》第七）\n(11)司馬牛 問君子。子曰：「君子不憂不懼。」曰：「不憂不懼，斯謂之君子已乎 ？」子曰：「內省不疚，夫何憂何懼 ？」（《顏淵》第十二）\n(12)子曰：「君子成人之美，不成人之惡 。小人反是 。」（《顏淵》第十二）\n(13)子曰：「君子恥其言而過其行 。」（《憲問》第十四）\n(14)子曰：「君子義以為質 ，禮以行之，孫以出之，信以成之 。君子哉！」（《衛靈公》第十五）\n(15)子曰：「君子病無能焉，不病人之不己知也 。」（《衛靈公》第十五）\n(16)子曰：「君子求諸己，小人求諸人 。」（《衛靈公》第十五）" },
        { "title": "魚我所欲也", "content": "孟子曰：「魚，我所欲也，熊掌，亦我所欲也；二者不可得兼，舍魚而取熊掌 者也。生亦我所欲也，義亦我所欲也；二者不可得兼，舍生而取義者也。\n\n「生亦我所欲，所欲有甚於生者，故不為苟得 也；死亦我所惡 ，所惡有甚於死者，故患有所不辟 也。如使人之所欲莫甚於生，則凡可以得生者，何不用也？使人之所惡莫甚於死者，則凡可以辟患者，何不為也？由是則生而有不用也，由是則可以辟患而有不為也，是故所欲有甚於生者，所惡有甚於死者。非獨賢者有是心也，人皆有之，賢者能勿喪耳 。\n\n一簞食 ，一豆羹 ，得之則生，弗 得則死。嘑爾而與之 ，行道之人弗受 ；蹴爾而與之 ，乞人不屑也 ；萬鍾 則不辯 禮義而受之。萬鍾於我何加 焉？為宮室之美、妻妾之奉 、所識窮乏者得我與 ？鄉 為身死而不受，今為宮室之美為之；鄉為身死而不受，今為妻妾之奉為之；鄉為身死而不受，今為所識窮乏者得我而為之，是亦不可以已 乎？此之謂失其本心 。」" }
    ]
};



	
/* === 修改後的 openModalEditor (手機版不自動彈出鍵盤) === */
function openModalEditor(element) {
    currentEditingElement = element;
    modalTextarea.value = currentEditingElement.value;

    let titleText = '編輯內容'; 

    // === 標題生成邏輯 (保持不變) ===
    if (element.id === 'writingContent' || element.id === 'argumentWritingContent') {
        titleText = '輸入您的文章';
    } else {
        const parentTableCell = element.closest('td');
        if (parentTableCell) {
            const parentRow = parentTableCell.closest('tr');
            if (parentRow) {
                const headerCell = parentRow.cells[0];
                const table = parentRow.closest('table');
                if (table && table.rows.length > 0) {
                    const columnHeaderCell = table.rows[0].cells[parentTableCell.cellIndex];
                    const rowTitle = headerCell ? headerCell.textContent.trim().replace(/[:：]/g, '') : '';
                    const colTitle = columnHeaderCell ? columnHeaderCell.textContent.trim().replace(/[:：]/g, '') : '';
                    if (rowTitle && colTitle && rowTitle !== colTitle) {
                        titleText = `編輯「${rowTitle}」的「${colTitle}」`;
                    } else if (rowTitle) {
                        titleText = `編輯「${rowTitle}」`;
                    } else if (colTitle) {
                        titleText = `編輯「${colTitle}」`;
                    }
                }
            }
        } else {
            let associatedLabel = null;
            if (element.id) {
                associatedLabel = document.querySelector(`label[for="${element.id}"]`);
            }
            if (!associatedLabel) {
                const parentContainer = element.closest('div');
                if (parentContainer) {
                    associatedLabel = parentContainer.querySelector('label');
                }
            }
            if (associatedLabel) {
                titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
            }
        }
    }

    modalTitle.textContent = titleText;

    // === 範文選擇器邏輯 (修正版) ===
    const templateSelect = document.getElementById('modal-template-select');
    
    if (element.id === 'readingPassage') {
        templateSelect.style.display = 'block';
        
        // 1. 如果選項還沒建立，先建立選項 (只執行一次)
        if (templateSelect.options.length <= 1) { 
            textLibrary.texts.forEach(text => {
                const option = document.createElement('option');
                option.value = text.content;
                option.textContent = text.title;
                templateSelect.appendChild(option);
            });
        }

        // 2. ★★★ 關鍵修正：將 onchange 監聽器移到 if 外面 ★★★
        // 這樣每次打開視窗時，都會確保監聽器是運作中的
        templateSelect.onchange = function() {
            if (this.value) {
                modalTextarea.value = this.value;
            }
        };

        // 3. 重置選單回到「指定範文」預設選項
        templateSelect.value = ""; 

    } else {
        templateSelect.style.display = 'none';
        templateSelect.onchange = null; // 其他輸入框不需要此功能
    }

    // 顯示視窗
    modal.style.display = 'flex';

    // === 鍵盤控制邏輯 (保持不變) ===
    modalTextarea.blur();
    if (window.innerWidth > 1024) {
        setTimeout(() => {
            modalTextarea.focus();
        }, 50);
    } 
}

function closeModalEditor() {
modal.style.display = 'none';
currentEditingElement = null;
}

function saveAndCloseEditor() {
if (currentEditingElement) {
currentEditingElement.value = modalTextarea.value;
if (currentEditingElement.id === 'expandContent') {
updateCharCount();
}
}
closeModalEditor();
}




// 主事件監聽器 (保持不變)
document.body.addEventListener('click', function(event) {
    const target = event.target;

    const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
    const isTextarea = target.tagName === 'TEXTAREA';

    // 檢查是否為需要觸發懸浮視窗的輸入框
    if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
        event.preventDefault(); // 阻止瀏覽器預設的聚焦行為
        target.blur();          // ★ 關鍵：讓原本點擊的框立刻失焦，防止手機鍵盤閃現
        openModalEditor(target);
    }
});

// 為懸浮視窗的按鈕和外部區域綁定事件 (保持不變)
modalSaveBtn.addEventListener('click', saveAndCloseEditor);
modalCloseBtn.addEventListener('click', closeModalEditor);

});



// =======================================================
// === 全新評等系統邏輯 (Grading System Logic) ===
// =======================================================

let radarChartInstance = null; // 全域變數，用於存放雷達圖實例

/**
* 建立評等系統的完整 HTML 結構 (修訂版)
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @returns {string} HTML 字符串
*/
/**
* 建立評等系統的完整 HTML 結構 (修訂版：直接注入分數)
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @param {object} scores - (新) AI 評分結果物件，若無則為 null
* @param {string} grade - (新) 最終等級
* @returns {string} HTML 字符串
*/
function createGradingSystemHTML(uniqueIdPrefix, scores = null, grade = "3") {
    // 1. 獲取分數 (如果 scores 存在就用 scores，否則用預設值 5)
    // 透過 || 運算符處理可能的 undefined，確保有數值
    const c = scores ? (scores.content || 0) : 5;
    const e = scores ? (scores.expression || 0) : 5;
    const s = scores ? (scores.structure || 0) : 5;
    
    // 標點和錯別字目前 AI 沒評分，維持固定值
    const p = 5; 
    const t = 1; // 錯別字預設 1 分 (3分滿分)

    // 2. 計算顯示用的總分與百分比寬度
    const c_disp = c * 4;
    const e_disp = e * 3;
    const s_disp = s * 2;
    const p_disp = p * 1;
    const t_disp = t;
    
    const totalScore = c_disp + e_disp + s_disp + p_disp + t_disp;
    const cappedTotal = Math.min(totalScore, 100);

    // 3. 生成 HTML (直接將 width 和 value 寫死在 HTML 裡)
    return `
    <div class="grading-container">
        <div class="grading-grid">
            <div class="grading-scores">
                <h3>評等</h3>
                
                <!-- 內容 -->
                <div class="score-item">
                    <label>內容 (40)</label>
                    <div class="slider-container">
                        <div class="progress-bar-container">
                            <div id="${uniqueIdPrefix}ContentScoreFill" class="progress-bar-fill" style="width: ${c * 10}%"></div>
                        </div>
                        <span id="${uniqueIdPrefix}ContentScoreDisplay" class="score-display">${c_disp}</span>
                    </div>
                </div>

                <!-- 表達 -->
                <div class="score-item">
                    <label>表達 (30)</label>
                    <div class="slider-container">
                        <div class="progress-bar-container">
                            <div id="${uniqueIdPrefix}ExpressionScoreFill" class="progress-bar-fill" style="width: ${e * 10}%"></div>
                        </div>
                        <span id="${uniqueIdPrefix}ExpressionScoreDisplay" class="score-display">${e_disp}</span>
                    </div>
                </div>

                <!-- 結構 -->
                <div class="score-item">
                    <label>結構 (20)</label>
                    <div class="slider-container">
                        <div class="progress-bar-container">
                            <div id="${uniqueIdPrefix}StructureScoreFill" class="progress-bar-fill" style="width: ${s * 10}%"></div>
                        </div>
                        <span id="${uniqueIdPrefix}StructureScoreDisplay" class="score-display">${s_disp}</span>
                    </div>
                </div>

                <!-- 標點 -->
                <div class="score-item">
                    <label>標點字體 (10)</label>
                    <div class="slider-container">
                        <div class="progress-bar-container">
                            <div id="${uniqueIdPrefix}PunctuationScoreFill" class="progress-bar-fill" style="width: ${p * 10}%"></div>
                        </div>
                        <span id="${uniqueIdPrefix}PunctuationScoreDisplay" class="score-display">${p_disp}</span>
                    </div>
                </div>

                <!-- 錯別字 -->
                <div class="score-item">
                    <label>錯別字 (+3)</label>
                    <div class="slider-container">
                        <div class="progress-bar-container">
                            <!-- 錯別字滿分是3，所以寬度計算不同 -->
                            <div id="${uniqueIdPrefix}TypoScoreFill" class="progress-bar-fill" style="width: ${(t / 3) * 100}%"></div>
                        </div>
                        <span id="${uniqueIdPrefix}TypoScoreDisplay" class="score-display">${t_disp}</span>
                    </div>
                </div>

                <!-- 隱藏的 input 用於數值儲存 (確保 value 是真實分數) -->
                <input type="hidden" id="${uniqueIdPrefix}ContentScore" value="${c}">
                <input type="hidden" id="${uniqueIdPrefix}ExpressionScore" value="${e}">
                <input type="hidden" id="${uniqueIdPrefix}StructureScore" value="${s}">
                <input type="hidden" id="${uniqueIdPrefix}PunctuationScore" value="${p}">
                <input type="hidden" id="${uniqueIdPrefix}TypoScore" value="${t}">

                <div class="total-score-container">
                    <span id="${uniqueIdPrefix}TotalScoreDisplay">總分: ${cappedTotal} / 100</span>
                    <span id="${uniqueIdPrefix}FinalGrade">等級: ${grade}</span>
                </div>
            </div>
            
            <div class="grading-radar">
                <h3>能力雷達圖</h3>
                <div class="radar-chart-container">
                    <canvas id="${uniqueIdPrefix}RadarChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    `;
}

/**
* 初始化評等系統，包括設定分數和繪製初始圖表
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @param {object} initialScores - 包含初始分數的物件
* @param {string} finalGrade - 【新】直接傳入最終計算好的等級
*/
function initializeGradingSystem(uniqueIdPrefix, initialScores = {}, finalGrade) {
    // 確保 initialScores 和 initialScores.radar 存在
    if (!initialScores || !initialScores.radar) {
        console.error("初始化評分系統時缺少必要的分數數據。");
        return;
    }

    // 將最終計算出的分數設定到隱藏的 input 中，這些 input 是後續計算的基礎
    document.getElementById(`${uniqueIdPrefix}ContentScore`).value = initialScores.content;
    document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value = initialScores.expression;
    document.getElementById(`${uniqueIdPrefix}StructureScore`).value = initialScores.structure;
    
    // 標點和錯別字分數使用固定的預設值
    document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value = 5;
    document.getElementById(`${uniqueIdPrefix}TypoScore`).value = 1;

    // 呼叫更新函式，它會處理所有介面元素的更新，包括顯示分數、進度條和雷達圖
    updateScoresAndGrade(uniqueIdPrefix, finalGrade, initialScores.radar);
}




/**
* 根據分數計算總分，上限為 100
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @returns {number} 計算後且不超過 100 的總分
*/
function calculateTotalScore(uniqueIdPrefix) {
// 【修訂二】從隱藏的 input 中獲取原始分數 (0-10)
const content = parseInt(document.getElementById(`${uniqueIdPrefix}ContentScore`).value) * 4;
const expression = parseInt(document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value) * 3;
const structure = parseInt(document.getElementById(`${uniqueIdPrefix}StructureScore`).value) * 2;
const punctuation = parseInt(document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value) * 1;
const typo = parseInt(document.getElementById(`${uniqueIdPrefix}TypoScore`).value);

const totalScore = content + expression + structure + punctuation + typo;

// 返回分數，但最高不超過 100
return Math.min(totalScore, 100);
}

/**
* 根據總分決定 DSE 等級
* @param {number} score - 總分 (0-103)
* @returns {string} DSE 等級
*/
function determineGrade(score) {
if (score >= 72) return "5**";
if (score >= 69) return "5*";
if (score >= 64) return "5";
if (score >= 57) return "4";
if (score >= 50) return "3";
if (score >= 45) return "2";
return "1";
}

/**
* 更新所有分數顯示、總分、等級、進度條和雷達圖
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @param {string} finalGrade - 【新】直接傳入最終計算好的等級
* @param {object} radarData - 雷達圖的數據 (可選)
*/
function updateScoresAndGrade(uniqueIdPrefix, finalGrade, radarData = null) {
    // 從隱藏的 input 獲取原始分數 (0-10 或 0-3)
    const contentVal = parseInt(document.getElementById(`${uniqueIdPrefix}ContentScore`).value);
    const expressionVal = parseInt(document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value);
    const structureVal = parseInt(document.getElementById(`${uniqueIdPrefix}StructureScore`).value);
    const punctuationVal = parseInt(document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value);
    const typoVal = parseInt(document.getElementById(`${uniqueIdPrefix}TypoScore`).value);

    // 更新各分項顯示（乘以權重後的分數）
    document.getElementById(`${uniqueIdPrefix}ContentScoreDisplay`).textContent = contentVal * 4;
    document.getElementById(`${uniqueIdPrefix}ExpressionScoreDisplay`).textContent = expressionVal * 3;
    document.getElementById(`${uniqueIdPrefix}StructureScoreDisplay`).textContent = structureVal * 2;
    document.getElementById(`${uniqueIdPrefix}PunctuationScoreDisplay`).textContent = punctuationVal * 1;
    document.getElementById(`${uniqueIdPrefix}TypoScoreDisplay`).textContent = typoVal;

    // 更新進度條寬度
    document.getElementById(`${uniqueIdPrefix}ContentScoreFill`).style.width = `${contentVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}ExpressionScoreFill`).style.width = `${expressionVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}StructureScoreFill`).style.width = `${structureVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}PunctuationScoreFill`).style.width = `${punctuationVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}TypoScoreFill`).style.width = `${(typoVal / 3) * 100}%`;

    // 計算並更新總分
    const totalScore = calculateTotalScore(uniqueIdPrefix);
    document.getElementById(`${uniqueIdPrefix}TotalScoreDisplay`).textContent = `總分: ${totalScore} / 100`;
    // 【修訂】直接使用傳入的 finalGrade
    document.getElementById(`${uniqueIdPrefix}FinalGrade`).textContent = `等級: ${finalGrade}`;

    // 準備並更新雷達圖數據
    let currentRadarData;
    if (radarData) {
        currentRadarData = [
            radarData.立意 || 5,
            radarData.取材 || 5,
            radarData.扣題 || 5,
            radarData.詳略 || 5,
            radarData.詞彙 || 5,
            radarData.文學性 || 5
        ];
    } else {
        // 若 AI 未提供雷達圖數據，則根據分數估算 (此為備用邏輯)
        currentRadarData = [
            Math.round((contentVal * 0.6 + structureVal * 0.4)), 
            Math.round((contentVal * 0.8 + expressionVal * 0.2)),
            Math.round((contentVal * 0.7 + structureVal * 0.3)),
            Math.round((structureVal * 0.7 + contentVal * 0.3)),
            expressionVal,
            expressionVal
        ];
    }
    createOrUpdateRadarChart(uniqueIdPrefix, currentRadarData);
}


/**
* 創建或更新雷達圖
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @param {array} data - 包含五個能力值的數組
*/
function createOrUpdateRadarChart(uniqueIdPrefix, data) {
const ctx = document.getElementById(`${uniqueIdPrefix}RadarChart`).getContext('2d');

if (window[`${uniqueIdPrefix}_radarChartInstance`]) {
window[`${uniqueIdPrefix}_radarChartInstance`].data.datasets[0].data = data;
window[`${uniqueIdPrefix}_radarChartInstance`].update();
} else {
window[`${uniqueIdPrefix}_radarChartInstance`] = new Chart(ctx, {
type: 'radar',
data: {
labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
datasets: [{
label: '能力分佈',
data: data,
backgroundColor: 'rgba(54, 162, 235, 0.2)',
borderColor: 'rgba(54, 162, 235, 1)',
borderWidth: 2,
pointBackgroundColor: 'rgba(54, 162, 235, 1)',
pointBorderColor: '#fff',
pointHoverBackgroundColor: '#fff',
pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
scales: {
r: {
angleLines: {
display: true
},
suggestedMin: 0,
suggestedMax: 10,
pointLabels: {
font: {
size: 14,
family: "'Noto Serif TC', serif"
}
},
ticks: {
stepSize: 2
}
}
},
plugins: {
legend: {
display: false
}
}
}
});
}
}

/**
* 構建帶有評等指令的 API Prompt (V15 - 條件式加分)
* 此版本嚴格規定「內容」和「結構」分數必須以「扣題」分數為基礎，
* 但允許在這基礎上有條件地加一分，以獎勵表現出色的部分。
*/
function buildGradingPrompt(type, topic, content, toneNote, focus = null, plot = null) {
const dsePrinciples = document.getElementById('dse-grading-principles').innerText;
const fiveStarExamplesText = `
### 5** 級數範文參考 (用於判斷最高水平)：
${document.getElementById('example-yanhuo').innerHTML}
${document.getElementById('example-gen').innerHTML}
${document.getElementById('example-dengdai').innerHTML}
${document.getElementById('example-song-li').innerHTML}

### 3 級數範文參考 (用於判斷中等水平)：
${document.getElementById('example-lun-dushu').innerHTML}
`;

let basePrompt = "";
let specificInstructions = "";

if (type === 'narrative') {
basePrompt = `
題目：《${topic}》
${focus ? `結構段重點：${focus}` : ''}
${plot ? `情節大要：${plot}` : ''}
文章：\n${content}`;

// 【修訂一】這裡只引用敘事抒情相關的範文
const fiveStarExamplesText = `
### 5** 級數範文參考 (用於判斷最高水平)：
${document.getElementById('example-yanhuo').innerHTML}
${document.getElementById('example-gen').innerHTML}
${document.getElementById('example-dengdai').innerHTML}

### 3 級數範文參考 (用於判斷中等水平)：
${document.getElementById('example-yanhuo-l3').innerHTML}
`;

specificInstructions = `
### 敘事抒情專用評核指引
- 扣題判斷：文章必須在字面上緊扣題目關鍵詞，並透過具體情節體現主題
- 詳略剪裁：重點情節需詳寫，次要內容需略寫，體現層次感
- 物象運用：適當運用小物件、動作、對話和內心獨白，提高文句密度`;

// 【修訂二】這裡替換為你提供的全新評分邏輯和工作紙
return `你將扮演一個絕對理性的AI評卷員，你的核心任務是完成一份計分工作紙，然後根據工作紙的結果生成報告。

### 你的工作流程 (必須嚴格依序執行)

1. **填寫工作紙**: 這是你的首要且最重要的任務。在 <scoring_worksheet> 標籤內，完成所有計算。
2. **分發分數到JSON**: **絕對禁止重新思考分數**。你將扮演一個數據錄入員，將 <scoring_worksheet> 中計算出的分數，精確地分發到 <grading_json> 的對應欄位。
3. **撰寫報告**: 根據 <grading_json> 的最終分數，撰寫 <critique> 等文字報告，確保文字與數字完全對應。

${specificInstructions}

---

### 你的輸出格式 (必須嚴格遵守此結構與順序)

<scoring_worksheet>
[**計分工作紙**：你必須像執行程式碼一樣，完成以下所有步驟。]
<step_1_independent_evaluation>
[對以下各項進行獨立評分，互不影響。]
<eval_item name="扣題分數評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的具體內容來佐證你的評分。文章必須在*字面*及邏輯上扣連題目，所謂「字面」扣題，是指文章要反覆出現題眼或題眼的近義詞，例如題目是《勇氣》，則文中須反覆出現「勇氣」或「勇敢」等字眼。

- **7-10分 (緊扣主旨 / 5**水平):** 
能在*字面*及情節上直接呼應題目，完全能在字面上扣連題目，例如題目為《成長》，全文有較多「成長」或「成長」的近義詞，且意象連貫、深刻，絕對不接受任何只以隱喻扣題的間接形式。
令人信服地體現主旨。
多關鍵詞題目中能準確把握最重要的關鍵詞，水平與5**範文相當。

- **6分 (扣題良好 / 略遜於5**):** 
基本能扣緊題目要求，在主要情節、主旨及*字面*上與題目有明確關聯，能在字面上扣連題目，例如題目為《成長》，全文有一定數量「成長」或「成長」的近義詞，但在深度或完整性上
稍遜於頂尖水平，表現仍屬出色。絕對不接受任何只以隱喻扣題的間接形式。

- **5分 (扣題合格 / 中等水平):** 
能夠扣題，文章內容與題目有清晰關聯，但較少在字面上扣連題目，例如題目為《成長》，全文很少有「成長」或「成長」的近義詞，雖未能充分發揮題目的深層意涵，
但已達合格應試水平 (約3-4級)，絕對不接受任何只以隱喻扣題的間接形式。

- **1-4分 (偏離主題):** 
與題目關聯牽強，未能準確理解題意，或僅在表面文字上有所呼應，
實際內容偏離主題，扣題效果不佳。或沒有在字面上扣連題目，例如題目為《成長》，但全文卻沒有「成長」或「成長」的近義詞。絕對不接受任何只以隱喻扣題的間接形式。

評分 (0-10): [在此給出「扣題」的獨立分數]
</eval_item>

<eval_item name="立意分數評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的句子或主旨句來佐證你的評分。
- **7-10分 (深刻新穎 / 5**水平):** 能將個人經歷 **昇華** 至普遍的人生哲理或人性反思。主題層次豐富，能探討觀點的 **矛盾或轉變**。立意新穎，能給讀者帶來深刻啟發，水平與5**範文相當。
- **6分 (見解不凡 / 略遜於5**):** 立意有一定深度，能提出個人見解，而非複述道理。思想內容雖未及頂尖水平，但已超越一般考生的層次，表現出色。
- **5分 (清晰合理 / 中等水平):** 主題清晰，緊扣個人感受，能完整表達一次經歷後的體會。立意真誠、合理，是合格的應試文章水平 (約3-4級)。
- **1-4分 (膚淺陳腐):** 立意流於表面，多為 **陳腔濫調** (例如「努力便會成功」)，或僅是 **說教式** 的口號，與文章情節缺乏有機結合。

評分 (0-10): [在此給出「立意」的獨立分數]
</eval_item>
<eval_item name="取材分數評估">
規則：嚴格按照以下標尺評分，評分時需明確指出取材的優點（如某個具體的細節）或缺點（如情節過於概括）。
- **7-10分 (新穎生動 / 5**水平):** 選取的材料 **典型** 且具 **獨特性**，能有力地支撐立意。描寫 **具體入微**，包含豐富的感官細節、動作、對話和內心獨白，能營造強烈的情感張力，水平與5**範文相當。
- **6分 (細膩具體 / 略遜於5**):** 選材恰當，頗具獨特性，能有效支撐立意。描寫具體，包含不少細節，但整體新穎性或情感張力略遜於最高水平，但遠超於3等文章水平。
- **5分 (內容恰當 / 中等水平):** 選材合理，與主旨相關。情節有基本細節，但描寫較為普遍化，缺乏令人印象深刻的亮點 (約3-4級)。
- **1-4分 (空泛籠統):** 取材流於 **流水帳**，僅概括事件而無細節描寫。內容空泛，與主旨關係薄弱，無法有效支撐觀點。

評分 (0-10): [在此給出「取材」的獨立分數]
</eval_item>
<eval_item name="詳略安排評估">
規則：嚴格按照以下標尺評分。此項評估的是文章的「敘事節奏」與「焦點分配」。
- **7-10分 (卓越 / 5**水平):** **詳略得當，重心突出**。能將最多筆墨用於高潮、轉捩點或最能體現主旨的核心情節，並以豐富的細節（感官、心理）進行刻劃。次要的過渡性內容則簡潔交代。敘事節奏控制自如，張弛有度。
- **6分 (良好 / 略遜於5**):** **主次分明**。能意識到並詳寫核心事件，但詳寫的細膩度或略寫的簡練度未及頂尖水平。文章的焦點清晰，能引導讀者關注重點。
- **5分 (中等 / 合格水平):** **平均用力**。文章能完整敘述事件，但缺乏詳略意識，從頭到尾的細節密度相近，導致核心情節不夠突出，缺乏記憶點。
- **1-4分 (失衡 / 有待改善):** **詳略嚴重失衡**。常見問題如「頭重腳輕」（開頭冗長）、「虎頭蛇尾」（結尾倉促），或將大量筆墨用於無關緊要的細節上，導致主題模糊。
特別注意：必須評論文章的重心是否放在了最關鍵的情節上。

評分 (0-10): [在此給出「詳略安排」的獨立分數]
</eval_item>

<eval_item name="結構佈局評估">
規則：嚴格按照以下標尺評分。此項評估的是文章的「組織架構」與「段落邏輯」。
- **7-10分 (精巧嚴謹 / 5**水平):** 佈局精巧，**層層推進**，而非單純的順序記述。段落劃分清晰且邏輯性強，過渡自然無痕。開頭與結尾**巧妙呼應**，使文章渾然一體。
- **6分 (良好 / 略遜於5**):** **結構穩妥，脈絡清晰**。文章組織有序，段落職能分明（如開頭、發展、結尾），起承轉合流暢。整體表現穩健，無明顯結構缺陷。
- **5分 (中等 / 合格水平):** **結構完整，尚算清晰**。文章有頭有尾，段落劃分基本合理。但段落間的聯繫可能較弱，或過渡略顯生硬（例如頻繁使用「然後」、「接著」）。
- **1-4分 (鬆散混亂 / 有待改善):** **結構鬆散，脈絡不清**。段落劃分混亂，或思想跳躍，讓讀者難以跟隨。文章可能缺乏清晰的開頭或結尾。
特別注意：此項不評估內容詳略，只評估組織架構。

評分 (0-10): [在此給出「結構佈局」的獨立分數]
</eval_item>



<eval_item name="詞彙豐富度評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的詞語來佐證你的評分。
- **7-10分 (優良 / 5**水平):** 用詞精準、豐富且多樣化，能根據語境選擇最貼切的詞。善用成語、典故或富含意象的詞彙，且自然不堆砌。幾乎沒有重複用詞。水平與5**範文相當。
- **6分 (良好 / 略遜於5**):** 用詞準確，具備變化，能嘗試運用較豐富的詞彙（較少重複同一個詞彙），偶有佳句，整體表現穩健，屬良好水平。
- **5分 (中等 / 合格水平):** 用詞基本準確，但變化不大，偶爾出現不夠貼切或陳腔濫調的情況。能夠清晰達意，是合格的應試文章水平，經常運用虛詞（例如「的」、「了」、「呢」、「嗎」、「地」）及對話，用詞重複。
- **1-4分 (基礎 / 有待改善):** 用詞單調、重複，常使用口語化或模糊的詞語，甚至出現詞不達意的情況。
特別注意：不要輕易給予高分，必須有充分理據。

評分 (0-10): [在此給出「詞彙豐富度」的獨立分數]
</eval_item>


<eval_item name="文句文學性評估">
規則：嚴格按照以下標尺評分。此項評估的是「句子工藝」，而非單純的詞彙。
- **7-10分 (卓越 / 5**水平):** 句式靈活多變，長短句交錯，富有節奏感。善於運用**感官描寫**和**示現手法**（Show, not Tell），能巧妙地融情入景，運用物象營造意境氛圍。文句精煉，文字具有**畫面感**和感染力。水平與5**範文相當。
- **6分 (良好 / 略遜於5**):** 句式有一定變化，能避免單調。能運用基本的描寫技巧，但細節刻劃或意境營造未及頂尖水平。整體文句流暢，但偶有冗贅之處。屬良好水平，表現穩健。
- **5分 (中等 / 合格水平):** 句式有基本變化，但整體**平鋪直敘**，僅能清晰交代事件，缺少深入刻劃。能使用簡單修辭，但效果不突出。常使用虛詞（的、了、地）使文句略嫌鬆散。是合格的應試文章水平，能夠清晰達意。
- **1-4分 (基礎 / 有待改善):** 句式單一、冗長或破碎。文字平淡乏味，**缺乏描寫意識**。大量使用虛詞，文句不通順或口語化嚴重，影響閱讀流暢度。
特別注意：不要輕易給予高分，必須有充分理據。

評分 (0-10): [在此給出「文句文學性」的獨立分數]
</eval_item>


</step_1_independent_evaluation>


<step_2_high_score_validation>
[**高分驗證機制**：這是一個強制執行的覆核步驟。]
IF '扣題分數評估' >= 9 THEN
<re-evaluation name="立意分數覆核">
質疑：文章的主題思想是否真的深刻新穎，或僅僅是一個完美切題的「陳腔濫調」？（例如：《等待》寫等待母親，立意僅停留在「要珍惜親人」，這就是切題但膚淺）。
規則：完美切題但立意陳腐或淺白的文章，其「立意」分數**絕不能超過6分**。請將其與5**範文的哲理深度進行比較，然後給出最終修正分數。
修正後的立意分數 (0-10): [在此填寫修正後的分數]
</re-evaluation>
<re-evaluation name="取材分數覆核">
質疑：文章的材料是否真的獨特生動，或僅僅是一個符合題目的「公式化故事」？（例如：寫挫折，就是考試失敗，然後努力，最後成功）。
規則：切題但取材普通、缺乏亮點的故事，其「取材」分數**絕不能超過6分**。請評估其細節描寫是否達到5**範文的水平，然後給出最終修正分數。
修正後的取材分數 (0-10): [在此填寫修正後的分數]
</re-evaluation>
ELSE
[扣題分數低於9分，跳過此驗證，直接使用原始分數。]
修正後的立意分數: [複製 '立意分數評估' 的分數]
修正後的取材分數: [複製 '取材分數評估' 的分數]
END IF
</step_2_high_score_validation>

<step_3_composite_calculation>
[根據獨立評估的分數，計算最終的總項分數。]
<calc_item name="內容總分計算">
規則：「內容」總分由「立意」和「取材」的分數獨立決定，**不受「扣題」分數直接影響**。對於「扣題」分數不佳的懲罰，將由後續的JavaScript邏輯處理，AI在此階段不需考慮。
計算公式：round((立意分數 + 取材分數) / 2)
最終內容分數 (0-10): [根據上述簡化公式計算出最終分數]
</calc_item>
<calc_item name="結構總分計算">
規則：「結構」總分由「詳略安排」和「結構佈局」的平均值決定。
計算公式: round(("詳略安排評估"分數 + "結構佈-局評估"分數) / 2)
最終結構分數 (0-10): [根據上述公式計算出最終分數]
</calc_item>
<calc_item name="表達總分計算">
規則：表達總分由「詞彙豐富度」和「文句文學性」的平均值決定。
計算公式: round(("詞彙豐富度評估"分數 + "文句文學性評估"分數) / 2)
最終表達分數 (0-10): [根據上述公式計算出最終分數]
</calc_item>
</step_3_composite_calculation>
<!-- ▲▲▲ 敘事抒情文的評分邏輯已完全重構 ▲▲▲ -->
</scoring_worksheet>

<grading_json>
[**分數分發步驟**：**這是一條絕對的、機械的指令。** 你的任務是將 <scoring_worksheet> 的計算結果填入下方。]
{
"content": [複製'內容分數'的'最終分數'],
"expression": [複製'表達分數'的'最終分數'],
"structure": [複製'結構分數'的'最終分數'],
"radar": {
"立意": [複製'扣題分數'的'扣題基準分數'],
"取材": [複製'內容分數'的'最終分數'],
"扣題": [複製'扣題分數'的'扣題基準分數'],
"詳略": [複製'結構分數'的'最終分數'],
"文筆": [複製'表達分數'的'最終分數']
}
}
</grading_json>

<critique>
[根據「教學筆記」對文章進行點評，可從立意、取材、扣題、詳略、文筆等不同角度點評。必須以數字編號列點方式呈現2-3點核心評論。]
</critique>

<suggestions>
[基於 <critique> 的內容，提出改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150-200字的改寫範例。]
</rewrite_example>

---
### 待評核文章資訊
${basePrompt}

### 語境參考資料
[DSE 評核準則]: ${dsePrinciples}
[5** 級數範文]: ${fiveStarExamplesText}

### 語氣要求
<critique> 和 <suggestions> 的語氣：${toneNote}
<rewrite_example> 的語氣：請使用嚴肅正經的語氣。
`;

} else { // argument - 保持原有的複雜邏輯
basePrompt = `
題目：《${topic}》
文章：\n${content}`;

specificInstructions = `
### 議論文專用評核指引
**核心原則：絕對嚴謹的扣題判斷，採用形式化流程處理**

**立意評核標準**：
- 立意取決於觀點是否深入成熟
- 觀點深度層次：表面現象 → 深層原因 → 人生哲理
- 成熟度判斷：是否具備成年人的思辨深度

**取材評核標準**：
- 取材取決於論據是否充實，涵蓋古今中外
- 論據適用性：論據是否切合這道具體題目
- 覆蓋範圍：古代、現代、中外例證的平衡性

**內容與結構分數限制規則**：
- 即使扣題分數很高，但如果立意和取材分數低，其「內容」和「結構」分最高只能得5分
- 計算方式：內容分數 = min(5, 原計算分數) if (立意分數 ≤ 4 OR 取材分數 ≤ 4)
- 計算方式：結構分數 = min(5, 原計算分數) if (立意分數 ≤ 4 OR 取材分數 ≤ 4)

- **形式化扣題檢測流程**：
* 步驟1：提取題目核心關鍵詞（去除「論」、「談」等前綴詞）
* 步驟2：識別文章主要論述對象的關鍵詞
* 步驟3：執行字符串精確比對（character-by-character matching）
* 步驟4：IF (題目關鍵詞 === 文章關鍵詞) THEN 緊扣 ELSE 偏題/離題

- **嚴格判定規則（無例外執行）**：
* 關鍵詞完全匹配（===） = 緊扣（5-10分）
* 關鍵詞不匹配（!==） = 偏題（一般直接評為4分即可，極少情況會評為1至2分）或離題（一般直接評為3分即可，極少情況會評為1至2分）
* 題目《論禮貌》vs 文章論「禮物」→ 「禮貌」!==「禮物」→ 偏題（一般直接評為4分即可，極少情況會評為1至2分）
* 題目《論競爭》vs 文章論「合作」→ 「競爭」!==「合作」→ 偏題（一般直接評為4分即可，極少情況會評為1至2分）

例如：題目為《論禮貌》，但文中多論「禮物」，都屬於偏題，《禮貌》是一個更寬的概念，「禮貌」會包含「禮物」這個更狹窄的概念，絕不可用狹窄的概念論述寬泛的概念

- **禁止的判斷方式**：
* ❌ 語意相近性判斷（如「禮貌」與「禮儀」相近）
* ❌ 概念關聯性判斷（如「競爭」與「合作」有關聯）
* ❌ 邏輯推演判斷（如「責任心」包含「責任」）
* ❌ 文學創意判斷（如「以禮物論禮貌」的創意寫法）

- **強制執行機制**：
* 系統性：每篇文章必須執行完整的4步驟檢測流程
* 客觀性：僅基於字符串比對結果，不加入主觀判斷
* 一致性：相同字符串比對結果必須得出相同評級
* 嚴謹性：寧可誤判為偏題，不可誤判為緊扣

**範例執行**：
題目《論禮貌》：
- 文章論「禮貌」→ 「禮貌」===「禮貌」→ TRUE → 緊扣
- 文章論「禮物」→ 「禮貌」===「禮物」→ FALSE → 偏題 
- 文章論「禮儀」→ 「禮貌」===「禮儀」→ FALSE → 偏題
- 文章論「送禮」→ 「禮貌」===「送禮」→ FALSE → 偏題`;

// 議論文保持原有的複雜評分邏輯
return `你將扮演一個絕對理性的AI評卷員，你的核心任務是完成一份計分工作紙，然後根據工作紙的結果生成報告。

### 你的工作流程 (必須嚴格依序執行)

1. **填寫工作紙**: 這是你的首要且最重要的任務。在 <scoring_worksheet> 標籤內，完成所有計算。
2. **分發分數到JSON**: **絕對禁止重新思考分數**。你將扮演一個數據錄入員，將 <scoring_worksheet> 中計算出的分數，精確地分發到 <grading_json> 的對應欄位。
3. **撰寫報告**: 根據 <grading_json> 的最終分數，撰寫 <critique> 等文字報告，確保文字與數字完全對應。

${specificInstructions}

---

### 你的輸出格式 (必須嚴格遵守此結構與順序)

<scoring_worksheet>
[**計分工作紙**：你必須像執行程式碼一樣，完成以下所有步驟。]
<step_1_topic_analysis>
<topic_keywords>題目關鍵詞: [提取題目的核心概念，如「禮貌」]</topic_keywords>
<article_focus>文章論述焦點: [識別文章主要論述的核心概念，如「禮物」、「送禮」]</article_focus>
<concept_match>概念匹配度: [比較題目關鍵詞與文章焦點是否一致]</concept_match>
</step_1_topic_analysis>

<step_2_strict_topic_judgement>
<critical_check>
**絕對嚴格扣題檢查**：
- 題目核心關鍵詞: [提取題目去除助詞後的核心概念]
- 文章核心論述詞: [識別文章主要論述的核心詞匯]
- 字面一致性檢查: [兩詞是否完全相同，YES/NO]
- 關鍵詞出現頻率: [該關鍵詞在文章中的使用次數]
- 關鍵詞重要性: [該關鍵詞是否為文章論述主線]

**形式化判斷標準**：
- 如果文章論述的核心詞匯與題目關鍵詞字面不同（如「禮貌」vs「禮物」、「責任」vs「負責」、「寬容」vs「包容」），無論內容多優秀，強制判定為「偏題」
- 如果關鍵詞雖然相同但使用頻率極低或非論述主線，判定為「偏題」
- 偏題文章扣題分數：4分或以下
- 離題文章扣題分數：3分或以下
</critical_check>

<final_topic_judgement>[基於上述形式化檢查，強制填寫「離題」、「偏題」或「緊扣」，不得有任何例外]</final_topic_judgement>
</step_2_strict_topic_judgement>

<step_3_base_scores>
<judgement_item name="表達水平">[在此獨立評估文筆，填寫「優良」、「普通」或「欠佳」]</judgement_item>
</step_3_base_scores>

<step_4_calculation>
<calc_item name="扣題分數計算（絕對基準）">
判斷結果: [複製上面的'final_topic_judgement']
**強制執行規則**：
- IF '離題' THEN 扣題分數 = 1-3分（一般直接評為3分即可，極少情況會評至1至2分）
- IF '偏題' THEN 扣題分數 = 1-4分（一般直接評為4分即可，極少情況會評至1至2分）
- IF '緊扣' THEN 扣題分數 = 5-10分

**特別注意**：任何概念置換（如禮貌→禮物、責任→負責、寬容→包容）必須判定為偏題，如題目為《論禮貌》，但文中多論「禮物」，都屬於偏題，《禮貌》是一個更寬的概念，「禮貌」會包含「禮物」這個更狹窄的概念，絕不可用狹窄的概念論述寬泛的概念，扣題分數絕對不得超過4分，扣題絕對不能打5分或以上。

最終扣題分數 (1-10): [嚴格按照上述規則給分，不允許任何例外]
</calc_item>

<calc_item name="內容分數計算">
規則: 偏題或離題情況下，內容分數不得超過扣題分數且有絕對上限
基於扣題分數: [複製上面的扣題分數]
**嚴格限制**：
- 偏題情況：內容分數絕對上限4分，一般直接評為4分即可，極少情況會評至1至2分
- 離題情況：內容分數絕對上限3分，一般直接評為3分即可，極少情況會評至1至2分
最終內容分數 (1-10): [不得超過扣題分數且不得超過上述絕對上限]
</calc_item>

<calc_item name="結構分數計算">
規則: 偏題或離題情況下，結構分數不得超過扣題分數且有絕對上限
基於扣題分數: [複製上面的扣題分數]
**嚴格限制**：
- 偏題情況：結構分數絕對上限4分，一般直接評為4分即可，極少情況會評至1至2分
- 離題情況：結構分數絕對上限3分，一般直接評為3分即可，極少情況會評至1至2分
最終結構分數 (1-10): [不得超過扣題分數且不得超過上述絕對上限]
</calc_item>

<calc_item name="表達分數計算（相對獨立）">
判斷: [複製上面的'表達水平']
規則: IF '優良' THEN score=7-9; IF '普通' THEN score=4-6; ELSE score=1-3
最終表達分數 (1-10): [按此規則給分]
</calc_item>


<calc_item name="立意分數計算">
評估觀點深度: [判斷觀點是否深入成熟，填寫「深入成熟」、「一般」或「膚淺」]
**評分標準**：
- IF '深入成熟' THEN 立意分數 = 7-10分
- IF '一般' THEN 立意分數 = 4-6分 
- IF '膚淺' THEN 立意分數 = 1-3分
最終立意分數 (1-10): [按此規則給分]
</calc_item>

<calc_item name="取材分數計算">
論據充實度: [評估論據是否充實涵蓋古今中外]
論據適用性: [評估論據是否適用於論述這道題目]
**評分標準**：
- 充實且適用 THEN 取材分數 = 7-10分
- 一般程度 THEN 取材分數 = 4-6分
- 不足或不適用 THEN 取材分數 = 1-3分
最終取材分數 (1-10): [按此規則給分]
</calc_item>

<calc_item name="內容與結構分數限制檢查">
立意分數: [複製上面的立意分數]
取材分數: [複製上面的取材分數]
**強制限制規則**：
- IF (立意分數 ≤ 4 OR 取材分數 ≤ 4) THEN 內容分數上限 = 5分且結構分數上限 = 5分
- 即使扣題很高，但立意或取材低分時，內容和結構都不能超過5分

內容分數修正: [根據上述規則修正內容分數，不得超過5分if條件符合]
結構分數修正: [根據上述規則修正結構分數，不得超過5分if條件符合]
</calc_item>


</step_4_calculation>
</scoring_worksheet>

<grading_json>
{
"content": [複製'內容分數'的'最終分數'],
"expression": [複製'表達分數'的'最終分數'],
"structure": [複製'結構分數'的'最終分數'],
"radar": {
"立意": [複製'扣題分數'的'扣題基準分數'],
"取材": [複製'內容分數'的'最終分數'],
"扣題": [複製'扣題分數'的'扣題基準分數'],
"詳略": [複製'結構分數'的'最終分數'],
"文筆": [複製'表達分數'的'最終分數']
}
}
</grading_json>

<critique>
[根據「教學筆記」對文章進行點評，可從立意、取材、扣題、詳略、文筆等不同角度點評。必須以數字編號列點方式呈現2-3點核心評論。]
</critique>

<suggestions>
[基於 <critique> 的內容，提出改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150-200字的改寫範例。]
</rewrite_example>

---
### 待評核文章資訊
${basePrompt}

### 語境參考資料
[DSE 評核準則]: ${dsePrinciples}
[5** 級數範文]: ${fiveStarExamplesText}

### 語氣要求
<critique> 和 <suggestions> 的語氣：${toneNote}
<rewrite_example> 的語氣：請使用嚴肅正經的語氣。


### 【重要】概念辨識檢查清單
在評分前，必須完成以下檢查：
□ 題目核心概念是什麼？
□ 文章主要論述什麼概念？ 
□ 兩個概念是否完全相同？
□ 是否存在概念置換問題？

**常見偏題案例**：
- 題目《論禮貌》→ 文章論述禮物/送禮 = 偏題
- 題目《論堅持》→ 文章論述堅定 = 偏題
- 題目《論競爭》→ 文章論述合作 = 偏題

記住：邏輯相關 ≠ 概念相同，必須嚴格區分！



`;
}
}

/**
 * 【最終修訂版】顯示完整的點評、評分系統，並根據最終等級和所選閱卷員調整內容
 * @param {string} containerId - 顯示結果的容器ID
 * @param {string} originalApiResponse - 原始模型的API回應
 * @param {string} llama3ApiResponse - 驗證模型的API回應 (可選)
 * @param {string} uniqueIdPrefix - 用於區分不同評分系統的唯一前綴
 * @param {string} fullTextContent - 用戶提交的完整文章內容
 */
async function displayFullCommentWithGrading(containerId, originalApiResponse, llama3ApiResponse, uniqueIdPrefix, fullTextContent) {
    // 1. 先找出閱卷員的名字
    let reviewerName = "陳SIR"; 
    let reviewerSelect;
    let currentTone = "serious"; 
    
    if (uniqueIdPrefix === 'narrative') {
        reviewerSelect = document.getElementById('writingReviewer');
        const toneEl = document.getElementById('writingTone');
        if (toneEl) currentTone = toneEl.value;
    } else if (uniqueIdPrefix === 'argument') {
        reviewerSelect = document.getElementById('argumentReviewer');
        const toneEl = document.getElementById('argumentWritingTone'); 
        if (toneEl) currentTone = toneEl.value;
    }

    if (reviewerSelect) {
        reviewerName = reviewerSelect.options[reviewerSelect.selectedIndex].text;
        reviewerName = reviewerName.replace(/\s*\(預設\)\s*/, ''); 
    }

    // 2. 打開畫布
    openResultCanvas(reviewerName + " 評核報告");
    const resultContainer = document.getElementById("resultCanvasBody");

    // 3. 處理舊的雷達圖實例
    const instanceName = `${uniqueIdPrefix}_radarChartInstance`;
    if (window[instanceName]) {
        window[instanceName].destroy();
        window[instanceName] = null;
    }
    
    let finalHTML = `<h3>${reviewerName}點評：</h3>`;
    
    let scoresForDisplay = null;
    let finalGradeForDisplay = "評級中"; 

    // 使用 i 標誌來忽略大小寫匹配標籤
    const critiqueMatch = originalApiResponse.match(/<critique>([\s\S]*?)<\/critique>/i);
    const suggestionsMatch = originalApiResponse.match(/<suggestions>([\s\S]*?)<\/suggestions>/i);
    const rewriteMatch = originalApiResponse.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/i);
    const originalGradingMatch = originalApiResponse.match(/<grading_json>([\s\S]*?)<\/grading_json>/i);
    
    // --- 分數解析邏輯 ---
    if (uniqueIdPrefix === 'narrative') {
        const llama3GradingMatch = llama3ApiResponse ? llama3ApiResponse.match(/<grading_json>([\s\S]*?)<\/grading_json>/i) : null;
        if (originalGradingMatch && originalGradingMatch[1] && llama3GradingMatch && llama3GradingMatch[1]) {
             try {
                const originalScores = JSON.parse(originalGradingMatch[1].trim());
                const llama3Scores = JSON.parse(llama3GradingMatch[1].trim());
                
                // 定義 V8 規則函式 (內部使用)
                const applyV8Rules = (scores) => {
                    let s = JSON.parse(JSON.stringify(scores)); 
                    s.radar = s.radar || {};
                    if (s.radar && s.radar.扣題 !== undefined) {
                        let final = { kouTi: s.radar.扣題, xiangLue: s.radar.詳略, structure: s.structure, liYi: s.radar.立意, quCai: s.radar.取材, ciHui: s.radar.詞彙, wenXueXing: s.radar.文學性, expression: s.expression, content: s.content };
                        if (final.kouTi >= 5) { final.liYi = Math.max(final.liYi, 5); final.quCai = Math.max(final.quCai, 5); }
                        if (final.kouTi <= 5) { final.liYi = Math.min(final.liYi, 5); final.quCai = Math.min(final.quCai, 5); }
                        if (final.kouTi <= 4) { final.xiangLue = Math.min(final.xiangLue, 4); final.structure = Math.min(final.structure, 4); }
                        if (final.ciHui <= 6 && final.wenXueXing <= 6) { final.liYi = Math.min(final.liYi, 6); final.quCai = Math.min(final.quCai, 6); }
                        if (!(final.liYi >= 7 && final.quCai >= 7)) { final.ciHui = Math.min(final.ciHui, 8); final.wenXueXing = Math.min(final.wenXueXing, 8); }
                        final.quCai = Math.min(final.quCai, final.liYi);
                        if (final.kouTi <= 4) { let t = final.kouTi; t = Math.min(t, 4); t = Math.max(t, 2); final.content = t; }
                        else { if (final.liYi === 10 && final.quCai === 10) final.content = 9; else if (final.liYi === 9 && final.quCai === 9) final.content = 8; else if (final.liYi === 8 && final.quCai === 8) final.content = 7; else final.content = Math.round((final.liYi + final.quCai) / 2); }
                        if (final.ciHui < 8 || final.wenXueXing < 8) { final.content = Math.min(final.content, 7); }
                        if (final.ciHui === final.wenXueXing) { final.expression = final.ciHui - 1; } else { final.expression = Math.min(final.ciHui, final.wenXueXing); }
                        const structureLowerBound = final.content - 1;
                        final.structure = Math.min(final.structure, final.content);
                        final.structure = Math.max(final.structure, structureLowerBound);
                        s.content = final.content; s.expression = final.expression; s.structure = final.structure;
                        s.radar.立意 = final.liYi; s.radar.取材 = final.quCai; s.radar.詳略 = final.xiangLue;
                        s.radar.詞彙 = final.ciHui; s.radar.文學性 = final.wenXueXing; s.radar.扣題 = final.kouTi;
                    }
                    return s;
                };
                
                // 定義字數規則 (內部使用)
                const applyWordCountRule = (scores, textContent) => {
                     let s = JSON.parse(JSON.stringify(scores));
                     const wordCount = textContent.length;
                     if (wordCount < 900) {
                        s.content = Math.min(s.content, 5); s.structure = Math.min(s.structure, 5);
                        if (s.radar) { s.radar.立意 = Math.min(s.radar.立意, 5); s.radar.取材 = Math.min(s.radar.取材, 5); s.radar.詳略 = Math.min(s.radar.詳略, 5); }
                     }
                     return s;
                };

                let finalQwenScores = applyV8Rules(originalScores);
                finalQwenScores = applyWordCountRule(finalQwenScores, fullTextContent);
                let finalLlama3Scores = applyWordCountRule(llama3Scores, fullTextContent);
                finalLlama3Scores = applyContentStructureRule(finalLlama3Scores); // 假設此函式已定義

                const totalQwen = (finalQwenScores.content * 4) + (finalQwenScores.expression * 3) + (finalQwenScores.structure * 2) + 5 + 1;
                const totalLlama3 = (finalLlama3Scores.content * 4) + (finalLlama3Scores.expression * 3) + (finalLlama3Scores.structure * 2) + 5 + 1;
                
                if (totalLlama3 > totalQwen) {
                    scoresForDisplay = finalLlama3Scores;
                } else {
                    scoresForDisplay = finalQwenScores;
                }

            } catch (e) {
                console.error("解析評分時出錯:", e);
                scoresForDisplay = null;
            }
        }
    } 
    else if (uniqueIdPrefix === 'argument') {
        if (originalGradingMatch && originalGradingMatch[1]) {
             try {
                scoresForDisplay = JSON.parse(originalGradingMatch[1].trim());
             } catch(e) {
                scoresForDisplay = null;
             }
        }
    }
    
    // 計算最終總分與等級
    if (scoresForDisplay) {
        // 應用最終一致性規則 (扣題<=4 則其他不超4)
        scoresForDisplay = applyFinalConsistencyRule(scoresForDisplay);
        
        const finalTotalScoreAfterRules = (scoresForDisplay.content * 4) + (scoresForDisplay.expression * 3) + (scoresForDisplay.structure * 2) + 5 + 1;
        finalGradeForDisplay = determineGrade(Math.min(finalTotalScoreAfterRules, 100));
    }

    // 字數不足降級處理
    if (scoresForDisplay) {
        const wordCount = fullTextContent.length;
        if (wordCount < 500) {
            scoresForDisplay = {
                content: 1, expression: 1, structure: 1, 
                radar: { "立意": 1, "取材": 1, "扣題": 1, "詳略": 1, "詞彙": 1, "文學性": 1 }
            };
            finalGradeForDisplay = "1";
        }
        else if (wordCount < 800) {
            const gradeHierarchy = ["1", "2", "3", "4", "5", "5*", "5**"];
            const originalGradeIndex = gradeHierarchy.indexOf(finalGradeForDisplay);
            if (originalGradeIndex > gradeHierarchy.indexOf("3")) {
                finalGradeForDisplay = "3";
            }
        }
    }

    // --- AI 點評語氣重寫 (Prompt 結構鎖定) ---
    const originalCritiqueText = critiqueMatch ? critiqueMatch[1].trim() : "未生成點評";
    let finalCritiqueText = originalCritiqueText;
    let critiqueRewriteInstruction = "";

    if (finalGradeForDisplay === "5**") {
        critiqueRewriteInstruction = "點評中應為讚賞。請完全移除所有批評或負面評價。";
    } else if (finalGradeForDisplay === "5*" || finalGradeForDisplay === "5") {
        critiqueRewriteInstruction = "點評主要以讚賞為主，可提及微小的建議。";
    } else if (finalGradeForDisplay === "4") {
        critiqueRewriteInstruction = "點評應有褒有貶，份量大致均衡。";
    } else {
        critiqueRewriteInstruction = "點評以批評為主，集中分析核心問題。";
    }
    
    let emojiInstruction = "";
    if (currentTone === "chen") {
        emojiInstruction = "務必在句子中自然地穿插大量 Emoji (如 😎, 🔥, 👎, 🧐, ✨，表示揶揄時會用🤌這個EMOJI)，讓語氣輕鬆幽默。";
    } else {
        emojiInstruction = "語氣要專業嚴肅，絕對不要使用 Emoji。";
    }

    const rewritePrompt = `請重寫以下點評內容。
    原文：${originalCritiqueText}

    【嚴格重寫要求】
    1. **結構鎖定**：必須嚴格維持原本的列點數量（保持原來的2-3個重點）。**絕對禁止**將內容拆解成瑣碎的短句，或增加額外的點數。
    2. **篇幅鎖定**：每點的分析篇幅必須與原本相若，不可縮寫成一句話。
    3. **評級調整**：${critiqueRewriteInstruction}
    4. **語氣風格**：${emojiInstruction}
    `;

    try {
        // 嘗試重寫點評
        finalCritiqueText = await callReadingAPI(rewritePrompt, 0.5); 
    } catch (e) {
        // 失敗則使用原文
        finalCritiqueText = originalCritiqueText;
    }

    // --- 組合 HTML (關鍵修訂：傳入分數) ---
    if (scoresForDisplay) {
        // ★★★ 關鍵修改：將計算好的 scores 和 grade 傳入，確保 HTML 生成時就有正確數據 ★★★
        finalHTML += createGradingSystemHTML(uniqueIdPrefix, scoresForDisplay, finalGradeForDisplay);
    } else {
        finalHTML += "<p>評等資料不完整。</p>";
    }
    
    if (finalCritiqueText) {
        finalHTML += createBulletedListHTML("點評", finalCritiqueText);
    }
    if (suggestionsMatch && suggestionsMatch[1]) {
        finalHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
    }
    
    if (rewriteMatch && rewriteMatch[1]) {
        const rewriteContent = rewriteMatch[1].trim().replace(/\*/g, '');
        finalHTML += `<div class="rewrite-explanation-container">
            <div class="rewrite-explanation-card">
                <h3>改寫範例</h3>
                <div class="rewrite-content">${rewriteContent}</div>
            </div>
        </div>`;
    }

    // 加入聊天室 HTML
    const chatType = uniqueIdPrefix === 'narrative' ? 'narrative_writing' : 'argument_writing';
    finalHTML += getCanvasChatHTML(chatType);

    // 注入 HTML
    resultContainer.innerHTML = finalHTML;

    // 初始化雷達圖 (雖然 HTML 已經有數據，但 Canvas 仍需 JS 繪製)
    if (scoresForDisplay) {
        setTimeout(() => {
            // 注意：這裡仍然呼叫 initializeGradingSystem 是為了繪製雷達圖
            // 以及確保隱藏的 input 被正確賦值 (如果 createGradingSystemHTML 漏掉的話)
            initializeGradingSystem(uniqueIdPrefix, scoresForDisplay, finalGradeForDisplay);
        }, 50);
    }

    // 儲存到歷史紀錄
    const topic = (uniqueIdPrefix === 'narrative') ? localStorage.getItem("currentTopic") : localStorage.getItem("argumentCurrentTopic");
    
    // 使用 captureContainerHTML 確保儲存時雷達圖不消失 (記得要用不轉圖片的修復版)
    const htmlContent = captureContainerHTML('resultCanvasBody'); 
    
    saveToHistory(
        uniqueIdPrefix === 'narrative' ? "敘事抒情" : "議論", 
        "文章點評", 
        topic || "無題目", 
        `題目：${topic}\n\n文章：${fullTextContent}`, 
        htmlContent,
        scoresForDisplay 
    );
}


// =======================================================
// === 評等系統邏輯結束 ===
// =======================================================

document.addEventListener('DOMContentLoaded', function() {

// --- 為動態生成的「自訂題目」輸入框加上排除標記 ---
const originalShowCustomTopicInput = window.showCustomTopicInput;
window.showCustomTopicInput = function(buttonElement) {
originalShowCustomTopicInput(buttonElement);
const customTopicInput = document.getElementById('customTopic');
if (customTopicInput) {
customTopicInput.classList.add('no-modal-editor');
}
// For writing custom topic with focus and plot
const customTitle = document.getElementById('customTitle');
const customFocus = document.getElementById('customFocus');
const customPlot = document.getElementById('customPlot');
if(customTitle) customTitle.classList.add('no-modal-editor');
if(customFocus) customFocus.classList.add('no-modal-editor');
if(customPlot) customPlot.classList.add('no-modal-editor');
};

const originalShowArgumentCustomTopicInput = window.showArgumentCustomTopicInput;
window.showArgumentCustomTopicInput = function(buttonElement) {
originalShowArgumentCustomTopicInput(buttonElement);
const argumentCustomTopicInput = document.getElementById('argumentCustomTopic');
if (argumentCustomTopicInput) {
argumentCustomTopicInput.classList.add('no-modal-editor');
}
};

const originalShowExpandCustomTopicInput = window.showExpandCustomTopicInput;
window.showExpandCustomTopicInput = function(buttonElement) {
originalShowExpandCustomTopicInput(buttonElement);
const container = document.getElementById('expandCustomTopicInputArea');
if (container) {
container.querySelectorAll('input[type="text"], textarea').forEach(el => el.classList.add('no-modal-editor'));
}
};

// --- 懸浮視窗核心邏輯 ---
const modal = document.getElementById('outline-editor-modal');
const modalTextarea = document.getElementById('modal-textarea');
const modalTitle = document.getElementById('modal-title');
const modalSaveBtn = document.getElementById('modal-save-btn');
const modalCloseBtn = document.getElementById('modal-close-btn');

if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
console.error("懸浮視窗的 HTML 結構不完整或未找到！");
return;
}

let currentEditingElement = null;

function openModalEditor(element) {
currentEditingElement = element;
modalTextarea.value = currentEditingElement.value;
let titleText = '編輯內容';

if (element.id === 'writingContent' || element.id === 'argumentWritingContent') {
titleText = '輸入您的文章';
} else {
const parentTableCell = element.closest('td');
if (parentTableCell) {
const parentRow = parentTableCell.closest('tr');
if (parentRow) {
const headerCell = parentRow.cells[0];
const table = parentRow.closest('table');
if (table && table.rows.length > 0) {
const columnHeaderCell = table.rows[0].cells[parentTableCell.cellIndex];
const rowTitle = headerCell ? headerCell.textContent.trim().replace(/[:：]/g, '') : '';
const colTitle = columnHeaderCell ? columnHeaderCell.textContent.trim().replace(/[:：]/g, '') : '';
if (rowTitle && colTitle && rowTitle !== colTitle) {
titleText = `編輯「${rowTitle}」的「${colTitle}」`;
} else if (rowTitle) {
titleText = `編輯「${rowTitle}」`;
} else if (colTitle) {
titleText = `編輯「${colTitle}」`;
}
}
}
} else {
let associatedLabel = document.querySelector(`label[for="${element.id}"]`);
if (!associatedLabel) {
const parentContainer = element.closest('div');
if (parentContainer) {
associatedLabel = parentContainer.querySelector('label');
}
}
if (associatedLabel) {
titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
}
}
}
modalTitle.textContent = titleText;
modal.style.display = 'flex';
modalTextarea.focus();
}

function closeModalEditor() {
modal.style.display = 'none';
currentEditingElement = null;
}

function saveAndCloseEditor() {
if (currentEditingElement) {
currentEditingElement.value = modalTextarea.value;
if (currentEditingElement.id === 'expandContent') {
updateCharCount();
}
}
closeModalEditor();
}

document.body.addEventListener('click', function(event) {
const target = event.target;
const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
const isTextarea = target.tagName === 'TEXTAREA';
if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
event.preventDefault();
openModalEditor(target);
}
});

modalSaveBtn.addEventListener('click', saveAndCloseEditor);
modalCloseBtn.addEventListener('click', closeModalEditor);


// --- OCR 整合邏輯 ---
const ocrBtn = document.getElementById('modal-ocr-btn');
let ocrWindow = null;
const VERCEL_OCR_URL = 'https://gemini-ocr-proxy.vercel.app/';

if (ocrBtn) {
ocrBtn.addEventListener('click', function() {
if (ocrWindow && !ocrWindow.closed) {
ocrWindow.focus();
return;
}
ocrWindow = window.open(VERCEL_OCR_URL, 'OCRWindow', 'width=650,height=850,scrollbars=yes,resizable=yes');
});
}

window.addEventListener('message', function(event) {
if (event.origin !== new URL(VERCEL_OCR_URL).origin) {
console.warn('收到來源不明的訊息，已忽略:', event.origin);
return;
}
if (event.data && event.data.type === 'ocrResult') {
const ocrText = event.data.text;
modalTextarea.value += (modalTextarea.value.trim() ? '\n' : '') + ocrText;
if (ocrWindow) {
ocrWindow.close();
}
modalTextarea.focus();
}
});
});

/**
 * 【最終把關規則修訂 v3】
 * 當「扣題」分數為 4 分或以下時，強制將多個核心項目分數的上限限制在 4 分。
 * @param {object} scores - 從 AI 模型解析或初步處理後的原始評分物件。
 * @returns {object} - 經過此規則嚴格調整後的最終評分物件。
 */
function applyFinalConsistencyRule(scores) {
    // 建立一個分數物件的深層複本，避免直接修改傳入的物件
    let s = JSON.parse(JSON.stringify(scores)); 
    
    // 從 radar 物件中安全地獲取「扣題」分數，若不存在則預設為 0
    const kouTi = s.radar ? s.radar.扣題 || 0 : 0;
    
    // 【核心修訂】將觸發條件從 <= 5 改為 <= 4
    if (kouTi <= 4) {
        console.log(`觸發扣題分數把關規則 v3：偵測到扣題分數 (${kouTi}) 低於或等於 4，將相關分數上限設為 4。`);

        // 使用 Math.min() 確保分數不會超過 4。
        // 如果原始分數低於 4（例如 3），則會保留較低的 3 分。
        // 如果原始分數高於 4（例如 6），則會被強制降為 4 分。
        
        // 1. 強制限制雷達圖中的「立意」、「取材」、「詳略」分數
        if (s.radar) {
            s.radar.立意 = Math.min(s.radar.立意, 4);
            s.radar.取材 = Math.min(s.radar.取材, 4);
            s.radar.詳略 = Math.min(s.radar.詳略, 4);
        }

        // 2. 強制限制總項分數中的「內容」和「結構」分數
        s.content = Math.min(s.content, 4);
        s.structure = Math.min(s.structure, 4);
    }
    
    // 在控制台中輸出日誌，方便追蹤規則是否被正確應用及其調整結果
    console.log(`扣題把關規則 v3 應用後：扣題=${kouTi}，調整後立意=${s.radar ? s.radar.立意 : 'N/A'}，取材=${s.radar ? s.radar.取材 : 'N/A'}，詳略=${s.radar ? s.radar.詳略 : 'N/A'}，內容=${s.content}，結構=${s.structure}`);
    
    // 返回經過嚴格調整後的分數物件
    return s;
}



document.addEventListener('DOMContentLoaded', function() {
    const sideMenuToggle = document.getElementById('sideMenuToggle');
    const sideMenu = document.getElementById('sideMenu');
    const sideMenuHomeBtn = document.getElementById('sideMenuHomeBtn');
    const sideMenuCloudBtn = document.getElementById('sideMenuCloudBtn'); // 獲取雲端按鈕

    // 1. 漢堡選單點擊邏輯 (你的新代碼)
    sideMenuToggle.onclick = function(e) {
        e.stopPropagation();
        if (sideMenu.classList.contains('active')) {
            sideMenu.classList.remove('active');
            sideMenuToggle.classList.remove('active');
        } else {
            sideMenu.classList.add('active');
            sideMenuToggle.classList.add('active');
            
            // === 判斷當前頁面狀態以決定按鈕顯示 ===
            const isOnMainPage = document.querySelector('.title-container').style.display !== 'none';
            const isOnToolsPage = document.getElementById('toolsContainer2').style.display === 'flex';
            const isOnCloudPage = document.getElementById('studentCloudModal').style.display === 'block'; // 檢查是否在課業狀態
            
            // 邏輯判斷
            if (isOnCloudPage) {
                // 如果在「課業狀態」頁面
                if (sideMenuHomeBtn) sideMenuHomeBtn.style.display = 'flex';  // 顯示返回主頁
                if (sideMenuCloudBtn) sideMenuCloudBtn.style.display = 'none'; // 隱藏課業狀態按鈕
            } 
            else if (isOnToolsPage) {
                // 如果在「工具一覽」頁面
                if (sideMenuHomeBtn) sideMenuHomeBtn.style.display = 'flex';
                if (sideMenuCloudBtn) sideMenuCloudBtn.style.display = 'flex'; 
            }
            else if (isOnMainPage) {
                // 如果在「主頁」
                if (sideMenuHomeBtn) sideMenuHomeBtn.style.display = 'none'; 
                if (sideMenuCloudBtn) sideMenuCloudBtn.style.display = 'flex'; 
            } 
            else {
                // 其他功能頁面 (如寫作、閱讀等)
                if (sideMenuHomeBtn) sideMenuHomeBtn.style.display = 'flex';
                if (sideMenuCloudBtn) sideMenuCloudBtn.style.display = 'flex';
            }
        }
    };

    // 2. 點擊選單項目後自動收起選單 (補回此功能)
    const menuItems = document.querySelectorAll('.side-menu-item');
    menuItems.forEach(item => {
        item.addEventListener('click', function() {
            sideMenu.classList.remove('active');
            sideMenuToggle.classList.remove('active');
        });
    });

    // 3. 點擊頁面空白處收起選單 (補回此功能)
    document.addEventListener('click', function(e) {
        if (sideMenu.classList.contains('active') && 
            !sideMenu.contains(e.target) && 
            e.target !== sideMenuToggle) {
            sideMenu.classList.remove('active');
            sideMenuToggle.classList.remove('active');
        }
    });
});

// 從側邊選單打開工具一覽
function openToolsFromSideMenu() {
    document.getElementById('sideMenu').classList.remove('active');
    document.getElementById('expandToolsBtn2').click(); // 觸發原有的工具一覽邏輯
}

// 切換音樂播放器顯示/隱藏
function toggleMusicPlayer() {
    const musicPlayer = document.getElementById('music-player');
    
    if (musicPlayer.style.display === 'none' || musicPlayer.style.display === '') {
        musicPlayer.style.display = 'flex';
        // 移除下面這行：showPlayerBtn.style.display = 'none';
    } else {
        musicPlayer.style.display = 'none';
        // 移除下面這行：showPlayerBtn.style.display = 'block';
    }
    
    // 收起側邊選單
    document.getElementById('sideMenu').classList.remove('active');
}

// === 優化版：帶動畫的返回主頁 ===
const performReturnToHomeLogic = window.returnToHome || function() {}; // 備份舊邏輯引用(如果有的話)

// === 優化版：帶動畫的返回主頁 (修復滾動鎖定與視窗殘留) ===
// === 優化版：帶動畫的返回主頁 (已修復：自動關閉課業狀態) ===
window.returnToHome = function() {
    // 1. 找出當前正在顯示的容器 (加入 studentCloudModal)
    const activeContainer = document.querySelector(
        '#writingContainer[style*="display: block"], ' +
        '#readingContainer[style*="display: block"], ' +
        '#booksContainer[style*="display: block"], ' +
        '#expandContainer[style*="display: block"], ' +
        '#argumentContainer[style*="display: block"], ' +
        '#historyContainer[style*="display: block"], ' +
        '#toolsContainer2[style*="display: flex"], ' + 
        '#studentCloudModal[style*="display: block"]' // <--- 新增這行偵測
    );

    // 2. 如果找到了正在顯示的頁面，先播動畫
    if (activeContainer) {
        activeContainer.classList.add('page-exit-shrink');

        // 3. 等待動畫播完再執行清理
        setTimeout(() => {
            // A. 隱藏所有主要功能容器 (加入 studentCloudModal)
            const containers = [
                'writingContainer', 
                'readingContainer', 
                'booksContainer', 
                'expandContainer', 
                'argumentContainer', 
                'historyContainer', 
                'toolsContainer2',
                'studentCloudModal' // <--- 關鍵：加入課業狀態視窗 ID
            ];
            
            containers.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = "none";
                    el.classList.remove('page-exit-shrink');
                    el.style.opacity = "";
                    el.style.transform = "";
                }
            });

            // ★★★ B. 關鍵修復：解鎖頁面捲動 (因為課業狀態鎖住了它) ★★★
            document.body.style.overflow = 'auto'; 
            document.body.style.height = 'auto'; 

            // C. 恢復主頁背景
            document.body.style.backgroundImage = `url('${scenes['home']}')`;
            document.body.style.backgroundColor = '';

            // D. 顯示主頁元素
            document.querySelector('.title-container').style.display = 'block';
            document.getElementById('hitokoto-container').style.display = 'block';
            document.getElementById('mainMenuBox').style.display = 'block';
            
            // E. 顯示 DSE 倒數
            const dseBox = document.getElementById('dse-countdown-box');
            if (dseBox) dseBox.style.display = 'flex';

            // F. 隱藏返回按鈕
            document.getElementById('sideMenuHomeBtn').style.display = 'none';
            document.getElementById('homeBtn').style.display = 'none';

            // G. 移除卡片 active 狀態
            document.querySelectorAll('.anime-card').forEach(card => card.classList.remove('active'));

            // H. 收起側邊選單
            const sideMenu = document.getElementById('sideMenu');
            if (sideMenu) {
                sideMenu.classList.remove('active');
                document.getElementById('sideMenuToggle').classList.remove('active');
            }
            
            // I. 隱藏儲存按鈕
            hideAllSaveHtmlButtons();

            // J. 確保舊版工具箱隱藏
            const toolsBox = document.getElementById('toolsBox');
            if (toolsBox) toolsBox.style.display = 'none';

            // K. 隱藏其他模態視窗
            const historyModal = document.getElementById('historyModal');
            if (historyModal) historyModal.style.display = 'none';
            
            const outlineModal = document.getElementById('outline-editor-modal');
            if (outlineModal) outlineModal.style.display = 'none';

            const previewModal = document.getElementById('previewModal');
            if (previewModal) {
                previewModal.style.display = 'none';
                const iframe = document.getElementById('previewIframe');
                if (iframe) iframe.src = 'about:blank';
            }

            const videoModal = document.getElementById('videoModal');
            if (videoModal) {
                videoModal.style.display = 'none';
                const vIframe = document.getElementById('videoIframe');
                if (vIframe) vIframe.src = '';
            }

            // M. 滾動到頂部
            window.scrollTo({ top: 0, behavior: 'instant' });

            // N. 觸發主頁進場動畫
            const mainMenu = document.getElementById('mainMenuBox');
            const dse = document.getElementById('dse-countdown-box');
            
            if (mainMenu) {
                mainMenu.classList.remove('home-enter-pop');
                void mainMenu.offsetWidth; 
                mainMenu.classList.add('home-enter-pop');
            }
            if (dse) {
                dse.classList.remove('home-enter-pop');
                void dse.offsetWidth;
                dse.classList.add('home-enter-pop');
            }

        }, 350); 
        
    } else {
        // 如果沒有偵測到活動頁面，保險起見解鎖滾動並重整
        document.body.style.overflow = 'auto'; 
        location.reload(); 
    }
};

// ==========================================
// === IndexedDB 歷史紀錄系統 (V2 層級版) ===
// ==========================================

const DB_NAME = 'SansiDB';
const DB_VERSION = 1;
const STORE_NAME = 'history';

// 定義層級結構 (主範疇 -> 子功能)
const HISTORY_STRUCTURE = {
    "閱讀": ["點評", "指引"],
    "敘事抒情": ["文章點評", "大綱點評", "解題指引", "敘事物象"],
    "議論": ["文章點評", "大綱點評", "指引"],
    "整合拓展": ["點評", "指引"]
};

// 1. 初始化資料庫 (保持不變)
function openHistoryDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = function(event) {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                store.createIndex('timestamp', 'timestamp', { unique: false });
                store.createIndex('category', 'category', { unique: false });
                store.createIndex('subFunction', 'subFunction', { unique: false });
            }
        };
        request.onsuccess = function(event) { resolve(event.target.result); };
        request.onerror = function(event) { reject(event.target.error); };
    });
}

// 2. ★ 核心輔助：捕捉 HTML 並將 Canvas 轉為圖片 ★
// ★ 核心輔助：捕捉 HTML (修訂版：只捕捉結構，不轉圖片) ★
function captureContainerHTML(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return "";

    // 1. 複製節點
    const clone = container.cloneNode(true);

    // 2. 處理 Canvas：保留標籤，但強制設定高度，避免在歷史紀錄中塌陷
    const canvases = clone.querySelectorAll('canvas');
    canvases.forEach(canvas => {
        // 關鍵：給予明確的高度，確保 Chart.js 稍後有空間繪圖
        canvas.setAttribute('style', 'width: 100%; height: 350px; display: block;');
        // 移除 id 屬性，避免與主頁面的圖表 ID 衝突 (會在查看時動態處理)
        canvas.removeAttribute('id'); 
        // 添加一個通用 class 方便識別
        canvas.classList.add('history-radar-canvas');
    });

    // 3. 捕捉進度條 (藍色 BAR) 的寬度
    const progressBars = clone.querySelectorAll('.progress-bar-fill');
    const originalBars = container.querySelectorAll('.progress-bar-fill');
    for (let i = 0; i < progressBars.length; i++) {
        if (originalBars[i]) {
            progressBars[i].style.width = originalBars[i].style.width;
        }
    }

    // 4. 處理表單元素 (Textarea / Input)
    const textareas = clone.querySelectorAll('textarea');
    const originalTextareas = container.querySelectorAll('textarea');
    for (let i = 0; i < textareas.length; i++) {
        if (originalTextareas[i]) {
            textareas[i].textContent = originalTextareas[i].value;
        }
    }

    const inputs = clone.querySelectorAll('input');
    const originalInputs = container.querySelectorAll('input');
    for (let i = 0; i < inputs.length; i++) {
        if (originalInputs[i]) {
            inputs[i].setAttribute('value', originalInputs[i].value);
        }
    }

    return clone.innerHTML;
}

// 1. 修改 saveToHistory：存入 IndexedDB 後自動觸發雲端同步
async function saveToHistory(category, subFunction, title, userContent, aiContent, scoreData = null) {
    try {
        // ============================================================
        // ★★★ 核心修訂：在上傳前徹底移除聊天室/追問區 HTML ★★★
        // ============================================================
        if (aiContent && typeof aiContent === 'string') {
            // 建立一個暫時的 DOM 元素來處理 HTML 字串
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = aiContent;
            
            // 1. 移除主要的聊天室容器 (.canvas-chat-container)
            // 使用 querySelectorAll 確保移除頁面上所有可能的聊天室實例
            const chatContainers = tempDiv.querySelectorAll('.canvas-chat-container');
            chatContainers.forEach(el => el.remove());

            // 2. 保險起見，移除聊天輸入區 (.canvas-input-area) 和 歷史區 (.canvas-chat-history)
            // 防止有殘留的 HTML 結構
            const inputAreas = tempDiv.querySelectorAll('.canvas-input-area');
            inputAreas.forEach(el => el.remove());
            
            const historyBoxes = tempDiv.querySelectorAll('.canvas-chat-history');
            historyBoxes.forEach(el => el.remove());
            
            // 將處理乾淨的 HTML 重新賦值給 aiContent
            aiContent = tempDiv.innerHTML;
        }
        // ============================================================

        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);

        const record = {
            category: category,
            subFunction: subFunction,
            title: title || "無標題",
            userContent: userContent,
            aiContent: aiContent, // 這裡是已經過濾掉聊天室的內容
            scoreData: scoreData, 
            timestamp: new Date().getTime(),
            dateStr: new Date().toLocaleString('zh-HK', { hour12: false })
        };

        store.add(record);
        console.log("本地紀錄已儲存 (已過濾追問區)");
        
        // 檢查是否已綁定身份，如果是，則自動同步
        const s = JSON.parse(localStorage.getItem('studentProfile'));
        if (s) {
            syncHistoryToFirebase(true); 
        }

    } catch (error) {
        console.error("儲存紀錄失敗:", error);
    }
}



// ==========================================
// === 智能同步邏輯 (最終修訂版：已修復反引號語法錯誤) ===
// ==========================================

// ==========================================
// === 智能同步邏輯 (最終解決版：智能標記) ===
// ==========================================



// ==========================================
// === 即時自動同步監聽器 (防無限迴圈版) ===
// ==========================================

let autoSyncListenerRef = null;
let isSyncingLock = false; // 鎖定狀態，防止無限迴圈

function startAutoSyncListener() {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (!s) return;

    // 先移除舊的監聽器，避免重複
    if (autoSyncListenerRef) {
        autoSyncListenerRef.off();
    }

    // 監聽路徑：該學生的歷史紀錄
    // 注意：這裡有反引號 `
    const path = `students/${s.grade}/${s.class}/${s.name}/history`;
    autoSyncListenerRef = database.ref(path);

    // 監聽 'value' 事件 (任何新增、修改、刪除都會觸發)
    autoSyncListenerRef.on('value', (snapshot) => {
        
        // 如果目前正在執行同步(由本地發起)，則忽略這次由雲端回傳的訊號
        if (isSyncingLock) {
            console.log("忽略自身寫入導致的更新訊號");
            return;
        }

        console.log("⚡ 偵測到雲端資料變更 (可能是老師批改或刪除)，準備同步...");
        
        // 設定鎖定，避免稍後的寫入動作又觸發監聽器
        isSyncingLock = true;

        // 執行同步
        syncHistoryToFirebase(true).then(() => {
            // 同步完成後，延遲 2 秒再解鎖
            // 這樣可以過濾掉 Firebase 寫入後的回彈訊號
            setTimeout(() => {
                isSyncingLock = false;
            }, 2000);
        });
    });
}


	
// 1. 主同步函式
// 1. 主同步函式 (修復版)
async function syncHistoryToFirebase(isSilent = false) {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (!s) {
        if (!isSilent) alert("請先綁定身份");
        return;
    }
    
    let btn = null;
    let originalText = "";
    // 如果是由按鈕觸發，加入 Loading 效果
    if (!isSilent && typeof event !== 'undefined' && event && event.target) {
        btn = event.target.tagName === 'BUTTON' ? event.target : event.target.closest('button');
        if (btn) {
            originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> 智能合併中...';
            btn.disabled = true;
        }
    }
    
    try {
        const db = await openHistoryDB();
        
        // A. 獲取本地資料
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const localRecords = await new Promise((resolve, reject) => {
            const req = store.getAll();
            req.onsuccess = e => resolve(e.target.result);
            req.onerror = () => resolve([]);
        });
        
        // B. 獲取雲端資料 (★ 關鍵修復處 ★)
        const path = `students/${s.grade}/${s.class}/${s.name}/history`;
        const cloudSnapshot = await database.ref(path).once('value');
        let cloudData = cloudSnapshot.val();
        let cloudRecords = [];
 
        // ★★★ 強制轉為 Array，防止 Firebase 因刪除產生 "Sparse Array" (物件格式) 導致 .map 報錯 ★★★
        if (cloudData) {
            if (Array.isArray(cloudData)) {
                // 如果是陣列，過濾掉可能存在的 null (空洞)
                cloudRecords = cloudData.filter(item => item !== null);
            } else if (typeof cloudData === 'object') {
                // 如果是物件 (例如 {"1": {...}})，強制轉為陣列
                cloudRecords = Object.values(cloudData);
            }
        }
        
        // 給雲端下載的資料貼上「官方認證」標籤
        cloudRecords = cloudRecords.map(r => {
            return Object.assign({}, r, { isSynced: true });
        });
        
        console.log(`開始同步：本地 ${localRecords.length} 筆，雲端 ${cloudRecords.length} 筆`);
 
        // C. 執行智能合併 (包含刪除判斷)
        const mergedRecords = mergeHistoryRecords(localRecords, cloudRecords);
        
        // D. 寫回雲端 (更新後的完整清單)
        await database.ref(path).set(mergedRecords);
        
        // E. 寫回本地 (讓本地資料也擁有 isSynced 標籤)
        await updateLocalHistoryWithMergedData(mergedRecords, db);
        
        console.log(`同步完成：合併後共 ${mergedRecords.length} 筆`);
        
        if (!isSilent) alert("✅ 智能同步完成！本地與雲端紀錄已合併。");
        
        // F. 刷新 UI (如果在列表頁面)
        if (document.getElementById('historyLevel3') && document.getElementById('historyLevel3').style.display === 'flex') {
            if (typeof currentSubFunctionFilter !== 'undefined') {
                enterHistoryList(currentSubFunctionFilter, typeof currentThemeIndex !== 'undefined' ? currentThemeIndex : 1);
            }
        }
 
    } catch (err) {
        console.error("智能同步失敗:", err);
        if (!isSilent) alert("❌ 同步失敗: " + err.message);
    } finally {
        if (btn && originalText) {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }
}

// 2. 輔助函式：合併算法 (核心邏輯)
function mergeHistoryRecords(localRecords, cloudRecords) {
    const mergedMap = new Map();
    
    // 生成唯一鍵
    const generateKey = (r) => {
        return `${r.category}_${r.subFunction}_${r.title}_${r.timestamp}`;
    };

    // A. 雲端資料是「權威」，無條件放入
    cloudRecords.forEach(record => {
        mergedMap.set(generateKey(record), record);
    });

    // B. 處理本地資料
    localRecords.forEach(localRecord => {
        if(!localRecord) return;
        const key = generateKey(localRecord);
        
        // 檢查雲端是否已經有這筆資料
        if (mergedMap.has(key)) {
            // 如果雲端有，代表兩邊都有，我們保留雲端的 (因為它帶有最新的 isSynced 標籤)
        } else {
            // ★★★ 核心判斷：為什麼雲端沒有這筆資料？ ★★★
            
            if (localRecord.isSynced) {
                // 情況 1：這筆資料本地有「已同步」標籤，但雲端卻找不到。
                // 結論：這代表「老師在雲端刪掉了它」。
                // 動作：捨棄它 (等於在本地也刪除)。
                console.log(`移除已在雲端被刪除的項目：${localRecord.title}`);
            } else {
                // 情況 2：這筆資料本地「沒有」標籤。
                // 結論：這代表「這是學生離線新寫的，還沒上傳過」。
                // 動作：保留它 (準備上傳)。
                mergedMap.set(key, localRecord);
            }
        }
    });

    // C. 轉回陣列並排序
    return Array.from(mergedMap.values()).sort((a, b) => b.timestamp - a.timestamp);
}

// 3. 輔助函式：更新本地 IndexedDB
async function updateLocalHistoryWithMergedData(mergedRecords, db) {
    let localDb = db;
    if (!localDb) {
        localDb = await openHistoryDB();
    }

    try {
        const transaction = localDb.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // A. 清空本地：避免 ID 衝突
        await new Promise((resolve, reject) => {
            const req = store.clear();
            req.onsuccess = resolve;
            req.onerror = reject;
        });

        // B. 寫入資料
        for (const record of mergedRecords) {
            // 移除舊的 ID，讓 IndexedDB 重新分配，解決 id 衝突
            delete record.id; 
            
            // ★★★ 關鍵：寫入本地時，確保加上 isSynced: true ★★★
            // 這樣下次同步時，系統就知道這筆資料「已經存在過雲端」了
            record.isSynced = true;
            
            store.put(record); 
        }
        
        return new Promise((resolve) => {
            transaction.oncomplete = resolve;
        });
    } catch(e) {
        console.error("更新本地資料庫錯誤", e);
    }
}

// ================= UI 導航邏輯 =================

// 變數儲存當前導航狀態
let currentCategoryFilter = null;
let currentSubFunctionFilter = null;

// 4. 開啟歷史頁面 (進入第一層)
// 4. 開啟歷史頁面 (進入第一層)
function openHistoryContainer() {
    // 1. 定義要隱藏的所有容器 (加入 'toolsContainer2' 和 'studentCloudModal')
    const containers = [
        'writingContainer', 'readingContainer', 'booksContainer', 
        'expandContainer', 'argumentContainer', 'mainMenuBox', 
        'hitokoto-container', 'dse-countdown-box', 'toolsBox',
        'toolsContainer2',      // <--- 關閉語薈
        'studentCloudModal'     // <--- 關閉學生雲端
    ];
    
    containers.forEach(id => {
        const el = document.getElementById(id);
        if(el) el.style.display = 'none';
    });
    document.querySelector('.title-container').style.display = 'none';
    
    // 2. ★★★ 關鍵：解鎖捲動 (因為語薈和學生雲端都會鎖住捲動) ★★★
    document.body.style.overflow = 'auto'; 

    // 3. 顯示歷史容器
    const historyContainer = document.getElementById('historyContainer');
    historyContainer.style.display = 'block';
    
    // 4. 按鈕狀態調整
    const homeBtn = document.getElementById('sideMenuHomeBtn');
    if (homeBtn) homeBtn.style.display = 'flex';
    
    // 確保雲端按鈕顯示 (因為離開了雲端介面)
    const cloudBtn = document.getElementById('sideMenuCloudBtn');
    if (cloudBtn) cloudBtn.style.display = 'flex';

    document.getElementById('sideMenu').classList.remove('active');

    // 渲染第一層
    renderHistoryCategories();
}
// 5. 渲染第一層：主範疇
// ==========================================
// === 歷史紀錄 UI 渲染邏輯 (修訂版) ===
// ==========================================

// 定義範疇與圖片的對應關係 (確保與主頁一致)
const CATEGORY_ASSETS = {
    "閱讀": { img: '郵筒.png', en: 'READING' },
    "敘事抒情": { img: '相機.png', en: 'NARRATIVE' },
    "議論": { img: '筆.png', en: 'ARGUMENT' },
    "整合拓展": { img: '火車.png', en: 'EXPAND' },
    "課外書籍": { img: '書.png', en: 'LIBRARY' },
    "學習報告": { img: '書.png', en: 'REPORT' } // <--- ★★★ 新增這一行 (暫用書.png 或您可指定其他圖片) ★★★
};

// 5. 渲染第一層：主範疇 (動漫卡片風格)
// 5. 渲染第一層：主範疇 (動漫卡片風格)
function renderHistoryCategories() {
    // --- 新增：隱藏日期搜尋按鈕 (因為第一層不需要搜尋) ---
    const searchContainer = document.getElementById('historyDateSearchContainer');
    if (searchContainer) searchContainer.style.display = 'none';

    // 顯示/隱藏層級容器
    document.getElementById('historyLevel1Wrapper').style.display = 'flex'; // Wrapper 需要 flex
    document.getElementById('historyLevel2').style.display = 'none';
    document.getElementById('historyLevel3').style.display = 'none';

	 // ★★★ 新增這一行：觸發第一層的進場動畫 ★★★
    playEntryAnimation('historyLevel1Wrapper');
    
    // 隱藏麵包屑 (第一層不需要)
    document.getElementById('historyBreadcrumb').style.display = 'none';
    
    const container = document.getElementById('historyLevel1');
    const categories = Object.keys(HISTORY_STRUCTURE); // ["閱讀", "敘事抒情", "議論", "整合拓展"]
    
    let html = '';

    categories.forEach(cat => {
        const asset = CATEGORY_ASSETS[cat] || { img: '背景.png', en: 'RECORD' };
        
        // 生成與主頁完全一致的卡片 HTML
        // 注意：這裡移除了 id 屬性以避免衝突，改用 onclick 直接觸發歷史功能
        html += `
            <div class="anime-card" style="--bg-img: url('${asset.img}');" onclick="enterHistoryCategory('${cat}')">
                <div class="card-overlay"></div>
                <div class="card-border-effect"></div>
                <div class="card-content">
                    <div class="card-text">
                        <span class="card-zh">${cat}</span>
                        <span class="card-en">${asset.en}</span>
                    </div>
                </div>
            </div>
        `;
    });

    container.innerHTML = html;
}

// === 新增全域變數，用於傳遞顏色主題 ===
let currentThemeIndex = 1; 

// 6. 進入第二層：子功能 (修改版：分配顏色)
function enterHistoryCategory(category) {
    const searchContainer = document.getElementById('historyDateSearchContainer');
    if (searchContainer) searchContainer.style.display = 'none';

    currentCategoryFilter = category;
    
    document.getElementById('historyLevel1Wrapper').style.display = 'none';
    document.getElementById('historyLevel2').style.display = 'grid';
    document.getElementById('historyLevel3').style.display = 'none';

	 // ★★★ 新增這一行：觸發第二層的進場動畫 ★★★
    playEntryAnimation('historyLevel2');

    // 麵包屑
    const breadcrumb = document.getElementById('historyBreadcrumb');
    breadcrumb.style.display = 'flex';
    document.getElementById('breadcrumb-sep-1').style.display = 'inline';
    const catSpan = document.getElementById('breadcrumb-category');
    catSpan.textContent = category;
    catSpan.style.display = 'inline';
    document.getElementById('breadcrumb-sep-2').style.display = 'none';
    document.getElementById('breadcrumb-sub').style.display = 'none';

    const container = document.getElementById('historyLevel2');
    const subFunctions = HISTORY_STRUCTURE[category] || [];
    
    let html = '';
    
    const subIcons = {
        "文章點評": "fa-file-alt",
        "大綱點評": "fa-list-ol",
        "敘事物象": "fa-tree",
        "解題指引": "fa-compass",
        "指引": "fa-lightbulb",
        "點評": "fa-comment-dots"
    };

    // ★★★ 核心修改：為每個子功能分配一個固定的顏色索引 (1-5) ★★★
    subFunctions.forEach((sub, index) => {
        // 使用 index % 5 + 1 確保顏色在 1~5 之間循環，並讓不同按鈕顏色不同
        const themeIndex = (index % 5) + 1;
        
        // 在 onclick 中傳遞 themeIndex
        html += `
            <div class="history-folder-btn history-theme-${themeIndex}" onclick="enterHistoryList('${sub}', ${themeIndex})">
                <i class="fas ${subIcons[sub] || 'fa-file'}"></i>
                <span>${sub}</span>
            </div>
        `;
    });

    if (subFunctions.length === 0) {
        html = '<p style="grid-column: 1/-1; text-align:center; color: #666;">此範疇暫無子功能定義。</p>';
    }

    container.innerHTML = html;
}

// 7. 進入第三層：紀錄列表 (修改版：接收並儲存顏色)
async function enterHistoryList(subFunction, themeIndex) {
    currentSubFunctionFilter = subFunction;
    
    // ★★★ 儲存傳入的顏色索引，供渲染列表時使用 ★★★
    // 如果是從麵包屑返回，themeIndex 可能為 undefined，則保持原值或預設為 1
    if (themeIndex) {
        currentThemeIndex = themeIndex;
    }

    document.getElementById('historyLevel1Wrapper').style.display = 'none';
    document.getElementById('historyLevel2').style.display = 'none';
    document.getElementById('historyLevel3').style.display = 'flex';

	// ★★★ 新增這一行：觸發第三層的進場動畫 ★★★
    playEntryAnimation('historyLevel3');
    
    const searchContainer = document.getElementById('historyDateSearchContainer');
    if (searchContainer) searchContainer.style.display = 'block';

    // 麵包屑邏輯 (樣式已在 CSS 修改為莫蘭迪色)
    const breadcrumb = document.getElementById('historyBreadcrumb');
    breadcrumb.style.display = 'flex';

    const homeSpan = breadcrumb.querySelector('span[onclick="renderHistoryCategories()"]');
    homeSpan.innerHTML = '<i class="fas fa-home"></i> 主範疇';
    
    document.getElementById('breadcrumb-sep-1').style.display = 'inline';
    
    const catSpan = document.getElementById('breadcrumb-category');
    catSpan.textContent = currentCategoryFilter;
    catSpan.style.display = 'inline';
    catSpan.setAttribute('onclick', `enterHistoryCategory('${currentCategoryFilter}')`);
    
    document.getElementById('breadcrumb-sep-2').style.display = 'inline';
    
    const subSpan = document.getElementById('breadcrumb-sub');
    subSpan.textContent = subFunction;
    subSpan.style.display = 'inline';

    const listContainer = document.getElementById('historyLevel3');
    listContainer.innerHTML = '<div style="text-align:center; padding:20px;"><i class="fas fa-spinner fa-spin"></i> 載入中...</div>';

    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const index = store.index('timestamp');
        const request = index.openCursor(null, 'prev');

        const records = [];
        request.onsuccess = function(event) {
            const cursor = event.target.result;
            if (cursor) {
                const r = cursor.value;
                if (r.category === currentCategoryFilter && r.subFunction === subFunction) {
                    records.push(r);
                }
                cursor.continue();
            } else {
                renderFilteredRecords(records);
            }
        };
    } catch (error) {
        console.error("讀取失敗:", error);
        listContainer.innerHTML = '<p>讀取失敗，請重試。</p>';
    }
}

// 8. 渲染列表卡片 (修改版：統一顏色)
// === 優化版：渲染列表卡片 (整張卡片可點擊) ===
function renderFilteredRecords(records) {
    const listContainer = document.getElementById('historyLevel3');
    listContainer.innerHTML = '';

    if (records.length === 0) {
        listContainer.innerHTML = `
            <div style="text-align:center; color:#999; margin-top:40px; grid-column: 1/-1; font-family: 'Noto Serif TC', serif;">
                <i class="far fa-file-alt" style="font-size: 40px; margin-bottom: 15px; opacity: 0.5;"></i>
                <p>此處尚無紀錄，靜待落筆。</p>
            </div>`;
        listContainer.style.display = 'flex';
        listContainer.style.justifyContent = 'center';
        return;
    } else {
        listContainer.style.display = 'grid';
    }

    records.forEach((record) => {
        const accentClass = `history-theme-${currentThemeIndex}`;

        const dateObj = new Date(record.timestamp);
        const dateStr = dateObj.toLocaleDateString('zh-HK', { 
            year: 'numeric', 
            month: '2-digit', 
            day: '2-digit' 
        }).replace(/\//g, '-');

        const card = document.createElement('div');
        card.className = `history-card ${accentClass}`;
        card.setAttribute('data-timestamp', record.timestamp);
        
        // ★★★ 關鍵修改 1：將點擊事件移到最外層容器 ★★★
        // 這樣點擊卡片的任何留白處都能打開視窗
        card.setAttribute('onclick', `viewHistoryDetail(${record.id})`);

        card.innerHTML = `
            <!-- ★★★ 關鍵修改 2：移除這裡內層 div 的 onclick，改為純佈局容器 ★★★ -->
            <div style="flex-grow: 1;">
                <div class="history-meta">
                    <span class="history-tag">${record.subFunction}</span>
                    <span class="history-date">${dateStr}</span>
                </div>
                
                <!-- 
                    標題保留自己的 onclick/ondblclick 邏輯。
                    因為 handleTitleClick 裡面有 event.stopPropagation()，
                    所以點標題時不會觸發外層的直接打開，而是執行標題專屬的「延遲判斷雙擊」邏輯。
                -->
                <h4 class="history-title" 
                    onclick="handleTitleClick(event, ${record.id})"
                    ondblclick="handleTitleDblClick(this, ${record.id})"
                    title="單擊查看詳情，雙擊直接修改標題">
                    ${record.title}
                </h4>
            </div>
            
            <div class="history-actions">
    <!-- 下載按鈕 (新增) -->
    <button class="btn-download-history" id="download-btn-${record.id}" onclick="event.stopPropagation(); downloadHistoryHTML(${record.id})" title="下載 HTML 檔案">
    <i class="fas fa-file-code"></i>
</button>

    <!-- 刪除按鈕 -->
    <button class="btn-delete-history" onclick="event.stopPropagation(); deleteHistoryItem(${record.id})" title="刪除此紀錄">
        <i class="fas fa-trash-alt"></i>
    </button>
</div>
        `;

        listContainer.appendChild(card);
    });
}


// === 新增：下載歷史紀錄為 PDF ===
// === [100% 完美復刻 + 強制置中修復版] 下載歷史紀錄為 HTML ===
async function downloadHistoryHTML(id) {
    const btn = document.getElementById(`download-btn-${id}`);
    if (!btn) return;
    
    const originalContent = btn.innerHTML;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    btn.disabled = true;

    const resetBtn = () => {
        btn.innerHTML = originalContent;
        btn.disabled = false;
    };

    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(id);

        request.onsuccess = async function(event) {
            const record = event.target.result;
            if (!record) { alert("找不到紀錄"); resetBtn(); return; }

            // 1. 建立影子容器 (設定為 900px，這是電腦版的標準寬度)
            const shadowContainer = document.createElement('div');
            shadowContainer.style.cssText = `
                position: absolute; left: -9999px; top: 0; 
                width: 900px; 
                background-color: #fff; 
                visibility: hidden;
                box-sizing: border-box;
            `;
            document.body.appendChild(shadowContainer);

            // 2. === 重建 HTML 結構 ===
            
            let themeIndex = 1;
            if (record.category && typeof HISTORY_STRUCTURE !== 'undefined') {
                const subIndex = HISTORY_STRUCTURE[record.category]?.indexOf(record.subFunction);
                if (subIndex !== -1 && subIndex !== undefined) themeIndex = (subIndex % 5) + 1;
            }
            const themeClass = `history-theme-context-${themeIndex}`;
            const colorVar = `var(--m-color-${themeIndex})`;

            let contentHTML = `
                <div style="padding: 40px 40px 30px 40px; border-bottom: 1px solid #eee; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: #2A9689; font-size: 28px; font-family: 'Noto Serif TC', serif; text-align: left;">
                        ${record.title}
                    </h2>
                    <div style="color: #888; font-size: 14px; margin-top: 15px; text-align: center;">
                        <span style="background-color:${colorVar}; color:white; padding: 2px 8px; border-radius: 4px; font-weight:bold;">${record.category}</span>
                        <span style="margin: 0 5px;">/</span>
                        <span>${record.subFunction}</span>
                        <span style="margin-left: 15px;">📅 ${record.dateStr}</span>
                    </div>
                </div>
                <div style="padding: 0 40px 40px 40px;">
            `;

            if (record.userContent) {
                const rawText = record.userContent;
                const lines = rawText.split('\n');
                let parsedHTML = `<div class="history-parsed-container ${themeClass}">`;
                let currentLabel = '輸入內容'; 
                let currentContent = [];
                const labelRegex = /^(.{2,10}?)[：:](.*)$/;

                lines.forEach((line) => {
                    const match = line.match(labelRegex);
                    if (match) {
                        if (currentContent.length > 0) {
                            parsedHTML += `<div class="history-item-block"><div class="history-item-label">${currentLabel}</div><div class="history-item-content">${currentContent.join('\n')}</div></div>`;
                        }
                        currentLabel = match[1].trim(); 
                        const restOfLine = match[2].trim();
                        currentContent = restOfLine ? [restOfLine] : []; 
                    } else {
                        if (line.trim() !== "") currentContent.push(line);
                    }
                });
                if (currentContent.length > 0 || lines.length === 0) { 
                     const finalContent = currentContent.length > 0 ? currentContent.join('\n') : rawText;
                     parsedHTML += `<div class="history-item-block"><div class="history-item-label">${currentLabel}</div><div class="history-item-content">${finalContent}</div></div>`;
                }
                parsedHTML += '</div>';
                
                contentHTML += `
                    <div style="background:#fff; padding:25px; border-radius:12px; margin-bottom:30px; border:1px solid #e0ddd7; box-shadow: 0 4px 15px rgba(0,0,0,0.03);">
                        ${parsedHTML}
                    </div>`;
            }

            if (record.aiContent) {
                contentHTML += `<div class="ai-output-area">${record.aiContent}</div>`;
            }

            contentHTML += `</div>`; 
            shadowContainer.innerHTML = contentHTML;

            // 3. === 清理與凍結 ===
            shadowContainer.querySelectorAll('.canvas-chat-container, .canvas-input-area, button, .action-buttons-container, .history-save-btn, input[type="text"], textarea').forEach(el => {
                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    const span = document.createElement('div');
                    span.innerText = el.value;
                    span.style.cssText = "white-space: pre-wrap; background: #fffcf6; padding: 10px; border: 1px solid #ddd; border-radius: 4px; color: #333; font-size: 16px; font-family: 'Noto Serif TC', serif;";
                    el.parentNode.replaceChild(span, el);
                } else {
                    el.remove();
                }
            });

            shadowContainer.querySelectorAll('.progress-bar-fill').forEach(bar => {
                const w = bar.style.width; 
                bar.setAttribute('style', `width: ${w} !important; background-color: #007bff !important; -webkit-print-color-adjust: exact; print-color-adjust: exact;`);
            });

            // 4. === 處理圖表 ===
            if (record.scoreData && record.scoreData.radar) {
                let canvasEl = shadowContainer.querySelector('canvas');
                if (!canvasEl) {
                    const radarContainer = shadowContainer.querySelector('.radar-chart-container') || shadowContainer.querySelector('.ai-output-area');
                    if (radarContainer) {
                        if (radarContainer.classList.contains('radar-chart-container')) radarContainer.innerHTML = ''; 
                        canvasEl = document.createElement('canvas');
                        canvasEl.width = 500;
                        canvasEl.height = 350;
                        if (radarContainer.firstChild) {
                            radarContainer.insertBefore(canvasEl, radarContainer.firstChild);
                        } else {
                            radarContainer.appendChild(canvasEl);
                        }
                    }
                }

                if (canvasEl) {
                    const ctx = canvasEl.getContext('2d');
                    await new Promise((resolve) => {
                        new Chart(ctx, {
                            type: 'radar',
                            data: {
                                labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
                                datasets: [{
                                    label: '能力評估',
                                    data: [
                                        record.scoreData.radar.立意 || 0,
                                        record.scoreData.radar.取材 || 0,
                                        record.scoreData.radar.扣題 || 0,
                                        record.scoreData.radar.詳略 || 0,
                                        record.scoreData.radar.詞彙 || 0,
                                        record.scoreData.radar.文學性 || 0
                                    ],
                                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    borderWidth: 2,
                                    pointBackgroundColor: 'rgba(54, 162, 235, 1)'
                                }]
                            },
                            options: {
                                animation: false,
                                responsive: false,
                                scales: {
                                    r: {
                                        angleLines: { display: true },
                                        suggestedMin: 0, suggestedMax: 10,
                                        pointLabels: { font: { size: 14, family: "'Noto Serif TC', serif" } },
                                        ticks: { stepSize: 2, display: false }
                                    }
                                },
                                plugins: { legend: { display: false } }
                            }
                        });
                        setTimeout(resolve, 300);
                    });

                    const imgUrl = canvasEl.toDataURL('image/png');
                    const img = document.createElement('img');
                    img.src = imgUrl;
                    img.style.cssText = "width: 100%; max-width: 500px; display: block; margin: 0 auto;";
                    canvasEl.parentNode.replaceChild(img, canvasEl);
                }
            }

            // 5. === 提取全站 CSS ===
            let cssRules = "";
            Array.from(document.querySelectorAll('style')).forEach(style => { cssRules += style.innerHTML + "\n"; });
            let externalLinks = "";
            Array.from(document.querySelectorAll('link[rel="stylesheet"]')).forEach(link => { externalLinks += link.outerHTML + "\n"; });

            // 6. === 組合最終 HTML (強制覆寫 Body 樣式) ===
            const finalHtmlSource = `
<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${record.title} - 神思紀錄</title>
    ${externalLinks}
    <style>
        ${cssRules}
        
        /* === 關鍵修正：強制覆寫原有網站 CSS 對 Body 的限制 === */
        
        body { 
            /* 1. 強制重置 Body 寬度與背景，覆蓋原網站的 max-width: 800px */
            max-width: 100% !important; 
            width: 100% !important;
            margin: 0 !important;
            padding: 40px 0 !important;
            
            /* 2. 使用 Flexbox 確保內容卡片絕對置中 */
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important; /* 水平置中 */
            
            background-color: #f2f4f7 !important;
            background-image: none !important;
            min-height: 100vh !important;
            overflow-y: auto !important;
        }

        /* 內容容器：這張「紙」 */
        .export-wrapper {
            /* 3. 設定固定寬度 900px (電腦版)，配合 Body 的 Flex 置中 */
            width: 900px !important;
            
            /* 4. 響應式保護：在小螢幕上縮放 */
            max-width: 95% !important; 
            
            background-color: #ffffff !important;
            box-shadow: 0 10px 40px rgba(0,0,0,0.08) !important;
            border-radius: 12px !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
            position: relative !important;
            margin: 0 !important; /* Margin 0，因為 Body 已經負責置中了 */
        }

        /* 修復 Grid 排版 (評分表 + 雷達圖) */
        .grading-grid { 
            display: grid !important; 
            grid-template-columns: 1fr 1fr !important; 
            gap: 20px !important; 
            width: 100% !important;
        }
        .grading-scores, .grading-radar {
            width: 100% !important;
            box-sizing: border-box !important;
            margin: 0 !important;
        }

        /* 手機版樣式 */
        @media (max-width: 768px) {
            body {
                padding: 0 !important; 
                background-color: #fff !important;
                display: block !important; /* 手機版改回 Block，讓內容自然流動 */
            }
            .export-wrapper {
                width: 100% !important;
                max-width: 100% !important;
                border-radius: 0 !important;
                box-shadow: none !important;
            }
            .grading-grid {
                grid-template-columns: 1fr !important;
            }
        }

        button { display: none !important; }
    </style>
</head>
<body>
    <div class="export-wrapper">
        ${shadowContainer.innerHTML}
    </div>
    
    <div style="text-align: center; color: #aaa; font-size: 12px; margin-top: 30px; font-family: sans-serif; width: 100%;">
        Generated by 神思 SANSI AI System
    </div>
</body>
</html>`;

            // 7. 清理與下載
            document.body.removeChild(shadowContainer);

            const blob = new Blob([finalHtmlSource], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            const safeTitle = record.title.replace(/[\\/:*?"<>|]/g, '_').substring(0, 15);
            const dateSuffix = new Date().toISOString().slice(0, 10);
            a.href = url;
            a.download = `神思紀錄_${safeTitle}_${dateSuffix}.html`;
            
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                resetBtn();
            }, 100);
        };

        request.onerror = function() { alert("讀取紀錄失敗"); resetBtn(); };

    } catch (e) {
        console.error("下載 HTML 錯誤:", e);
        alert("下載失敗，請重試");
        resetBtn();
    }
}
	
	
// 9. 刪除與清空 (保持類似)
async function deleteHistoryItem(id) {
    if (!confirm("確定要刪除這條紀錄嗎？\n(注意：雲端備份也會同步刪除)")) return;
    
    // 檢查登入狀態
    const s = JSON.parse(localStorage.getItem('studentProfile'));

    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // 1. 先獲取這筆資料的詳情 (為了拿到 timestamp 去雲端比對)
        const recordRequest = store.get(id);
        
        recordRequest.onsuccess = async function(event) {
            const recordToDelete = event.target.result;
            
            // 如果本地已經找不到了，直接刷新 UI 並退出
            if (!recordToDelete) {
                enterHistoryList(currentSubFunctionFilter);
                return;
            }

            // 2. 執行本地刪除
            store.delete(id);
            
            // 3. 執行雲端刪除 (如果已登入)
            if (s) {
                // 注意：這裡有反引號 `
                const path = `students/${s.grade}/${s.class}/${s.name}/history`;
                
                // 讀取雲端目前所有資料
                const snapshot = await database.ref(path).once('value');
                const cloudRecords = snapshot.val() || [];
                
                // 過濾掉我們要刪除的那一筆 (利用 timestamp 比對)
                const updatedRecords = cloudRecords.filter(r => r.timestamp !== recordToDelete.timestamp);
                
                // 將剩下的資料寫回雲端
                await database.ref(path).set(updatedRecords);
                console.log("雲端同步刪除成功");
            }

            // 4. 刷新介面
            enterHistoryList(currentSubFunctionFilter);
        };
        
    } catch (e) { 
        console.error("刪除失敗:", e); 
        alert("刪除失敗，請重試。");
    }
}

	
// === 修改版：清空所有紀錄 (加入即時刷新邏輯) ===
async function clearAllHistory() {
    if (!confirm("確定要清空所有歷史紀錄嗎？")) return;
    
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    const level3 = document.getElementById('historyLevel3');

    // 1. 視覺反饋：如果正在看列表，先強制清空內容並顯示 Loading
    // 這裡改用 !== 'none' 確保捕捉到 grid 或 flex 狀態
    if (level3 && level3.style.display !== 'none') {
        level3.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:40px; color:#999;"><i class="fas fa-circle-notch fa-spin"></i> 正在清空...</div>';
    }

    try {
        const db = await openHistoryDB();
        
        // 2. 等待本地資料庫完全清空
        await new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = (e) => reject(e);
        });

        // 3. 清空雲端資料
        if (s) {
            const path = `students/${s.grade}/${s.class}/${s.name}/history`;
            await database.ref(path).set([]);
            console.log("雲端同步清空成功");
        }

        // 4. ★★★ 關鍵修訂：寬鬆的顯示判斷 ★★★
        
        // 檢查 Level 3 (紀錄列表) 是否顯示中 (無論是 grid 還是 flex)
        if (document.getElementById('historyLevel3').style.display !== 'none') {
            // 重新載入列表 -> 因為 DB 空了，這裡會自動顯示「無紀錄」
            const themeIndex = typeof currentThemeIndex !== 'undefined' ? currentThemeIndex : 1;
            // 確保有過濾器變數，如果沒有則回到主選單
            if (typeof currentSubFunctionFilter !== 'undefined') {
                enterHistoryList(currentSubFunctionFilter, themeIndex);
            } else {
                renderHistoryCategories(); // 變數遺失，退回主層
            }
        } 
        // 檢查 Level 2 (子功能選單) 是否顯示中
        else if (document.getElementById('historyLevel2').style.display !== 'none') {
            // 刷新子選單 -> 數字會變 (0)
            if (typeof currentCategory !== 'undefined') {
                renderLevel2(currentCategory);
            } else {
                renderHistoryCategories();
            }
        } 
        else {
            // 其他情況 (例如在主選單)，刷新主選單
            renderHistoryCategories();
        }

        alert("✅ 所有紀錄已清空");

    } catch (e) { 
        console.error("清空錯誤:", e); 
        alert("清空失敗，請重試。");
        // 發生錯誤時嘗試恢復畫面
        if (document.getElementById('historyLevel3').style.display !== 'none') {
             const themeIndex = typeof currentThemeIndex !== 'undefined' ? currentThemeIndex : 1;
             enterHistoryList(currentSubFunctionFilter, themeIndex);
        }
    }
}
// 優化後的查看詳情函數
// === 優化版：查看詳情 (加入雷達圖重繪邏輯) ===
async function viewHistoryDetail(id) {
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(id);
 
        request.onsuccess = function(event) {
            const record = event.target.result;
            if (record) {
                // 1. 計算主題色
                let themeIndex = 1;
                if (HISTORY_STRUCTURE[record.category]) {
                    const subIndex = HISTORY_STRUCTURE[record.category].indexOf(record.subFunction);
                    if (subIndex !== -1) {
                        themeIndex = (subIndex % 5) + 1;
                    }
                }
                const themeClass = `history-theme-context-${themeIndex}`;
                const colorVar = `var(--m-color-${themeIndex})`;
 
                // 2. 設定標題
                document.getElementById('historyModalTitle').innerHTML =
                    `<i class="fas fa-book-open" style="color:${colorVar}"></i>
                     <span style="color:#333">${record.category}</span>
                     <span style="font-size:0.8em; color:#bbb; margin: 0 5px;">/</span>
                     <span style="color:${colorVar}; font-weight:bold;">${record.subFunction}</span>`;
                
                const dateElement = document.getElementById('historyModalDate');
                if (dateElement) dateElement.style.display = "none";
                
                let contentHTML = '';
 
                // 3. 處理使用者輸入內容 (加入雙擊事件與 ID)
                if (record.category !== "學習報告" && record.userContent) {
                    const rawText = record.userContent;
                    const lines = rawText.split('\n');
                    let parsedHTML = `<div class="history-parsed-container ${themeClass}">`;
                    let currentLabel = '輸入內容';
                    let currentContent = [];
                    const labelRegex = /^(.{2,10}?)[：:](.*)$/;
 
                    lines.forEach((line) => {
                        const match = line.match(labelRegex);
                        if (match) {
                            if (currentContent.length > 0) {
                                parsedHTML += `<div class="history-item-block"><div class="history-item-label">${currentLabel}</div><div class="history-item-content">${currentContent.join('\n')}</div></div>`;
                            }
                            currentLabel = match[1].trim();
                            const restOfLine = match[2].trim();
                            currentContent = restOfLine ? [restOfLine] : [];
                        } else {
                            if (line.trim() !== "") currentContent.push(line);
                        }
                    });
 
                    if (currentContent.length > 0 || lines.length === 0) {
                         const finalContent = currentContent.length > 0 ? currentContent.join('\n') : rawText;
                         parsedHTML += `<div class="history-item-block"><div class="history-item-label">${currentLabel}</div><div class="history-item-content">${finalContent}</div></div>`;
                    }
                    parsedHTML += '</div>';
                    
                    // ★★★ 關鍵修改：外層加入 ID 和雙擊事件 ★★★
                    contentHTML += `
                        <div id="edit-user-content-${record.id}"
                             ondblclick="enableHistoryEdit(this)"
                             title="雙擊即可修訂內容"
                             style="background:#fff; padding:20px; border-radius:12px; margin-bottom:25px; border:1px solid #eee; box-shadow: 0 4px 20px rgba(0,0,0,0.04);">
                            ${parsedHTML}
                        </div>`;
                }
 
                // 4. 處理 AI 生成內容 (加入雙擊事件與 ID)
                if (record.aiContent) {
                    // ★★★ 關鍵修改：外層加入 ID 和雙擊事件 ★★★
                    contentHTML += `
                        <div id="edit-ai-content-${record.id}"
                             ondblclick="enableHistoryEdit(this)"
                             title="雙擊即可修訂內容"
                             class="ai-output-area"
                             style="margin-top: 15px;">
                            ${record.aiContent}
                        </div>`;
                }
                
                // 5. 顯示繳交按鈕
                const s = JSON.parse(localStorage.getItem('studentProfile'));
                if (s && record.category !== "學習報告") {
                    contentHTML += `
                        <div style="margin-top: 40px; padding-top: 20px; border-top: 2px dashed #eee; text-align: right; display: flex; justify-content: flex-end; align-items: center; gap: 10px;">
                            <button class="btn-action btn-morandi"
                                    onclick="openSubmitSelector(${record.id})">
                                <i class="fas fa-paper-plane"></i> 繳交
                            </button>
                        </div>
                    `;
                }
 
                // 6. ★★★ 注入懸浮儲存鍵 (預設隱藏) ★★★
                contentHTML += `
                    <button id="history-save-btn-${record.id}"
                            class="morandi-save-float-btn"
                            onclick="saveHistoryEdits(${record.id})">
                        <i class="fas fa-save"></i>
                    </button>
                `;
 
                // 7. 注入 Modal
                const modalContent = document.getElementById('historyModalContent');
                modalContent.innerHTML = contentHTML;
                document.getElementById('historyModal').style.display = 'flex';
 
                // 8. 雷達圖重繪邏輯 (保持不變)
                setTimeout(() => {
                    if (record.scoreData && record.scoreData.radar) {
                        const canvasEl = modalContent.querySelector('canvas');
                        if (canvasEl) {
                            const radarData = [
                                record.scoreData.radar.立意 || 0,
                                record.scoreData.radar.取材 || 0,
                                record.scoreData.radar.扣題 || 0,
                                record.scoreData.radar.詳略 || 0,
                                record.scoreData.radar.詞彙 || 0,
                                record.scoreData.radar.文學性 || 0
                            ];
                            new Chart(canvasEl.getContext('2d'), {
                                type: 'radar',
                                data: {
                                    labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
                                    datasets: [{
                                        label: '能力評估',
                                        data: radarData,
                                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                        borderColor: 'rgba(54, 162, 235, 1)',
                                        borderWidth: 2,
                                        pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                                        pointBorderColor: '#fff'
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        r: {
                                            angleLines: { display: true },
                                            suggestedMin: 0,
                                            suggestedMax: 10,
                                            pointLabels: { font: { size: 14, family: "'Noto Serif TC', serif" } },
                                            ticks: { stepSize: 2, display: false }
                                        }
                                    },
                                    plugins: { legend: { display: false } }
                                }
                            });
                        }
                    }
                }, 100);
            }
        };
    } catch (e) { console.error(e); }
}


	function enableHistoryEdit(element) {
    // 啟用編輯
    element.contentEditable = "true";
    element.focus();
    
    // 找出目前紀錄的 ID
    const parts = element.id.split('-');
    const recordId = parts[parts.length - 1];
    
    // 顯示對應的懸浮儲存按鈕
    const saveBtn = document.getElementById(`history-save-btn-${recordId}`);
    if (saveBtn) {
        saveBtn.style.display = 'flex'; // 顯示圓形按鈕
        
        // 手機震動回饋
        if (navigator.vibrate) navigator.vibrate(15);
    }
}

// ==========================================
// === 核心修復：儲存修訂並覆蓋舊檔 ===
// ==========================================

// 輔助函式：根據時間戳記找回新 ID
function findIdByTimestamp(timestamp) {
    return new Promise(async (resolve) => {
        try {
            const db = await openHistoryDB();
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const index = store.index('timestamp');
            const request = index.get(timestamp);
            
            request.onsuccess = function(event) {
                const record = event.target.result;
                resolve(record ? record.id : null);
            };
            request.onerror = () => resolve(null);
        } catch (e) {
            resolve(null);
        }
    });
}


// ==========================================
// === 最終修復：儲存修訂 + 刷新背景列表 ===
// ==========================================
 
async function saveHistoryEdits(id) {
    const userContentEl = document.getElementById(`edit-user-content-${id}`);
    const aiContentEl = document.getElementById(`edit-ai-content-${id}`);
    const saveBtn = document.getElementById(`history-save-btn-${id}`);
 
    // UI 鎖定
    const originalIcon = saveBtn.innerHTML;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    saveBtn.disabled = true;
 
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // 1. 讀取本地舊紀錄
        const getRequest = store.get(id);
        
        getRequest.onsuccess = function(event) {
            const record = event.target.result;
            if (record) {
                const oldTimestamp = record.timestamp;
 
                // 2. 更新內容
                if (userContentEl) record.userContent = userContentEl.innerText;
                if (aiContentEl) record.aiContent = aiContentEl.innerHTML;
 
                // 更新時間戳
                const newTimestamp = new Date().getTime();
                record.timestamp = newTimestamp;
                record.dateStr = new Date().toLocaleString('zh-HK', { hour12: false });
                
                if (record.isSynced) delete record.isSynced;
 
                // 3. 寫回本地
                const putRequest = store.put(record);
                
                putRequest.onsuccess = async function() {
                    console.log("本地紀錄已更新");
 
                    // 4. 刪除雲端舊檔
                    const s = JSON.parse(localStorage.getItem('studentProfile'));
                    if (s) {
                        try {
                            const path = `students/${s.grade}/${s.class}/${s.name}/history`;
                            const snapshot = await database.ref(path).once('value');
                            const cloudData = snapshot.val();
                            let cloudRecords = [];
                            if (cloudData) {
                                cloudRecords = Array.isArray(cloudData) ? cloudData.filter(x=>x) : Object.values(cloudData);
                            }
                            const updatedRecords = cloudRecords.filter(r => r.timestamp !== oldTimestamp);
                            await database.ref(path).set(updatedRecords);
                        } catch (cloudErr) {
                            console.error("雲端舊檔移除失敗:", cloudErr);
                        }
                    }
                    
                    // 5. 觸發同步 (這會重整 ID)
                    await syncHistoryToFirebase(true);
 
                    // 6. 找回新 ID
                    const newId = await findIdByTimestamp(newTimestamp);
                    
                    if (newId) {
                        // A. 重新加載視窗內容 (更新按鈕 ID)
                        await viewHistoryDetail(newId);
                        
                        // ★★★ 關鍵新增：在背景刷新列表，讓卡片 ID 也同步更新 ★★★
                        // 檢查目前是否在列表頁面，如果是，就刷新它
                        if (typeof currentSubFunctionFilter !== 'undefined' &&
                            document.getElementById('historyLevel3').style.display !== 'none') {
                            
                            // 保持當前的主題色索引，如果沒有則預設 1
                            const themeIndex = typeof currentThemeIndex !== 'undefined' ? currentThemeIndex : 1;
                            
                            // 靜默刷新列表 (這會更新卡片上的 onclick ID)
                            enterHistoryList(currentSubFunctionFilter, themeIndex);
                        }
 
                        alert("✅ 修訂已儲存！\n資料已同步，您可以直接按「繳交」。");
                    } else {
                        alert("✅ 修訂已儲存！\n請重新打開紀錄以進行繳交。");
                        closeHistoryModal();
                        // 刷新列表以顯示新紀錄
                        if (typeof currentSubFunctionFilter !== 'undefined') {
                            enterHistoryList(currentSubFunctionFilter, currentThemeIndex || 1);
                        }
                    }
                    
                    if (navigator.vibrate) navigator.vibrate([10, 30, 10]);
                };
            } else {
                alert("錯誤：找不到原始紀錄。");
                saveBtn.disabled = false;
                saveBtn.innerHTML = originalIcon;
            }
        };
    } catch (e) {
        console.error("儲存失敗:", e);
        alert("儲存失敗，請重試。");
        saveBtn.disabled = false;
        saveBtn.innerHTML = originalIcon;
    }
}
	
function closeHistoryModal() {
    document.getElementById('historyModal').style.display = 'none';
}


// === 新增：日期搜尋功能 ===

// 觸發日期選擇器 (為了美觀，用按鈕觸發隱藏的 input)
function triggerDatePicker() {
    const picker = document.getElementById('historyDatePicker');
    if (picker) {
        // 嘗試顯示原生日期選擇器
        try {
            picker.showPicker(); 
        } catch (e) {
            picker.click(); // 舊版瀏覽器 fallback
        }
    }
}

// 執行捲動定位邏輯
function scrollToHistoryDate(inputElement) {
    const selectedDateStr = inputElement.value; // 格式: YYYY-MM-DD
    if (!selectedDateStr) return;

    // 將選擇的日期轉為當天的結束時間戳 (23:59:59)
    // 因為列表是從新到舊排列 (Descending)，我們要找的第一個紀錄應該是
    // 時間戳小於或等於「該日結束」的紀錄
    const selectedDateEnd = new Date(selectedDateStr).setHours(23, 59, 59, 999);
    
    // 獲取所有已渲染的卡片
    const cards = document.querySelectorAll('#historyLevel3 .history-card');
    let targetCard = null;

    // 移除所有舊的高亮
    cards.forEach(c => c.classList.remove('highlighted'));

    // 遍歷卡片尋找目標
    for (let card of cards) {
        const timestamp = parseInt(card.getAttribute('data-timestamp'));
        
        // 邏輯：因為卡片是按時間倒序排列 (最新的在上面)
        // 我們要找的是第一個時間戳「小於或等於」選定日期結束時間的卡片
        // 這代表它是該日期(或該日期之前)最新的一條紀錄
        if (timestamp <= selectedDateEnd) {
            targetCard = card;
            break; // 找到後立即停止
        }
    }

    if (targetCard) {
        // 捲動到該卡片
        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // 添加高亮效果
        targetCard.classList.add('highlighted');
        
        // 檢查是否完全匹配當天 (用於提示)
        const targetDate = new Date(parseInt(targetCard.getAttribute('data-timestamp')));
        const checkDateStr = targetDate.toISOString().split('T')[0];
        
        if (checkDateStr !== selectedDateStr) {
            // 如果找到的卡片不是選定當天的(代表那天沒紀錄)，提示使用者
            // alert(`找不到 ${selectedDateStr} 的紀錄，已定位至最接近的過往紀錄 (${checkDateStr})。`);
            // 上方 alert 可依需求開啟或關閉，通常直接定位即可
        }
    } else {
        alert("找不到該日期或更早之前的紀錄。");
    }
}

	// === 歷史紀錄：標題原地編輯邏輯 ===

/**
 * 啟用標題編輯模式
 * @param {HTMLElement} titleEl - 被雙擊的 h4 元素
 * @param {number} id - 紀錄的 ID
 */
function enableTitleEditing(titleEl, id) {
    // 防止重複觸發 (如果已經是 input 就不動作)
    if (titleEl.querySelector('input')) return;

    const currentText = titleEl.innerText;
    
    // 創建 input 元素
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.className = 'history-title-input';
    
    // 點擊 input 時也要防止冒泡，以免觸發查看詳情
    input.onclick = (e) => e.stopPropagation();
    input.ondblclick = (e) => e.stopPropagation();

    // 清空原本的標題文字，放入 input
    titleEl.innerHTML = '';
    titleEl.appendChild(input);
    input.focus();

    // 定義儲存並還原的邏輯
    const saveAndRevert = async () => {
        const newTitle = input.value.trim() || currentText; // 如果是空的，還原舊標題
        
        if (newTitle !== currentText) {
            // 如果標題有變更，儲存到 DB
            await updateHistoryTitleInDB(id, newTitle);
        }
        
        // 還原為文字顯示
        titleEl.innerText = newTitle;
    };

    // 事件監聽：失去焦點 (Blur) 或 按下 Enter 鍵時儲存
    input.addEventListener('blur', saveAndRevert);
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            this.blur(); // 觸發 blur 來儲存
        } else if (e.key === 'Escape') {
            // 按 Esc 取消編輯，還原舊文字
            titleEl.innerText = currentText; 
        }
    });
}

/**
 * 更新 IndexedDB 中的標題
 */
async function updateHistoryTitleInDB(id, newTitle) {
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        
        // 1. 獲取舊紀錄
        const getRequest = store.get(id);
        
        getRequest.onsuccess = function(event) {
            const data = event.target.result;
            if (data) {
                // 2. 修改標題
                data.title = newTitle;
                
                // 3. 寫回 DB
                const putRequest = store.put(data);
                putRequest.onsuccess = function() {
                    console.log(`紀錄 ID ${id} 標題已更新為: ${newTitle}`);
                };
            }
        };
    } catch (e) {
        console.error("更新標題失敗:", e);
        alert("標題更新失敗，請重試。");
    }
}

// === 雙擊/單擊 衝突解決方案 ===
let titleClickTimer = null;

/**
 * 處理標題的單擊事件 (延遲觸發查看)
 */
function handleTitleClick(event, id) {
    // 1. 阻止事件冒泡，防止觸發父層的立即查看
    event.stopPropagation();

    // 2. 如果已經有計時器，表示這可能是雙擊過程中的第二次點擊，不做處理
    if (titleClickTimer) return;

    // 3. 設定延遲，如果 250ms 內沒有發生雙擊，才打開視窗
    titleClickTimer = setTimeout(() => {
        viewHistoryDetail(id);
        titleClickTimer = null;
    }, 250); 
}

/**
 * 處理標題的雙擊事件 (取消查看，進入編輯)
 */
function handleTitleDblClick(element, id) {
    // 1. 阻止事件冒泡
    event.stopPropagation();

    // 2. 關鍵：清除單擊產生的計時器！這樣就不會彈出視窗了
    if (titleClickTimer) {
        clearTimeout(titleClickTimer);
        titleClickTimer = null;
    }

    // 3. 進入編輯模式
    enableTitleEditing(element, id);
}




// 2. [發送端功能] 老師發送通知的函式
// 為了安全，將 API KEY 拆分混淆，避免簡單的爬蟲直接抓取
const _p1 = "os_v2_app_";
const _p2 = "7bo2joflvzgf5dnzzh2gh7eycxk5kn45q25uwymlyhqbq746uburtgfhd3xfyyxullklptksmnddfdwgpechno4byssraz7yysuusrq";
const _OS_KEY = _p1 + _p2;

/**
 * 發送推播通知給指定班級 (請在老師發佈課業的代碼中調用此函式)
 * @param {string} targetGrade - 年級 (如 "4")
 * @param {string} targetClass - 班別 (如 "A")
 * @param {string} title - 通知標題
 * @param {string} message - 通知內容
 */
async function sendClassNotification(targetGrade, targetClass, title, message) {
    const options = {
        method: 'POST',
        headers: {
            accept: 'application/json',
            'Content-Type': 'application/json',
            Authorization: 'Basic ' + _OS_KEY
        },
        body: JSON.stringify({
            app_id: "f85da4b8-abae-4c5e-8db9-c9f463fc9815",
            headings: { en: title, zh: title },
            contents: { en: message, zh: message },
            // 關鍵：只發送給符合 Grade 和 Class 的用戶
            filters: [
                { field: "tag", key: "grade", relation: "=", value: targetGrade },
                { operator: "AND" },
                { field: "tag", key: "class", relation: "=", value: targetClass }
            ],
            // 點擊通知後打開的網址 (即本頁面)
            url: window.location.href
        })
    };

    try {
        const response = await fetch('https://onesignal.com/api/v1/notifications', options);
        const data = await response.json();
        console.log('OneSignal 發送成功:', data);
    } catch (err) {
        console.error('OneSignal 發送失敗:', err);
    }
}

/**
 * 發送推播通知給特定學生 (請在老師發還評語的代碼中調用此函式)
 * 注意：這需要 OneSignal 的 External User ID 功能，或利用 Tag 標記個別學生
 * 這裡演示利用 Tag 標記個別學生 (假設 Tag 包含 studentName)
 */
async function sendStudentNotification(studentName, title, message) {
    // 您需要在 bindStudentIdentity 中增加 studentName 的 Tag 才能使用此功能
    // 這裡僅作示例
}

	

// === 1. 修改打開「學生雲端中心」的函式 ===
function openStudentLoginModal() {
    const modal = document.getElementById('studentCloudModal');
    if (modal) {
        // 1. ★★★ 強制關閉其他兩個全螢幕介面 ★★★
        document.getElementById('historyContainer').style.display = 'none';
        document.getElementById('toolsContainer2').style.display = 'none';

        // 2. 顯示視窗並鎖定捲動
        modal.style.display = 'block'; 
        document.body.style.overflow = 'hidden'; 
        
        // 3. 執行登入檢查
        checkStudentLogin();

        // 4. --- UI 按鈕狀態切換 ---
        // 隱藏「雲端同步」按鈕 (因為已經在雲端介面了)
        const cloudBtn = document.getElementById('sideMenuCloudBtn');
        if (cloudBtn) cloudBtn.style.display = 'none';

        // 顯示「返回主頁」按鈕
        const homeBtn = document.getElementById('sideMenuHomeBtn');
        if (homeBtn) homeBtn.style.display = 'flex';

        // 隱藏左上角浮動的返回按鈕
        const floatHomeBtn = document.getElementById('homeBtn');
        if (floatHomeBtn) floatHomeBtn.style.display = 'none';

        // 強制收起側邊選單
        const sideMenu = document.getElementById('sideMenu');
        if (sideMenu) {
            sideMenu.classList.remove('active');
            document.getElementById('sideMenuToggle').classList.remove('active');
        }
    }
}

// === 2. 修改關閉「學生雲端中心」的函式 ===
function closeStudentCloudModal() {
    // 直接呼叫 returnToHome()，它會負責：
    // 1. 播放退場動畫
    // 2. 隱藏雲端視窗
    // 3. 重新顯示主頁選單、標題、DSE倒數
    // 4. 解鎖頁面捲動
    returnToHome();
}

// ==========================================
// === 全新修訂：學生身份自動同步與轉班處理 ===
// ==========================================

// 修改原本的 checkStudentLogin
// 修改原本的 checkStudentLogin
// === 修改後：檢查登入狀態 (加入即時同步與監聽) ===
async function checkStudentLogin() {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    
    if (s) {
        // A. UI 切換
        document.getElementById('studentIdentityForm').style.display = 'none';
        document.getElementById('studentCloudPanel').style.display = 'block';
        
        // B. 更新歡迎語
        updateWelcomeMessage(s);
        
        // C. 載入課業列表
        loadAssignments(s.grade, s.class);

        // D. 啟動紅點監聽
        monitorPendingAssignments(); 

        // ★★★ 關鍵新增 1：頁面載入後，立即執行一次同步 ★★★
        // 確保本地資料與雲端一致 (例如老師剛剛刪除了作業)
        syncHistoryToFirebase(true);

        // ★★★ 關鍵新增 2：啟動即時監聽器 ★★★
        // 如果學生一直開著網頁，老師刪除資料時，這裡會收到通知並自動更新
        startAutoSyncListener();

        if (window.forceLogVisit) {
            window.forceLogVisit();
        }

        const user = firebase.auth().currentUser;
        if (user) {
            try { await user.reload(); } catch (error) { }
        }
        verifyStudentStatus(s);
    }
}

// 2. 輔助函式：更新歡迎文字
// 2. 輔助函式：更新歡迎文字 (優化顯示版)
function updateWelcomeMessage(profile) {
    let displayStr = '';
    
    // 如果是老師 (System/Test)，顯示特殊格式
    if (profile.grade === 'System') {
        displayStr = `系統測試 - ${profile.name}`;
    } else {
        // 如果是學生，顯示正常格式
        const numDisplay = profile.number ? `(${profile.number})` : '';
        displayStr = `${profile.grade}${profile.class} ${numDisplay} - ${profile.name}`;
    }

    document.getElementById('welcomeText').innerHTML = 
        `你好，${displayStr} 
         <span style="font-size:0.8em; color:#ccc; margin-left:5px;" id="syncStatusIcon"></span>`;
}

// 3. 【核心新增】驗證學生狀態 (同步資料 + 處理轉班 + 處理帳號失效)
// === 1. 嚴格驗證函式 (防止寫入幽靈資料) ===
async function verifyStudentStatus(localProfile) {
    const statusIcon = document.getElementById('syncStatusIcon');
    if(statusIcon) statusIcon.innerHTML = '<i class="fas fa-sync fa-spin"></i>'; 

    // 路徑：students/Grade/Class/Name/profile
    const path = `students/${localProfile.grade}/${localProfile.class}/${localProfile.name}/profile`;

    try {
        const snapshot = await database.ref(path).once('value');
        const cloudData = snapshot.val();

        if (cloudData) {
            // A. 資料存在，檢查班號是否為空
            if (!cloudData.number || cloudData.number === "") {
                // ★★★ 觸發：班號輸入請求 ★★★
                promptForNewClassNumber(localProfile, path);
            } 
            else if (cloudData.number != localProfile.number) {
                // 班號存在但不一樣 (例如老師手動改了)，同步本地
                localProfile.number = cloudData.number;
                localStorage.setItem('studentProfile', JSON.stringify(localProfile));
                updateWelcomeMessage(localProfile);
            }
            if(statusIcon) statusIcon.innerHTML = ''; 
        } else {
            // B. 資料不存在 (可能升班了)，執行全校搜尋
            console.warn("原路徑找不到資料，啟動全校搜尋...");
            findStudentNewLocation(localProfile.name);
        }
    } catch (error) {
        console.error("同步檢查失敗:", error);
    }
}

// === 新增：班號輸入介面 ===
// === 1. 暫存變數，用於跨函式傳遞資料 ===
let pendingUpdateProfile = null;
let pendingUpdatePath = null;

// === 2. 顯示班號更新視窗 (取代原本的 prompt) ===
function promptForNewClassNumber(profile, firebasePath) {
    // 儲存資料以便確認時使用
    pendingUpdateProfile = profile;
    pendingUpdatePath = firebasePath;

    // 初始化下拉選單 (1-35)
    const select = document.getElementById('newClassNumberSelect');
    select.innerHTML = '';
    for (let i = 1; i <= 35; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.innerText = i;
        select.appendChild(opt);
    }

    // 顯示視窗 (強制最上層)
    const modal = document.getElementById('classNumberUpdateModal');
    if (modal) {
        // ★ 強制搬運到 body 最外層，防止被遮擋 ★
        document.body.appendChild(modal);
        
        modal.style.display = 'flex';
    }
}

// === 3. 確認更新班號 (點擊按鈕觸發) ===
async function confirmClassNumberUpdate() {
    const select = document.getElementById('newClassNumberSelect');
    const newNum = select.value;
    const modal = document.getElementById('classNumberUpdateModal');
    const btn = modal.querySelector('button');

    // UI 鎖定
    btn.disabled = true;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 更新中...';

    try {
        // 寫入 Firebase
        await database.ref(pendingUpdatePath).update({ number: newNum });
        
        // 更新本地儲存
        pendingUpdateProfile.number = newNum;
        localStorage.setItem('studentProfile', JSON.stringify(pendingUpdateProfile));
        
        // 刷新歡迎語
        updateWelcomeMessage(pendingUpdateProfile);

        // 關閉視窗
        modal.style.display = 'none';
        alert(`✅ 班號已更新為：${newNum}`);

    } catch (err) {
        alert("更新失敗，請檢查網絡。\n" + err.message);
    } finally {
        btn.disabled = false;
        btn.innerText = '確認更新';
    }
}

// (舊的 fallback，備用)
function fallbackPrompt(profile, firebasePath) {
    let newNum = window.prompt(`👋 新學年好！\n請輸入您在 ${profile.grade}${profile.class} 班的新班號 (1-35)：`);
    if (newNum && !isNaN(newNum)) {
        database.ref(firebasePath).update({ number: newNum });
        profile.number = newNum;
        localStorage.setItem('studentProfile', JSON.stringify(profile));
        updateWelcomeMessage(profile);
        alert("✅ 班號已更新！");
    }
}

// === 2. 全校搜尋函式 (處理升班與刪除) ===
// ===============================================================
// === [核心修復] 自動轉班與班號視窗即時彈出邏輯 ===
// ===============================================================

// 1. 覆寫：全校搜尋函式 (移除重新整理，改為即時彈窗)
async function findStudentNewLocation(studentName) {
    console.log(`[系統] 正在全校搜尋學生新位置: ${studentName}...`);
    
    try {
        const snapshot = await database.ref('students').once('value');
        const allData = snapshot.val();
        
        let found = false;
        let newGrade = '';
        let newClass = '';
        let newInfo = null;

        if (allData) {
            for (const grade in allData) {
                for (const cls in allData[grade]) {
                    const studentsInClass = allData[grade][cls];
                    if (studentsInClass && studentsInClass[studentName]) {
                        found = true;
                        newGrade = grade;
                        newClass = cls;
                        newInfo = studentsInClass[studentName].profile;
                        break;
                    }
                }
                if (found) break;
            }
        }

        if (found && newInfo) {
            // === 情況 A: 找到新位置 (自動修正並彈窗) ===
            const newProfile = {
                name: studentName,
                grade: newGrade,
                class: newClass,
                number: newInfo.number || "",
                email: newInfo.email
            };
            
            // 1. 更新本地儲存
            localStorage.setItem('studentProfile', JSON.stringify(newProfile));
 
            // ★★★ 新增這段：強制清空本地 IndexedDB 歷史紀錄 ★★★
            // 因為已經轉班，舊的紀錄不再適用，且防止回傳到新班級資料庫
            try {
                const db = await openHistoryDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.clear(); // <--- 徹底清空
                console.log("已因應轉班清除本地舊紀錄");
            } catch (e) {
                console.error("清除本地紀錄失敗", e);
            }
            // ★★★ 新增結束 ★★★
            
            // 2. 顯示提示
            alert(`👋 歡迎回來！\n系統偵測到新學年資料變更。\n\n您的位置已更新為：${newGrade}${newClass} 班\n(舊的歷史紀錄已封存並移除)`);
            
            // 3. ★ 核心修正：立即更新 UI，不重新整理頁面 ★
            updateWelcomeMessage(newProfile);
            loadAssignments(newGrade, newClass);
            
            // 4. 重啟監聽器 (針對新班級)
            monitorPendingAssignments();
            startAutoSyncListener(); 

            // 5. ★ 關鍵動作：立即彈出班號輸入視窗 ★
            const newPath = `students/${newGrade}/${newClass}/${studentName}/profile`;
            promptForNewClassNumber(newProfile, newPath);
            
            return; 

        } else {
            // 2. 搜尋待分班區
            const pendingSnap = await database.ref('pending_allocation/' + studentName).once('value');
            
            if (pendingSnap.exists()) {
                alert("⏳ 您的資料目前在「待分班名單」中 (例如中三升中四)。\n請等待老師完成分班作業後再登入。");
                return; 
            }

            // 3. 徹底找不到
            console.warn("資料庫無此人，判定為舊學年殘留資料。");
            alert("⚠️ 系統資料庫已更新。\n\n您的舊身份已失效，請重新登入。");
            handleStudentLogout(); 
        }

    } catch (error) {
        console.error("搜尋錯誤:", error);
    }
}

// 2. 覆寫：自動同步監聽器 (新增 Profile 監聽，實現自動觸發)
// 用於儲存 Profile 監聽器，避免重複
let autoProfileListenerRef = null;

function startAutoSyncListener() {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (!s) return;

    // --- A. 歷史紀錄同步 (保持原樣) ---
    if (autoSyncListenerRef) autoSyncListenerRef.off();
    const historyPath = `students/${s.grade}/${s.class}/${s.name}/history`;
    autoSyncListenerRef = database.ref(historyPath);
    autoSyncListenerRef.on('value', (snapshot) => {
        if (isSyncingLock) return;
        console.log("⚡ 偵測到雲端歷史變更，執行同步...");
        isSyncingLock = true;
        syncHistoryToFirebase(true).then(() => {
            setTimeout(() => { isSyncingLock = false; }, 2000);
        });
    });

    // --- B. ★ 新增：身份狀態監聽 (這是自動彈出的關鍵) ---
    if (autoProfileListenerRef) autoProfileListenerRef.off();
    
    const profilePath = `students/${s.grade}/${s.class}/${s.name}/profile`;
    autoProfileListenerRef = database.ref(profilePath);

    autoProfileListenerRef.on('value', (snapshot) => {
        const val = snapshot.val();

        if (!val) {
            // 情況 1: 資料消失 (代表老師剛剛執行了轉班/升班操作)
            console.log("⚠️ 偵測到當前班級資料消失，正在搜尋新位置...");
            
            // 立即停止監聽舊路徑，防止報錯
            autoProfileListenerRef.off(); 
            if (autoSyncListenerRef) autoSyncListenerRef.off();

            // 觸發全校搜尋 -> 這裡會呼叫上面的 findStudentNewLocation -> 彈出班號視窗
            findStudentNewLocation(s.name);
        } 
        else if (!val.number || val.number === "") {
            // 情況 2: 資料還在，但班號被清空 (可能是原地升班或資料重置)
            console.log("⚠️ 偵測到班號需更新，彈出視窗...");
            promptForNewClassNumber(s, profilePath);
        }
    });
    
    console.log("✅ 實時狀態監聽器已啟動");
}
	
// 1. 初始化班號選項 (請放在 initDSECalendar 或 DOMContentLoaded 內執行，或是直接放在 script 最後)
function initClassNumbers() {
    const select = document.getElementById('studentNumber');
    if (!select) return;
    select.innerHTML = '';
    for (let i = 1; i <= 32; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.innerText = i; // 顯示數字
        select.appendChild(opt);
    }
}
// 呼叫初始化
document.addEventListener('DOMContentLoaded', initClassNumbers);




// === 新增：學校電郵登入處理函式 ===
// === 修改後：學校電郵登入處理函式 (支援手機 Redirect) ===
async function handleSchoolLogin() {
    // 1. 獲取用戶輸入的資料
    const manualName = document.getElementById('studentNameInput').value.trim();
    const grade = document.getElementById('studentGrade').value;
    const cls = document.getElementById('studentClass').value;
    const number = document.getElementById('studentNumber').value;
    
    // 2. 驗證姓名是否已填寫
    if (!manualName) {
        alert("請務必填寫您的「中文姓名」才能進行註冊！");
        document.getElementById('studentNameInput').focus();
        return;
    }

    const btn = event.target.closest('button'); 
    const originalContent = btn.innerHTML;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 驗證中...';
    btn.disabled = true;

    // 3. 暫存資料 (以防萬一)
    const tempStudentData = {
        manualName: manualName,
        grade: grade,
        cls: cls,
        number: number
    };
    sessionStorage.setItem('sansi_temp_student_data', JSON.stringify(tempStudentData));

    const provider = new firebase.auth.GoogleAuthProvider();
    provider.setCustomParameters({ prompt: 'select_account' });

    try {
        // ★★★ 關鍵修改：不分手機電腦，統一使用 Popup ★★★
        // 這能確保頁面不刷新，資料與狀態得以保留
        const result = await auth.signInWithPopup(provider);
        await processLoginResult(result.user, btn, originalContent);

    } catch (error) {
        console.error("登入錯誤:", error);
        
        // 處理手機瀏覽器常見的 Popup 被阻擋問題
        if (error.code === 'auth/popup-blocked') {
            alert("⚠️ 登入視窗被瀏覽器阻擋了。\n\n請允許此網站顯示彈出式視窗，或嘗試使用其他瀏覽器 (如 Chrome)。");
        } else if (error.code === 'auth/popup-closed-by-user') {
            // 用戶自己關閉視窗，不做處理
        } else {
            alert("登入發生錯誤：" + error.message);
        }
        
        btn.innerHTML = originalContent;
        btn.disabled = false;
    }
}


// === 新增：全校電郵搜尋函式 ===
async function findProfileByEmail(targetEmail) {
    try {
        // 讀取全校學生資料 (注意：若學生人數非常多，建議未來改用 Firebase Index)
        const snapshot = await database.ref('students').once('value');
        const allData = snapshot.val();
        
        if (!allData) return null;

        // 遍歷所有年級、班級、學生
        for (const grade in allData) {
            for (const cls in allData[grade]) {
                const studentsInClass = allData[grade][cls];
                for (const name in studentsInClass) {
                    const profile = studentsInClass[name].profile;
                    // 如果找到電郵相符的紀錄
                    if (profile && profile.email === targetEmail) {
                        return profile; // 回傳該學生的原始資料
                    }
                }
            }
        }
        return null; // 沒找到，代表是新用戶
    } catch (error) {
        console.error("搜尋電郵失敗:", error);
        return null;
    }
}

	

// === 修改後：統一處理登入後的邏輯 (加入唯一性檢查) ===

// === 修改後：統一處理登入後的邏輯 (加入唯一性檢查 & 支援新特許用家) ===
async function processLoginResult(user, btn, originalContent) {
    // 1. 獲取用戶輸入的資料 (優先從 SessionStorage 恢復，否則從 DOM 獲取)
    let manualName, grade, cls, number;
    
    const storedData = sessionStorage.getItem('sansi_temp_student_data');
    if (storedData) {
        const data = JSON.parse(storedData);
        manualName = data.manualName;
        grade = data.grade;
        cls = data.cls;
        number = data.number;
    } else {
        manualName = document.getElementById('studentNameInput')?.value.trim();
        grade = document.getElementById('studentGrade')?.value;
        cls = document.getElementById('studentClass')?.value;
        number = document.getElementById('studentNumber')?.value;
    }
 
    if (!manualName) {
        alert("資料遺失，請重新輸入姓名後再試一次。");
        if (btn) { btn.innerHTML = originalContent; btn.disabled = false; }
        return;
    }
 
    const email = user.email;
    
    // === 設定特定帳號 (BASE64 編碼) ===
    const DEBUG_USER_B64 = 'a2VuY2hhbjIwMTQxQGdtYWlsLmNvbQ==';   
    const STUDENT_ADD_B64 = 'a2VuY2hhbjIwMTMxQGdtYWlsLmNvbQ==';  
    const SPECIAL_USER_B64 = 'a2VuY2hhbjIwMTUxQGdtYWlsLmNvbQ==';
    const SPECIAL_USER_2_B64 = 'Y2hhbnN1bWx1aTIwMDVAZ21haWwuY29t'; // ★ 新增：chansumlui2005
 
    const debugUser = atob(DEBUG_USER_B64);
    const studentUserAdd = atob(STUDENT_ADD_B64);
    const specialUserAdd = atob(SPECIAL_USER_B64);
    const specialUser2Add = atob(SPECIAL_USER_2_B64); // ★ 解碼
 
    // 2. 檢查電郵網域 (允許學校電郵及白名單電郵)
    if (!email.endsWith('@ccckyc.edu.hk') &&
        email !== debugUser &&
        email !== studentUserAdd &&
        email !== specialUserAdd &&
        email !== specialUser2Add) { // ★ 加入檢查條件
        
        await auth.signOut();
        alert("⛔ 驗證失敗！\n\n請必須使用「@ccckyc.edu.hk」的學校電郵登入。");
        sessionStorage.removeItem('sansi_temp_student_data');
        if (btn) { btn.innerHTML = originalContent; btn.disabled = false; }
        return;
    }
 
    // === 教師名單識別 ===
    const TEACHER_B64_LIST = [
        "Y2trQGNjY2t5Yy5lZHUuaGs=",
        "dGx5QGNjY2t5Yy5lZHUuaGs=",
        "bHN0QGNjY2t5Yy5lZHUuaGs=",
        "Y2tjQGNjY2t5Yy5lZHUuaGs=",
        "c2tzQGNjY2t5Yy5lZHUuaGs=",
        "eWhjQGNjY2t5Yy5lZHUuaGs=",
        "d2ZjQGNjY2t5Yy5lZHUuaGs=",
        "dHVuZ0BjY2NreWMuZWR1Lmhr",
        "a2J5QGNjY2t5Yy5lZHUuaGs=",
        "d3B5QGNjY2t5Yy5lZHUuaGs=",
        DEBUG_USER_B64
    ];
 
    let isTeacher = false;
    
    // 遍歷並解碼比對教師名單
    for (let b64 of TEACHER_B64_LIST) {
        try {
            if (atob(b64) === email) {
                isTeacher = true;
                break;
            }
        } catch(e) {
            console.error("解碼錯誤", e);
        }
    }
 
    if (isTeacher) {
        console.log("身份識別：教師");
        // 強制覆寫變數，無視下拉選單的選擇
        grade = "System";
        cls = "Test";
        number = "99";
        alert(`👋 老師您好！\n系統已識別您的身份，將自動進入「系統測試班」 (System/Test)。\n您的所有操作將不會影響真實學生數據。`);
    }
 
    // === 新增：特許用家 (白名單) 識別 ===
    let isSpecialUser = false;
    // ★ 加入 specialUser2Add 的判斷
    if (email === specialUserAdd || email === specialUser2Add) {
        console.log("身份識別：特許用家 (白名單)");
        isSpecialUser = true;
        // 強制覆寫變數，進入白名單區域
        grade = "Special";
        cls = "User";
        // number 保持用戶輸入或設為預設值
        alert(`👋 歡迎特許用家！\n您已登入白名單帳號，享有無限生成權限。`);
    }
 
    // 3. 檢查帳號是否已存在於資料庫
    const existingProfile = await findProfileByEmail(email);
 
    if (existingProfile) {
        // A. 帳號已存在 (登入舊帳號)
        const oldLocation = `${existingProfile.grade}${existingProfile.class}`;
        const newLocation = `${grade}${cls}`;
 
        // 如果位置不同，提示用戶 (一般學生轉班的情況)
        if (oldLocation !== newLocation) {
            if (!isTeacher && !isSpecialUser) {
                alert(`⚠️ 偵測到此電郵已註冊！\n\n您已在【${oldLocation}班】擁有帳號。\n系統將登入您的原有帳號。`);
            }
        }
 
        // 強制遷移邏輯：
        // 1. 如果是老師，但舊資料不在 System/Test
        // 2. 如果是特許用家，但舊資料不在 Special/User
        if ((isTeacher && (existingProfile.grade !== "System" || existingProfile.class !== "Test")) ||
            (isSpecialUser && (existingProfile.grade !== "Special" || existingProfile.class !== "User"))) {
             
             console.log("將特殊帳號遷移至指定區域...");
             // 使用新的強制變數覆蓋舊資料
             await bindStudentIdentity(grade, cls, number, manualName, email, user.uid);
             
             // 重新建立 Profile 物件
             const newProfile = { grade: grade, class: cls, number: number, name: manualName, email: email };
             localStorage.setItem('studentProfile', JSON.stringify(newProfile));
             updateWelcomeMessage(newProfile);
             loadAssignments(grade, cls);
 
        } else {
             // 普通學生，或已經在正確位置的特殊帳號
             // 使用資料庫中的舊資料登入 (忽略本次輸入的班級)
             localStorage.setItem('studentProfile', JSON.stringify(existingProfile));
             updateWelcomeMessage(existingProfile);
             loadAssignments(existingProfile.grade, existingProfile.class);
        }
        
        sessionStorage.removeItem('sansi_temp_student_data');
        document.getElementById('studentIdentityForm').style.display = 'none';
        document.getElementById('studentCloudPanel').style.display = 'block';
        
        monitorPendingAssignments();
        
        // ★ 呼叫你的恢復封存函式 (如果有的話)
        if (typeof tryRestoreArchivedHistory === 'function') {
            await tryRestoreArchivedHistory(JSON.parse(localStorage.getItem('studentProfile')));
        }
 
        await syncHistoryToFirebase(true);
        startAutoSyncListener();
 
    } else {
        // B. 新用戶註冊
        console.log("新用戶註冊...");
        // 這裡的 grade/cls 已經經過上面的 Teacher/Special 判斷並可能被覆寫
        await bindStudentIdentity(grade, cls, number, manualName, email, user.uid);
        sessionStorage.removeItem('sansi_temp_student_data');
        
        await syncHistoryToFirebase(true);
        startAutoSyncListener();
    }
}

// === 新增：學生登出處理函式 ===
async function handleStudentLogout() {
    if (!confirm("確定要登出學生帳號嗎？\n(登出後下次需要重新輸入姓名驗證)")) {
        return;
    }

	 // ★★★ [新增] OneSignal 標籤移除 ★★★
    if (window.OneSignalDeferred) {
        window.OneSignalDeferred.push(function(OneSignal) {
            // 移除年級和班別標籤，停止接收該班通知
            OneSignal.User.removeTags(["grade", "class"]);
        });
    }
    // ★★★ [新增結束] ★★★


	 // ★★★ 新增：移除紅點監聽 ★★★
    if (pendingMonitorRef) {
        pendingMonitorRef.off();
        pendingMonitorRef = null;
    }
    const badge = document.getElementById('notifBadge');
    if(badge) badge.style.display = 'none';
    // ★★★ 新增結束 ★★★

    try {
        // 1. Firebase 登出
        await firebase.auth().signOut();
    } catch (e) {
        console.error("Firebase 登出錯誤 (可忽略):", e);
    }

    // 2. 清除本地學生資料
    localStorage.removeItem('studentProfile');
    
    // 3. 清除相關的課業緩存 (這裡使用萬用字元清除該使用者的緩存較難，暫時清除當前頁面狀態即可)
    // 若您有特定的緩存命名規則，可在這裡一併移除

    // 4. UI 界面重置
    document.getElementById('studentCloudPanel').style.display = 'none';
    document.getElementById('studentIdentityForm').style.display = 'block';
    
    // 重置按鈕狀態
    const loginBtn = document.querySelector('#studentIdentityForm button');
    if (loginBtn) {
        loginBtn.innerHTML = '<i class="fab fa-google"></i> 學校帳號登入';
        loginBtn.disabled = false;
    }

    // 重置輸入框 (選擇性)
    document.getElementById('studentNameInput').value = '';
    
    // 5. 提示訊息
    alert("已成功登出！");
}

	
// === 綁定並儲存學生資料到 Database ===
async function bindStudentIdentity(grade, cls, number, name, email, uid) {
    const path = `students/${grade}/${cls}/${name}/profile`;

    try {
        // ... (Firebase 更新代碼保持不變) ...
        const updatePromise = database.ref(path).update({
            name: name, grade: grade, class: cls, number: number, email: email, uid: uid,
            last_login: new Date().toLocaleString('zh-HK'), status: 'active'
        });

        // 建立本地資料物件
        const profile = { grade, class: cls, number, name, email };
        localStorage.setItem('studentProfile', JSON.stringify(profile));

        // ★★★ [新增] OneSignal 標籤設定 (參考您的成功案例) ★★★
        if (window.OneSignalDeferred) {
            window.OneSignalDeferred.push(function(OneSignal) {
                // 這是分類的關鍵：給瀏覽器貼上 "4A" 的標籤
                OneSignal.User.addTags({
                    grade: grade,
                    class: cls,
                    userType: 'student'
                });
                console.log("OneSignal 標籤已設定");
            });
        }
        // ★★★ [新增結束] ★★★

        // ... (原本的 UI 更新代碼) ...
        alert(`✅ 驗證成功！\n\n歡迎你，${name}。`);
        document.getElementById('studentIdentityForm').style.display = 'none';
        document.getElementById('studentCloudPanel').style.display = 'block';
        updateWelcomeMessage(profile);
        loadAssignments(grade, cls);
        await updatePromise;

    } catch (error) {
        console.error("資料庫寫入失敗:", error);
    }
}
	
// 3. 輔助函式：完成登入 (更新本地儲存)
function finishLogin(grade, cls, number, name) {
    const profile = { grade, class: cls, number, name };
    localStorage.setItem('studentProfile', JSON.stringify(profile));
    checkStudentLogin();
    
    // 重置按鈕
    const btn = document.querySelector('#studentIdentityForm button');
    if(btn) { btn.innerHTML = '綁定身份'; btn.disabled = false; }
}


// === 修訂版 V8：背景熱更新 (秒開緩存 + 強制同步) ===
// === 修訂版 V10：分頁讀取 (流量救星) ===
async function loadAssignments(grade, cls) {
    const listDiv = document.getElementById('assignmentList');
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (!s) return;

    // 重置分頁狀態
    allAssignmentTasks = [];
    currentLoadedCount = 0;
    listDiv.innerHTML = '<div style="text-align:center; padding:20px;"><i class="fas fa-spinner fa-spin"></i> 載入中...</div>';

    // 移除舊的「載入更多」按鈕 (如果有的話)
    const oldBtn = document.getElementById('loadMoreAssignmentsBtn');
    if (oldBtn) oldBtn.remove();

    try {
        // 1. 讀取該班級的「功課清單」 (Metadata)
        // 這一步流量很小，因為 assignments/{grade}/{class} 下面只有題目和日期，沒有大量文字
        const assignmentsSnap = await database.ref(`assignments/${grade}/${cls}`).once('value');
        const assignmentsData = assignmentsSnap.val();

        if (!assignmentsData) {
            listDiv.innerHTML = '<div style="text-align:center; padding:20px;">目前沒有新課業</div>';
            return;
        }

        // 2. 將功課轉換為陣列並按時間倒序排列 (最新的在上面)
        allAssignmentTasks = Object.entries(assignmentsData).sort((a, b) => b[1].timestamp - a[1].timestamp);

        // 3. 清空列表，準備載入第一批
        listDiv.innerHTML = '';

        // 4. 載入第一批 (Top 5)
        await loadNextBatchAssignments();

    } catch (error) {
        console.error("載入失敗", error);
        listDiv.innerHTML = '<div style="text-align:center; padding:20px; color:red;">載入失敗，請檢查網絡。</div>';
    }
}


	// === 核心：分批載入詳細數據 ===
async function loadNextBatchAssignments() {
    const listDiv = document.getElementById('assignmentList');
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    
    // 1. 檢查是否還有更多資料
    if (currentLoadedCount >= allAssignmentTasks.length) {
        return; 
    }

    // 2. 顯示局部 Loading (放在列表底部)
    let loadingDiv = document.createElement('div');
    loadingDiv.id = 'batchLoading';
    loadingDiv.style.cssText = "text-align:center; padding:10px; color:#aaa; font-size:0.9em;";
    loadingDiv.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> 讀取中...';
    listDiv.appendChild(loadingDiv);

    // 3. 切片：取出接下來的 5 份 (例如 0-5, 5-10)
    const nextBatch = allAssignmentTasks.slice(currentLoadedCount, currentLoadedCount + BATCH_SIZE);

    try {
        // 4. 並行查詢：只下載這 5 份的提交狀態 (HTML 內容)
        const results = await Promise.all(nextBatch.map(async ([key, task]) => {
            const subPath = `assignments_submissions/${key}/${s.name}`;
            const subSnap = await database.ref(subPath).once('value');
            const submission = subSnap.val(); 
            return { key, task, submission };
        }));

        // 移除 Loading
        if (loadingDiv) loadingDiv.remove();

        // 5. 渲染這 5 份 (傳入 true 代表 append)
        renderAssignmentList(results, false, true); // 注意：需修改 renderAssignmentList 支援 append

        // 6. 更新計數器
        currentLoadedCount += nextBatch.length;

        // 7. 檢查是否需要顯示「載入更多」按鈕
        manageLoadMoreButton();

    } catch (error) {
        console.error("分批讀取錯誤", error);
        if (loadingDiv) loadingDiv.innerHTML = "讀取失敗，請重試";
    }
}

// === 管理「載入更多」按鈕的顯示 ===
function manageLoadMoreButton() {
    const listDiv = document.getElementById('assignmentList');
    
    // 先移除舊按鈕
    const existingBtn = document.getElementById('loadMoreAssignmentsBtn');
    if (existingBtn) existingBtn.remove();

    // 如果還有剩餘資料，就加回按鈕
    if (currentLoadedCount < allAssignmentTasks.length) {
        const remaining = allAssignmentTasks.length - currentLoadedCount;
        
        const btn = document.createElement('button');
        btn.id = 'loadMoreAssignmentsBtn';
        // 使用莫蘭迪灰色系樣式
        btn.style.cssText = "width:100%; padding:10px; margin-top:10px; background:#e0e0e0; color:#555; border:none; border-radius:8px; cursor:pointer; font-weight:bold;";
        btn.innerHTML = `顯示較舊的課業 (${remaining})`;
        
        btn.onclick = function() {
            this.disabled = true; // 防止連點
            loadNextBatchAssignments();
        };

        listDiv.appendChild(btn);
    }
}

	
// === 輔助函數：渲染列表 HTML (避免代碼重複) ===
// === 輔助函數：渲染列表 HTML (CSP 修復版) ===
// 參數: isSyncing (舊參數), isAppend (新參數: true=附加到底部, false=清空重畫)
function renderAssignmentList(dataArray, isSyncing, isAppend = false) {
    const listDiv = document.getElementById('assignmentList');
    
    // 如果不是 Append 模式，才清空列表
    if (!isAppend) {
        listDiv.innerHTML = '';
    }

    // 莫蘭迪色系
    const morandiPalette = ['#8fa398', '#94a7b5', '#b6a6ca', '#d69a92', '#c7b299'];

    if (isSyncing) {
        listDiv.innerHTML += `<div>...</div>`;
        return;
    }

    dataArray.forEach((item, index) => {
        const task = item.task;
        const submission = item.submission;
        const themeColor = morandiPalette[index % morandiPalette.length];

        let uiClass = '';
        let statusIcon = '';
        let statusText = '';
        let clickHandler = null; // 用來儲存點擊事件的函數
        let dateDisplay = new Date(task.timestamp).toLocaleDateString('zh-HK', {month:'2-digit', day:'2-digit'});

        if (submission && submission.teacherFeedback && submission.teacherFeedback.status === 'returned') {
            uiClass = 'status-returned';
            statusIcon = '<i class="fas fa-envelope-open-text"></i>';
            statusText = '查看評語';
            submission.topic = task.topic; 
            const submissionStr = encodeURIComponent(JSON.stringify(submission));
            
            // ★★★ 修復重點：直接定義函數，而不是字串 ★★★
            clickHandler = function() { showTeacherFeedback(submissionStr); };
        }
        else if (submission) {
            uiClass = 'status-submitted';
            statusIcon = '<i class="fas fa-check-circle" style="color:#5e7067;"></i>';
            statusText = '<span style="color:#5e7067;">已繳交</span>';
            submission.topic = task.topic;
            submission.isPending = true; 
            const submissionStr = encodeURIComponent(JSON.stringify(submission));
            
            // ★★★ 修復重點：直接定義函數 ★★★
            clickHandler = function() { showTeacherFeedback(submissionStr); };
        }
        else {
            uiClass = 'status-pending';
            statusIcon = '<i class="fas fa-pen"></i>'; 
            statusText = '未繳交';
            
            // ★★★ 修復重點：直接定義函數 ★★★
            clickHandler = function() { goToHistoryForAssignment(task.topic); };
        }

        // 建立 DOM 元素
        const cardDiv = document.createElement('div');
        cardDiv.className = `task-card ${uiClass}`;
        
        // ★★★ 修復重點：直接將函數賦值給 onclick，移除 eval() ★★★
        cardDiv.onclick = clickHandler; 
        
        cardDiv.style.setProperty('--theme-color', themeColor);
        cardDiv.innerHTML = `
            <div class="task-info">
               <div class="task-topic" style="color: ${themeColor};">${task.topic}</div>
                <div class="task-meta">
                    <span class="task-type-tag" style="background-color: ${themeColor}; color: white; border:none;">${task.type}</span>
                    <span><i class="far fa-clock"></i> ${dateDisplay}</span>
                </div>
            </div>
            <div class="task-status">
                ${statusIcon} <span style="margin-left:5px;">${statusText}</span>
            </div>
        `;
        
        listDiv.appendChild(cardDiv);
    });
}
	// === 新增：從未繳交課業跳轉至歷史紀錄 ===
// === 新增：從未繳交課業跳轉至歷史紀錄 (無提示版) ===
function goToHistoryForAssignment(topic) {
    // 1. 關閉「學生雲端中心」彈窗
    document.getElementById('studentCloudModal').style.display = 'none';
    
    // 2. 打開「歷史紀錄」容器 (這會自動顯示第一層的五個範疇卡片)
    openHistoryContainer();
    
    // 3. 滾動到頁面頂部
    window.scrollTo({ top: 0, behavior: 'instant' });
}
// === 顯示老師回饋 (彈窗) ===
// === 最終修訂版：顯示老師回饋 (隱藏右上角日期 + 大地色系) ===
function showTeacherFeedback(submissionStr) {
    let record;
    try {
        record = JSON.parse(decodeURIComponent(submissionStr));
    } catch (e) {
        console.error("解析失敗", e);
        return alert("資料讀取錯誤");
    }

    const feedback = record.teacherFeedback || {};
    const isPending = record.isPending === true;

    // 1. 決定主題顏色
    let themeIndex = 1;
    if (record.category && HISTORY_STRUCTURE[record.category]) {
        const subIndex = HISTORY_STRUCTURE[record.category].indexOf(record.subFunction);
        if (subIndex !== -1) {
            themeIndex = (subIndex % 5) + 1;
        }
    }
    const themeClass = `history-theme-context-${themeIndex}`;

    // 2. 構建「老師回饋」區塊
    let teacherFeedbackHTML = '';
    
    if (isPending) {
        // 待批改
        teacherFeedbackHTML = `
            <div style="background:#f4f8f6; border:2px dashed #8fa398; border-radius:12px; padding:20px; text-align:center;">
                <h3 style="color:#5e7067; margin-top:0;"><i class="fas fa-check-circle"></i> 作業已繳交</h3>
                <p style="color:#666; margin-bottom:5px;">老師尚未批改這份作業。</p>
                <small style="color:#999;">繳交日期：${record.submittedAt ? record.submittedAt.split(' ')[0] : '未知'}</small>
            </div>
        `;
    } else {
        // 已發還
        const scoreDisplay = feedback.score ? `<div class="teacher-score-badge">${feedback.score}</div>` : '';
        const dateObj = feedback.timestamp ? new Date(feedback.timestamp) : null;
        const dateStr = dateObj ? dateObj.toLocaleDateString('zh-HK') : '未知';
        const commentText = feedback.comment ? feedback.comment.trim() : "（沒有文字評語）";

        teacherFeedbackHTML = `
            <div class="teacher-feedback-section">
                <div class="teacher-feedback-header">
                    <div class="teacher-feedback-title">
                        <i class="fas fa-chalkboard-teacher"></i> 老師回饋
                    </div>
                    ${scoreDisplay}
                </div>
                <div class="teacher-comment-content">${commentText}</div>
                
                <div style="text-align:right; margin-top:15px; font-size:0.85em; color:#a1887f;">
                    <i class="far fa-calendar-alt"></i> 批改日期：${dateStr}
                </div>
            </div>
        `;
    }

    // 3. 構建整體內容 HTML
    let contentHTML = teacherFeedbackHTML;

    // 如果有學生內容，加入分隔線
    if (record.userContent || record.aiContent) {
        contentHTML += `<div class="feedback-separator"></div>`;
    }

    // 4. 構建「學生原稿」區塊
    if (record.userContent) {
        const rawText = record.userContent;
        const lines = rawText.split('\n');
        let parsedHTML = `<div class="history-parsed-container ${themeClass}">`;
        let currentLabel = '輸入內容'; 
        let currentContent = [];
        const labelRegex = /^(.{2,10}?)[：:](.*)$/;

        lines.forEach((line) => {
            const match = line.match(labelRegex);
            if (match) {
                if (currentContent.length > 0) {
                    parsedHTML += `<div class="history-item-block"><div class="history-item-label">${currentLabel}</div><div class="history-item-content">${currentContent.join('\n')}</div></div>`;
                }
                currentLabel = match[1].trim(); 
                const restOfLine = match[2].trim();
                currentContent = restOfLine ? [restOfLine] : []; 
            } else {
                if (line.trim() !== "") currentContent.push(line);
            }
        });

        if (currentContent.length > 0 || lines.length === 0) { 
             const finalContent = currentContent.length > 0 ? currentContent.join('\n') : rawText;
             parsedHTML += `<div class="history-item-block"><div class="history-item-label">${currentLabel}</div><div class="history-item-content">${finalContent}</div></div>`;
        }
        parsedHTML += '</div>';
        
        contentHTML += `<div style="background:#fff; padding:20px; border-radius:12px; margin-bottom:25px; border:1px solid #eee; box-shadow: 0 4px 20px rgba(0,0,0,0.04);">
                            ${parsedHTML}
                        </div>`;
    }

    // 加入 AI 分析結果 (這裡通常包含 HTML 結構，但不包含活的 Canvas)
    if (record.aiContent) {
        contentHTML += `<div class="ai-output-area" style="margin-top: 15px;">${record.aiContent}</div>`;
    }

    // 5. 顯示 Modal
    const historyModal = document.getElementById('historyModal');
    const modalTitle = document.getElementById('historyModalTitle');
    const modalContent = document.getElementById('historyModalContent');
    const modalDate = document.getElementById('historyModalDate');

    modalTitle.innerHTML = `<span style="color:#2A9689; font-weight:bold;">${record.topic || "課業紀錄"}</span>`;
    
    if (modalDate) {
        modalDate.style.display = 'none'; 
    }

    modalContent.innerHTML = contentHTML;
    historyModal.style.display = 'flex';

    // 6. ★★★ [核心修復] 雷達圖重繪邏輯 ★★★
    // 使用 setTimeout 確保 DOM 渲染完成後再繪圖
    setTimeout(() => {
        // 檢查是否有分數數據
        if (record.scoreData && record.scoreData.radar) {
            
            // A. 嘗試在 AI 輸出區域尋找現有的 Canvas
            let canvasEl = modalContent.querySelector('canvas');

            // B. 如果找不到 (例如舊資料的 aiContent 裡沒有 Canvas 標籤)，則動態建立一個
            if (!canvasEl) {
                const aiOutputArea = modalContent.querySelector('.ai-output-area');
                if (aiOutputArea) {
                    // 建立圖表容器
                    const chartWrapper = document.createElement('div');
                    chartWrapper.style.width = '100%';
                    chartWrapper.style.maxWidth = '500px';
                    chartWrapper.style.height = '350px';
                    chartWrapper.style.margin = '20px auto';
                    chartWrapper.style.position = 'relative';
                    
                    // 建立 Canvas
                    const newCanvas = document.createElement('canvas');
                    chartWrapper.appendChild(newCanvas);
                    
                    // 將圖表插入到 AI 內容的最上方
                    aiOutputArea.insertBefore(chartWrapper, aiOutputArea.firstChild);
                    
                    canvasEl = newCanvas;
                }
            }

            // C. 執行 Chart.js 繪圖
            if (canvasEl) {
                const radarData = [
                    record.scoreData.radar.立意 || 0,
                    record.scoreData.radar.取材 || 0,
                    record.scoreData.radar.扣題 || 0,
                    record.scoreData.radar.詳略 || 0,
                    record.scoreData.radar.詞彙 || 0,
                    record.scoreData.radar.文學性 || 0
                ];

                new Chart(canvasEl.getContext('2d'), {
                    type: 'radar',
                    data: {
                        labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
                        datasets: [{
                            label: '能力評估',
                            data: radarData,
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2,
                            pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                            pointBorderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, // 關鍵：允許填滿高度
                        scales: {
                            r: {
                                angleLines: { display: true },
                                suggestedMin: 0,
                                suggestedMax: 10,
                                pointLabels: {
                                    font: { size: 14, family: "'Noto Serif TC', serif" }
                                },
                                ticks: { stepSize: 2, display: false }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        }
                    }
                });
            }
        }
    }, 100); // 延遲 100ms 確保 HTML 已注入
}
// === 執行未繳交課業動作 (簡化版) ===
function doAssignment(type, topic) {
    document.getElementById('studentCloudModal').style.display = 'none';
    
    // 跳轉邏輯 (與之前相同)
    if (type === '敘事' || type === '敘事抒情') {
        document.getElementById('writingBtn').click();
        setTimeout(() => {
            const select = document.getElementById('writingType');
            if (select) { select.value = '片段描寫'; toggleWritingType(); }
            const btn = document.querySelector('#topicSelectionArea .btn-custom');
            if(btn) btn.click();
            const titleInput = document.getElementById('customTitle') || document.getElementById('customTopic');
            if (titleInput) {
                titleInput.value = topic;
                titleInput.focus();
                alert(`題目「${topic}」已準備就緒，請開始寫作。`);
            }
        }, 800);
    } else if (type === '議論') {
        document.getElementById('argumentBtn').click();
        setTimeout(() => {
            const select = document.getElementById('argumentType');
            if (select) { select.value = 'writing'; toggleArgumentType(); }
            const btn = document.querySelector('#argumentTopicSelectionArea .btn-custom');
            if(btn) btn.click();
            const titleInput = document.getElementById('argumentCustomTopic');
            if (titleInput) {
                titleInput.value = topic;
                setArgumentCustomTopic();
                alert(`題目「${topic}」已鎖定。`);
            }
        }, 800);
    }
    // 可繼續擴充其他類型...
}

// === 核心：同步 IndexedDB 到 Firebase ===



// 1. 打開選擇視窗，列出該班級的有效作業
// === 繳交邏輯 1: 打開選擇視窗 ===
function openSubmitSelector(recordId) {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (!s) return alert("請先在「雲端同步」中綁定身份！");

    // 將紀錄 ID 存入隱藏欄位，稍後繳交時使用
    document.getElementById('pendingRecordId').value = recordId;
    document.getElementById('submitAssignmentModal').style.display = 'flex';
    
    const listDiv = document.getElementById('activeAssignmentList');
    listDiv.innerHTML = '<div style="text-align:center; padding: 20px;"><i class="fas fa-spinner fa-spin"></i> 正在讀取老師的課業列表...</div>';

    // 從 Firebase 讀取該班級的作業
    database.ref(`assignments/${s.grade}/${s.class}`).once('value', (snapshot) => {
        const data = snapshot.val();
        listDiv.innerHTML = '';

        if (!data) {
            listDiv.innerHTML = '<p style="color:#999; text-align:center;">目前老師沒有派發任何課業。</p>';
            return;
        }

        const keys = Object.keys(data).reverse(); // 新的在上面
        
        keys.forEach(key => {
            const task = data[key];
            const item = document.createElement('div');
            item.style.cssText = "padding: 15px; margin-bottom: 10px; background: #fff; border: 2px solid #eee; border-radius: 10px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: space-between;";
            
            item.innerHTML = `
                <div>
                    <div style="font-weight:bold; color:#333; font-size: 1.1rem; margin-bottom: 5px;">${task.topic}</div>
                    <div style="font-size:0.85em; color:#666;">
                        <span style="background:#e0f7fa; color:#006064; padding:2px 8px; border-radius:4px; font-weight:bold;">${task.type}</span>
                        ${new Date(task.timestamp).toLocaleDateString()}
                    </div>
                </div>
                <div style="color: #2A9689; font-size: 1.2rem;"><i class="fas fa-upload"></i></div>
            `;
            
            // 滑鼠效果
            item.onmouseover = function() { 
                this.style.borderColor = "#2A9689"; 
                this.style.background = "#f0fdfc"; 
                this.style.transform = "translateY(-2px)";
            };
            item.onmouseout = function() { 
                this.style.borderColor = "#eee"; 
                this.style.background = "#fff"; 
                this.style.transform = "translateY(0)";
            };
            
            // 點擊即繳交
            item.onclick = function() { confirmAndSubmitAssignment(key, task.topic); };
            
            listDiv.appendChild(item);
        });
    });
}

// ==========================================
// === 最終修復：繳交課業 + 刷新背景列表 ===
// ==========================================
 
async function confirmAndSubmitAssignment(assignmentId, assignmentTopic) {
    // 確保 ID 是整數
    const recordId = parseInt(document.getElementById('pendingRecordId').value);
    const s = JSON.parse(localStorage.getItem('studentProfile'));
 
    if (!confirm(`確定要將這份紀錄繳交為「${assignmentTopic}」嗎？\n(注意：這將會覆蓋你之前對此功課的繳交內容)`)) return;
 
    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(recordId);
 
        request.onsuccess = function(e) {
            const record = e.target.result;
            
            if (!record) return alert("錯誤：找不到原始紀錄 (ID: " + recordId + ")，請重新打開紀錄。");
 
            // 上傳路徑
            const submitPath = `assignments_submissions/${assignmentId}/${s.name}`;
            
            // 顯示載入中
            const modalBody = document.getElementById('activeAssignmentList');
            modalBody.innerHTML = '<div style="text-align:center; color:#2A9689; padding:20px;"><i class="fas fa-circle-notch fa-spin fa-2x"></i><br><br>正在呈交給老師...</div>';
 
            database.ref(submitPath).set({
                ...record, // 包含修訂後的 userContent 和 aiContent
                submittedAt: new Date().toLocaleString('zh-HK'),
                studentName: s.name,
                studentClass: s.class,
                studentGrade: s.grade
            }, async (error) => {
                if (error) {
                    alert("繳交失敗：" + error.message);
                    document.getElementById('submitAssignmentModal').style.display = 'none';
                } else {
                    alert(`🎉 繳交成功！\n\n已成功將此紀錄呈交為「${assignmentTopic}」。`);
                    document.getElementById('submitAssignmentModal').style.display = 'none';
                    
                    // 1. 執行同步 (這會導致 ID 變更)
                    await syncHistoryToFirebase(true);
 
                    // 2. ★★★ 關鍵新增：刷新背景列表 ★★★
                    // 這樣卡片的 ID 才會更新，您關閉視窗後點擊卡片才不會報錯
                    if (typeof currentSubFunctionFilter !== 'undefined' &&
                        document.getElementById('historyLevel3').style.display !== 'none') {
                        
                        const themeIndex = typeof currentThemeIndex !== 'undefined' ? currentThemeIndex : 1;
                        
                        // 靜默刷新列表
                        enterHistoryList(currentSubFunctionFilter, themeIndex);
                    }
                }
            });
        };
    } catch (err) {
        console.error(err);
        alert("系統錯誤，無法讀取紀錄。");
    }
}


// ==========================================
// === 學習報告選單邏輯 (新增) ===
// ==========================================

function openReportMenu() {
    document.getElementById('reportMenuModal').style.display = 'flex';
}

function closeReportMenu(event) {
    // 點擊背景才關閉，點擊內容不關閉
    if (event.target.id === 'reportMenuModal') {
        document.getElementById('reportMenuModal').style.display = 'none';
    }
}

function viewPastReports() {
    // 1. 關閉選單
    document.getElementById('reportMenuModal').style.display = 'none';
    
    // 2. 直接導航到「學習報告」範疇 -> 「綜合分析」列表
    // 假設我們在 HISTORY_STRUCTURE 定義了 "學習報告"
    // 傳入 5 代表使用第 5 種主題色 (奶茶棕)
    enterHistoryCategory('學習報告'); 
    setTimeout(() => {
        enterHistoryList('綜合分析', 5);
    }, 100);
}

// ==========================================
// === 全新功能：生成智能學習報告 (V7 - 數據化存檔版) ===
// ==========================================

async function generateHistoryReport() {
    // 關閉選單
    document.getElementById('reportMenuModal').style.display = 'none';

    const btn = document.querySelector('button[title="學習報告"]');
    if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    }

    console.log("1. 開始生成深度報告...");

    try {
        const db = await openHistoryDB();
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();

        request.onsuccess = async function(event) {
            const records = event.target.result;

            if (!records || records.length === 0) {
                alert("目前沒有足夠的歷史紀錄來生成報告，請先多做練習！");
                if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-chart-pie"></i>'; }
                return;
            }

            // === 1. 數據聚合 (保持不變) ===
            const stats = {
                "敘事抒情": { count: 0, scores: { content: 0, expression: 0, structure: 0 }, radar: { 立意: 0, 取材: 0, 扣題: 0, 詳略: 0, 詞彙: 0, 文學性: 0 }, snippets: [] },
                "議論": { count: 0, scores: { content: 0, expression: 0, structure: 0 }, radar: { 立意: 0, 取材: 0, 扣題: 0, 詳略: 0, 詞彙: 0, 文學性: 0 }, snippets: [] },
                "閱讀": { snippets: [] },
                "整合拓展": { snippets: [] }
            };

            const parser = new DOMParser();

            records.forEach(r => {
                if (!r.aiContent) return;
                const cleanText = r.aiContent.replace(/<[^>]*>?/gm, ' ');
                let snippet = "";
                const critiqueIndex = cleanText.indexOf("點評");
                const suggestionIndex = cleanText.indexOf("建議");
                if (critiqueIndex !== -1) snippet += "[評]" + cleanText.substring(critiqueIndex + 3, critiqueIndex + 60).trim();
                if (suggestionIndex !== -1) snippet += " [議]" + cleanText.substring(suggestionIndex + 3, suggestionIndex + 60).trim();
                const summary = `日期:${r.dateStr}|題目:${r.title}|${snippet}`;
                if (stats[r.category]) {
                    stats[r.category].snippets.push(summary);
                }
                if (r.category === "敘事抒情" || r.category === "議論") {
                    try {
                        const doc = parser.parseFromString(r.aiContent, 'text/html');
                        const contentInput = doc.querySelector('input[id*="ContentScore"]');
                        const exprInput = doc.querySelector('input[id*="ExpressionScore"]');
                        const structInput = doc.querySelector('input[id*="StructureScore"]');
                        if (contentInput && exprInput && structInput) {
                            stats[r.category].count++;
                            const c = parseInt(contentInput.value || 5);
                            const e = parseInt(exprInput.value || 5);
                            const s = parseInt(structInput.value || 5);
                            stats[r.category].scores.content += c;
                            stats[r.category].scores.expression += e;
                            stats[r.category].scores.structure += s;
                            stats[r.category].radar.立意 += (c * 0.6 + s * 0.4);
                            stats[r.category].radar.取材 += (c * 0.8 + e * 0.2);
                            stats[r.category].radar.扣題 += (c * 0.7 + s * 0.3);
                            stats[r.category].radar.詳略 += (s * 0.7 + c * 0.3);
                            stats[r.category].radar.詞彙 += e;
                            stats[r.category].radar.文學性 += e;
                        }
                    } catch (e) { }
                }
            });

            // === 2. 計算平均值 & 綜合等級 ===
            const finalStats = {};
            let globalTotalScore = 0;
            let globalCount = 0;

            ["敘事抒情", "議論"].forEach(cat => {
                const s = stats[cat];
                if (s.count > 0) {
                    finalStats[cat] = {
                        content: Math.round(s.scores.content / s.count),
                        expression: Math.round(s.scores.expression / s.count),
                        structure: Math.round(s.scores.structure / s.count),
                        radar: [
                            parseFloat((s.radar.立意 / s.count).toFixed(1)),
                            parseFloat((s.radar.取材 / s.count).toFixed(1)),
                            parseFloat((s.radar.扣題 / s.count).toFixed(1)),
                            parseFloat((s.radar.詳略 / s.count).toFixed(1)),
                            parseFloat((s.radar.詞彙 / s.count).toFixed(1)),
                            parseFloat((s.radar.文學性 / s.count).toFixed(1))
                        ]
                    };
                    const totalScore = (finalStats[cat].content * 4) + (finalStats[cat].expression * 3) + (finalStats[cat].structure * 2) + 8; // +5+3
                    finalStats[cat].total = Math.min(totalScore, 100);
                    finalStats[cat].level = determineGrade(finalStats[cat].total);
                    globalTotalScore += finalStats[cat].total * s.count;
                    globalCount += s.count;
                }
            });

            let overallLevel = "待定";
            if (globalCount > 0) {
                const avgGlobalScore = globalTotalScore / globalCount;
                overallLevel = determineGrade(avgGlobalScore);
            }

            // === 3. 構建 Prompt ===
            let promptData = "";
            let hasData = false;
            for (const [cat, data] of Object.entries(stats)) {
                if (data.snippets.length > 0) {
                    hasData = true;
                    promptData += `\n【${cat}】(最近紀錄):\n${data.snippets.slice(-5).join('\n')}\n`;
                }
            }

            if (!hasData) {
                alert("找不到有效的文字紀錄。");
                if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-chart-pie"></i>'; }
                return;
            }

            showLoading("陳SIR 正在生成學習報告...");

            // Prompt 結構
             const prompt = `你現在扮演一位資深的中文科老師「陳SIR」。請根據學生以下的歷史紀錄，生成一份「學習概況報告」。

### 學生歷史紀錄摘要：
${promptData}

### 你的任務：
綜合分析數據。**不要使用列點**，直接用流暢、溫暖、專業的段落文字分析。

### 輸出格式要求 (嚴格遵守 HTML)：
請直接輸出以下 HTML，不要用 Markdown。

1. **整體評語** (注意：請將綜合評級 ${overallLevel} 填入下方指定位置)：
   <div class="report-section">
       <div class="report-category-badge badge-general">
           <div class="badge-general-title"><i class="fas fa-user-graduate"></i> 整體學習概況</div>
           <div class="overall-grade-tag">
               <span class="overall-grade-label">綜合評級</span>
               <span>${overallLevel}</span>
           </div>
       </div>
       <div class="report-text-card">
           <p>(約100字整體鼓勵性評語，請提及學生目前的綜合水平 ${overallLevel})</p>
       </div>
   </div>
   
   <!-- 分隔線 -->
   <div class="report-separator"></div>

2. **分範疇分析**：(針對有數據的範疇)
   <div class="report-section">
       <div class="report-category-badge badge-[narrative/argument/reading/expand]"><i class="fas fa-book"></i> [範疇名稱]</div>
       <div class="report-text-card">
           <p>(詳細分析該範疇的強項與弱項)</p>
       </div>
   </div>
   *badge class: badge-narrative, badge-argument, badge-reading, badge-expand*

3. **陳SIR寄語**：
   <div class="report-quote-card">
       <div class="report-quote-content">「(金句內容)」</div>
       <div class="report-quote-author">—— 陳SIR</div>
   </div>`;

            // 呼叫 API
            const reportHTML = await callReadingAPI(prompt);

            // === 4. 組合與渲染 ===
            openResultCanvas("學習歷程報告");
            const resultBody = document.getElementById("resultCanvasBody");
            const today = new Date().toLocaleDateString('zh-HK');
            let finalOutput = `<div style="text-align:right; margin-bottom:20px; color:#aaa; font-size:0.9em;">報告日期：${today}</div>`;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = reportHTML;

            // 插入圖表結構
            ["敘事抒情", "議論"].forEach(cat => {
                const badgeClass = cat === "敘事抒情" ? ".badge-narrative" : ".badge-argument";
                const aiHeader = tempDiv.querySelector(badgeClass);
                
                if (finalStats[cat] && aiHeader) {
                    const sectionDiv = aiHeader.closest('.report-section');
                    const textCard = sectionDiv.querySelector('.report-text-card');
                    const aiText = textCard ? textCard.innerHTML : "";
                    const uniqueId = cat === "敘事抒情" ? "reportNarrative" : "reportArgument";

                    const chartHTML = `
                    <div class="report-section">
                        ${aiHeader.outerHTML}
                        <div class="report-radar-wrapper">
                            <div class="grading-container" style="margin:0; border:none; padding:0;">
                                <div class="grading-grid">
                                    <div class="grading-scores" style="padding:15px;">
                                        <h3>綜合能力評估 (平均)</h3>
                                        <div class="score-item"><label>內容 (40)</label><div class="slider-container"><div class="progress-bar-container"><div style="width:${finalStats[cat].content * 10}%" class="progress-bar-fill"></div></div><span class="score-display">${finalStats[cat].content * 4}</span></div></div>
                                        <div class="score-item"><label>表達 (30)</label><div class="slider-container"><div class="progress-bar-container"><div style="width:${finalStats[cat].expression * 10}%" class="progress-bar-fill"></div></div><span class="score-display">${finalStats[cat].expression * 3}</span></div></div>
                                        <div class="score-item"><label>結構 (20)</label><div class="slider-container"><div class="progress-bar-container"><div style="width:${finalStats[cat].structure * 10}%" class="progress-bar-fill"></div></div><span class="score-display">${finalStats[cat].structure * 2}</span></div></div>
                                        <div class="score-item"><label>標點字體 (10)</label><div class="slider-container"><div class="progress-bar-container"><div style="width:50%" class="progress-bar-fill"></div></div><span class="score-display">5</span></div></div>
                                        <div class="score-item"><label>錯別字 (+3)</label><div class="slider-container"><div class="progress-bar-container"><div style="width:100%" class="progress-bar-fill"></div></div><span class="score-display">3</span></div></div>
                                        <div class="total-score-container">
                                            <span style="font-size:1.1em; color:#555;">平均總分: ${finalStats[cat].total} / 100</span>
                                            <span style="font-size:2em; font-weight:bold; color:#d9534f; margin-left:auto;">${finalStats[cat].level}</span>
                                        </div>
                                    </div>
                                    <div class="grading-radar" style="padding:15px;">
                                        <h3>能力分佈</h3>
                                        <div class="radar-chart-container" style="height:250px;">
                                            <canvas id="${uniqueId}Chart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="report-text-card">
                            ${aiText}
                        </div>
                    </div>`;
                    sectionDiv.outerHTML = chartHTML;
                }
            });

            resultBody.innerHTML = finalOutput + tempDiv.innerHTML;

            // === 5. 渲染圖表並存檔 (重點修訂) ===
            setTimeout(() => {
                // 這裡保留原本的圖表渲染邏輯，讓學生當下看得到
                ["敘事抒情", "議論"].forEach(cat => {
                    if (finalStats[cat]) {
                        const uniqueId = cat === "敘事抒情" ? "reportNarrative" : "reportArgument";
                        const ctxEl = document.getElementById(`${uniqueId}Chart`);
                        if (ctxEl) {
                            new Chart(ctxEl.getContext('2d'), {
                                type: 'radar',
                                data: {
                                    labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
                                    datasets: [{
                                        label: '平均能力',
                                        data: finalStats[cat].radar,
                                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                                        borderColor: 'rgba(54, 162, 235, 1)',
                                        borderWidth: 2,
                                        pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                                        pointBorderColor: '#fff'
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        r: {
                                            angleLines: { display: true },
                                            suggestedMin: 0, suggestedMax: 10,
                                            pointLabels: { font: { size: 12, family: "'Noto Serif TC', serif" } },
                                            ticks: { stepSize: 2, display: false }
                                        }
                                    },
                                    plugins: { legend: { display: false } }
                                }
                            });
                        }
                    }
                });

                // ★★★ 存檔 (傳入 finalStats 作為原始數據) ★★★
                setTimeout(() => {
                    // captureContainerHTML 已經在外部修改為不轉圖片
                    const htmlToSave = captureContainerHTML('resultCanvasBody');
                    saveToHistory(
                        "學習報告", 
                        "綜合分析", 
                        `學習報告 (${today})`, 
                        `系統自動生成之學習歷程分析。\n綜合評級：${overallLevel}`, 
                        htmlToSave,
                        finalStats // ★★★ 關鍵：傳入報告的原始統計數據，讓老師端可以動態繪圖
                    );
                    console.log("報告已自動存檔並同步 (含數據)。");
                }, 500);

            }, 100);

            hideAllSaveHtmlButtons();
            
            // 強制顯示
            const canvas = document.getElementById("resultCanvas");
            const loadingOverlay = document.getElementById("loadingOverlay");
            if (loadingOverlay) loadingOverlay.style.display = 'none';
            if (canvas) {
                canvas.style.display = 'block';
                canvas.style.zIndex = '99999';
                document.body.style.overflow = 'hidden';
            }

        };

        request.onerror = function(e) { console.error("DB Error:", e); alert("讀取失敗"); hideLoading(); };

    } catch (error) {
        console.error("Report Error:", error);
        alert("生成失敗：" + error.message);
        hideLoading();
    } finally {
        if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-chart-pie"></i>'; }
    }
}
	
	
</script>

<footer class="copyright-footer">
<p>Copyright © 2025 陳冠健. All rights reserved.</p>
</footer>

<!-- === 大綱編輯懸浮視窗 (修正版) === -->
<!-- === 大綱編輯懸浮視窗 (修正版) === -->
<div id="outline-editor-modal" class="outline-modal-overlay">
    <div class="outline-modal-content">
        <h3 id="modal-title">編輯內容</h3>
        
        <!-- ★★★ 新增：懸浮視窗內的範文選擇器 (預設隱藏) ★★★ -->
        <select id="modal-template-select" style="display: none; margin-bottom: 10px; padding: 8px; font-size: 16px; border: 1px solid #2A9689; border-radius: 5px; background-color: #f0fdfc;">
            <option value="">指定範文</option>
        </select>
        <!-- ★★★ 新增結束 ★★★ -->

        <textarea id="modal-textarea" rows="15"></textarea>
        <div class="modal-buttons">
            <button id="modal-ocr-btn" class="btn-action" style="background-color: #17a2b8;">OCR</button>
            <button id="modal-save-btn" class="btn-action">輸入</button>
        </div>
        <button id="modal-close-btn" class="preview-close-btn" title="關閉">&times;</button>
    </div>
</div>
	<!-- 煙花特效畫布 -->
<canvas id="fireworksCanvas"></canvas>
<!-- 學生雲端中心 (修訂版：加入姓名輸入與指引) -->
<div id="studentCloudModal" class="books-modal">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeStudentCloudModal()">&times;</span>

        <!-- 身份設定表單 -->
        <div id="studentIdentityForm">
            
            <!-- 新增：標題與指引區塊 -->
       <div style="margin-bottom: 20px; border-bottom: 2px dashed #b0bec5; padding-bottom: 15px; text-align: center;">
    <h3 style="color: #546e7a; margin: 0 0 15px 0; font-size: 1.5em;">註冊帳號</h3>
    
    <div style="background-color: #e8ecef; padding: 15px; border-radius: 8px; text-align: center; color: #78909c; font-size: 0.95em; line-height: 1.6;">
        <div style="font-weight: bold; margin-bottom: 8px;">
            <i class="fas fa-info-circle"></i> 指引：
        </div>
        <div style="text-align: left; margin-top: 5px;">
            請先輸入您的<strong>中文姓名</strong>，並選擇正確的<strong>年級、班別及班號</strong>，確認無誤後，再點擊下方的「學校帳號登入」按鈕。
        </div>
    </div>
</div>

            <!-- 新增：姓名輸入欄位 -->
            <label style="font-weight: bold; color: #455a64;">姓名：</label>
            <input type="text" id="studentNameInput" class="no-modal-editor" placeholder="請輸入您的中文全名 (例如：陳大文)" 
                   style="width: 100%; padding: 10px; margin: 5px 0 15px 0; border: 1px solid #cfd8dc; border-radius: 8px; font-size: 1.1em;">

            <!--原有的選單 -->
            <div style="display: flex; gap: 10px;">
                <div style="flex: 1;">
                    <label style="font-weight: bold; color: #455a64;">年級：</label>
                    <select id="studentGrade" class="no-modal-editor">
                        <option value="1">中一</option><option value="2">中二</option><option value="3">中三</option>
                        <option value="4">中四</option><option value="5">中五</option><option value="6">中六</option>
                    </select>
                </div>
                <div style="flex: 1;">
                    <label style="font-weight: bold; color: #455a64;">班別：</label>
                    <select id="studentClass" class="no-modal-editor">
                        <option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option>
                    </select>
                </div>
            </div>

            <label style="font-weight: bold; color: #455a64;">班號：</label>
            <select id="studentNumber" class="no-modal-editor">
                <!-- JS 會自動填入選項 -->
            </select>

            <!-- 登入按鈕區塊 -->
            <div style="margin-top: 25px; padding: 20px; background: #fff; border: 2px solid #607d8b; border-radius: 12px; text-align: center;">
                <p style="color: #78909c; margin-bottom: 15px; font-size: 0.9em;">
                    系統將驗證您的 @ccckyc.edu.hk 學校電郵
                </p>
                
                <button class="btn-action" onclick="handleSchoolLogin()" 
                        style="width: 100%; background-color: #607d8b; border: none; padding: 12px; font-size: 1.1em; letter-spacing: 1px; box-shadow: 0 4px 10px rgba(96, 125, 139, 0.3);">
                    <i class="fab fa-google"></i> 學校帳號登入
                </button>
            </div>
        </div>

       <!-- 登入後顯示區域 -->
<div id="studentCloudPanel" style="display:none; margin-top:15px;">
    
    <!-- 修改處：將歡迎文字與登出按鈕放在同一個容器內 -->
    <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 10px;">
        <p id="welcomeText" style="font-weight:bold; color:#555; font-size:1.1em; margin: 0;"></p>
        
        <!-- 新增：圖案設計的登出鍵 -->
        <button class="logout-icon-btn" onclick="handleStudentLogout()" title="登出帳號">
            <i class="fas fa-sign-out-alt"></i>
        </button>
    </div>

    <div style="border-top: 1px dashed #ccc; margin: 15px 0; padding-top:10px;">
        <h4 style="margin-top:0; color:#2A9689;"><i class="fas fa-tasks"></i> 你的課業狀態</h4>
        <div id="assignmentList" style="max-height: 250px; overflow-y:auto; padding-right:5px;">
            載入中...
        </div>
    </div>
</div>
    </div>
</div>

      
        </div>
    </div>
</div>

<!-- 繳交功課選擇視窗 -->
<div id="submitAssignmentModal" class="books-modal" style="z-index: 2200;">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="document.getElementById('submitAssignmentModal').style.display='none'">&times;</span>
        <h3 style="color: #2A9689; border-bottom: 2px solid #eee; padding-bottom: 10px;">
            <i class="fas fa-paper-plane"></i> 繳交課業
        </h3>
        <p>請選擇這份紀錄屬於哪一份課業：</p>
        
        <!-- 這裡會動態載入老師開設的功課 -->
        <div id="activeAssignmentList" style="margin: 15px 0; max-height: 200px; overflow-y: auto;">
            載入中...
        </div>

        <input type="hidden" id="pendingRecordId"> <!-- 暫存要繳交的紀錄 ID -->
    </div>
</div>

	<!-- === 加載動畫覆蓋層 (新增) === -->
<!-- === 加載動畫覆蓋層 (含取消功能) === -->
<div id="loadingOverlay" class="loading-overlay">
    <div class="loading-content">
        <!-- 加載動畫圖片 -->
        <img src="生成中.gif" alt="Loading" class="loading-gif" id="loadingImage">
        <div class="loading-text" id="loadingText">正在思考中...</div>
 
        <!-- 1. 純圖示取消鍵 (低調優雅) -->
        <button id="cancelLoadingBtn" onclick="openCancelModal()" class="cancel-icon-btn" title="取消生成">
            <i class="fas fa-times"></i>
        </button>
    </div>
 
    <!-- 2. 莫蘭迪風格確認視窗 (預設隱藏) -->
    <div id="cancelConfirmModal" class="morandi-modal-overlay">
        <div class="morandi-modal-card">
            <h3 class="morandi-title">中斷思考？</h3>
            <p class="morandi-text">目前的生成進度將會遺失，<br>但您輸入的內容會保留。</p>
            <div class="morandi-btn-group">
                <!-- 繼續等待 (灰色) -->
                <button onclick="closeCancelModal()" class="morandi-btn btn-gray">繼續等待</button>
                <!-- 確認取消 (莫蘭迪紅) -->
                <button onclick="confirmCancel()" class="morandi-btn btn-red">確認取消</button>
            </div>
        </div>
    </div>
</div>

<!-- 新增的畫布 HTML -->
<div id="resultCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #fdfcf8; z-index: 30000; display: none; overflow-y: auto; font-family: 'Noto Serif TC', serif;">
    <div style="max-width: 900px; margin: 0 auto; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px 0; border-bottom: 2px solid #2A9689; margin-bottom: 20px; position: sticky; top: 0; background: #fdfcf8; z-index: 10;">
            <span id="resultCanvasTitle" style="font-size: 1.4rem; font-weight: bold; color: #2A9689;">生成結果</span>
            <button onclick="closeResultCanvas()" style="background-color: #d9534f; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-weight: bold;">
                <i class="fas fa-times"></i> 
            </button>
        </div>
        <div id="resultCanvasBody">
            <!-- 內容注入處 -->
        </div>
    </div>
</div>

	<script>
// ==========================================
// === 紅點邏輯修復補丁 (Fix Badge Logic) ===
// ==========================================

// 1. 定義一個全域變數來記住是否有未交功課
window.hasPendingWork = false;

// 2. 建立一個「統一」的紅點更新函式
// 邏輯：只要 (有未繳交功課 OR 有推播通知卡片)，紅點就應該亮起
function refreshGlobalBadge() {
    const badge = document.getElementById('notifBadge');
    const notifContainer = document.getElementById('notifContainer');
    
    if (!badge) return;

    // 檢查 A: 畫面上是否有推播通知卡片
    const hasVisibleNotifs = notifContainer && notifContainer.querySelectorAll('.sansi-notification').length > 0;

    // 檢查 B: 是否有未繳交功課 (由 monitorPendingAssignments 更新 window.hasPendingWork)
    const shouldShow = window.hasPendingWork || hasVisibleNotifs;

    if (shouldShow) {
        badge.style.display = 'block';
        
        // 優化提示文字 (Tooltip)
        if (window.hasPendingWork && hasVisibleNotifs) {
            badge.title = "您有新通知及未繳交的課業！";
        } else if (window.hasPendingWork) {
            badge.title = "您有未繳交的課業！";
        } else {
            badge.title = "您有新通知！";
        }
    } else {
        badge.style.display = 'none';
    }
}

// 3. 覆寫原有的 updateNotifBadge 函式
// 讓推播系統不再直接關閉紅點，而是透過統一函式檢查
window.updateNotifBadge = function() {
    refreshGlobalBadge();
};

// 4. 覆寫原有的 monitorPendingAssignments 函式
// 改為更新全域狀態變數，然後呼叫統一函式
if (typeof pendingMonitorRef !== 'undefined' && pendingMonitorRef) {
    pendingMonitorRef.off(); // 先移除舊的監聽器防止重複
}

window.monitorPendingAssignments = function() {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    
    // 如果沒有登入資料，就不監聽
    if (!s) return;

    // 移除舊的監聽 (如果存在)
    if (typeof pendingMonitorRef !== 'undefined' && pendingMonitorRef) {
        pendingMonitorRef.off();
    }

    // 設定監聽路徑
    pendingMonitorRef = database.ref(`assignments/${s.grade}/${s.class}`);

    pendingMonitorRef.on('value', async (snapshot) => {
        const assignments = snapshot.val();
        
        // 如果完全沒有功課資料
        if (!assignments) {
            window.hasPendingWork = false;
            refreshGlobalBadge();
            return;
        }

        const assignmentKeys = Object.keys(assignments);
        
        // 並行檢查每一份功課的繳交狀態
        const checkPromises = assignmentKeys.map(async (key) => {
            const subSnap = await database.ref(`assignments_submissions/${key}/${s.name}`).once('value');
            return subSnap.exists(); // true = 已交, false = 未交
        });

        const results = await Promise.all(checkPromises);

        // 更新全域狀態：只要有一個是 false，就代表有待辦事項
        window.hasPendingWork = results.includes(false);

        // 觸發 UI 更新
        refreshGlobalBadge();
    });
};

// 5. 確保在頁面重新整理或登入後立即重新啟動監聽
// (延遲執行以確保 Firebase 已就緒)
setTimeout(() => {
    const s = JSON.parse(localStorage.getItem('studentProfile'));
    if (s) {
        monitorPendingAssignments();
    }
}, 1500);

</script>



<!-- === [新增] 神思大數據收集模組 (Log 顯示修正版) === -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    let totalSeconds = 0;
    let timerInterval = null;

    // 1. 獲取日期路徑
    function getDatePath() {
        const now = new Date();
        const y = now.getFullYear();
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const d = String(now.getDate()).padStart(2, '0');
        return `${y}/${m}/${d}`;
    }

    // 2. 獲取或生成訪客唯一 ID
    function getGuestID() {
        let id = localStorage.getItem('sansi_guest_uuid');
        if (!id) {
            id = 'guest_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            localStorage.setItem('sansi_guest_uuid', id);
        }
        return id;
    }

    // 3. 記錄訪問 (Log Visit)
    function logVisitOnce() {
        if (typeof firebase === 'undefined') return;
        const db = firebase.database();
        const pathSuffix = getDatePath();
        const rawProfile = localStorage.getItem('studentProfile');
        let s = null;
        try { if(rawProfile) s = JSON.parse(rawProfile); } catch (e) {}

        let currentIdentityID = '';
        let isStudent = false;

        if (s && s.grade && s.class && s.name) {
            currentIdentityID = `student_${s.grade}${s.class}_${s.name}`;
            isStudent = true;
        } else {
            currentIdentityID = `guest_${getGuestID()}`;
            isStudent = false;
        }

        const lastLoggedID = sessionStorage.getItem('sansi_logged_identity_id');

        if (currentIdentityID === lastLoggedID) {
            return;
        }

        console.log(`📍 [System] 偵測到新身份訪問 (${isStudent ? '學生' : '訪客'}), 正在記錄...`);

        const incrementData = (path) => {
            db.ref(path).transaction(data => {
                if (data === null) return { visits: 1, duration: 0 };
                return { visits: (data.visits || 0) + 1, duration: (data.duration || 0) };
            });
        };

        if (isStudent) {
            incrementData(`analytics/${pathSuffix}/students/${s.grade}/${s.class}/${s.name}`);
            incrementData(`analytics/${pathSuffix}/classes/${s.grade}${s.class}`);
            incrementData(`analytics/${pathSuffix}/school`);
        } else {
            incrementData(`analytics/${pathSuffix}/guests/${getGuestID()}`);
        }

        if (!sessionStorage.getItem('sansi_global_visit_logged')) {
            incrementData(`analytics/${pathSuffix}/global_summary`);
            sessionStorage.setItem('sansi_global_visit_logged', 'true');
        }

        sessionStorage.setItem('sansi_logged_identity_id', currentIdentityID);
    }

    // 4. 上傳時間
    function uploadOneMinute() {
        // ★★★ 新增 Log：讓你知道上傳觸發了 ★★★
        console.log(`⬆️ [System] 觸發上傳機制 (目前累計逗留: ${totalSeconds} 秒)`);

        if (typeof firebase === 'undefined') return;
        
        logVisitOnce(); 

        const db = firebase.database();
        const pathSuffix = getDatePath();
        const rawProfile = localStorage.getItem('studentProfile');
        let s = null;
        try { if(rawProfile) s = JSON.parse(rawProfile); } catch (e) {}

        const add60s = (path) => {
            db.ref(path).transaction(data => {
                if (data === null) return { visits: 0, duration: 60 };
                return { visits: (data.visits || 0), duration: (data.duration || 0) + 60 };
            });
        };

        add60s(`analytics/${pathSuffix}/global_summary`);

        if (s && s.grade && s.class && s.name) {
            add60s(`analytics/${pathSuffix}/school`);
            add60s(`analytics/${pathSuffix}/classes/${s.grade}${s.class}`);
            add60s(`analytics/${pathSuffix}/students/${s.grade}/${s.class}/${s.name}`);
        } else {
            const guestID = getGuestID();
            add60s(`analytics/${pathSuffix}/guests/${guestID}`);
        }
    }

    // 5. 計時器啟動
    function startTimer() {
        if (timerInterval) return;
        
        console.log("▶️ [System] 計時器已啟動/恢復"); 

        timerInterval = setInterval(() => {
            totalSeconds++;
            
            // (選用) 如果你想每秒都看到跳動，可以打開下面這行註解，但會很吵
            // console.log("tick: " + totalSeconds);

            if (totalSeconds === 30 || (totalSeconds > 30 && (totalSeconds - 30) % 60 === 0)) {
                uploadOneMinute();
            }
        }, 1000);
    }

    function pauseTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
            // ★★★ 新增 Log：讓你知道暫停了 ★★★
            console.log("⏸️ [System] 頁面隱藏/切換，計時已暫停");
        }
    }

    setTimeout(logVisitOnce, 3000); 
    
    startTimer(); 

    // 偵測頁面切換
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') {
            pauseTimer();
        } else {
            startTimer();
        }
    });
    
    window.forceLogVisit = logVisitOnce;
});
</script>

	
<!-- ★★★ 請在這裡加入凍結按鈕的程式碼 ★★★ -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // 獲取雲端同步按鈕
    const cloudBtn = document.getElementById('sideMenuCloudBtn');
    
    if (cloudBtn) {
        // 1. 頁面載入時立即凍結 (套用變灰、無法點擊的樣式)
        cloudBtn.classList.add('btn-frozen');
        
        // (選用) 暫時改變 title 提示
        const originalTitle = cloudBtn.getAttribute('title') || '雲端同步';
        cloudBtn.setAttribute('title', '系統初始化中，請稍候...');

        // 2. 設定 5 秒後解凍
        setTimeout(() => {
            // 移除凍結樣式，恢復顏色與點擊功能
            cloudBtn.classList.remove('btn-frozen');
            
            // 恢復原本的提示文字
            cloudBtn.setAttribute('title', originalTitle);
        }, 5000); // 5000 毫秒 = 5 秒
    }
});
</script>
<!-- ★★★ 加入結束 ★★★ -->


<!-- === [修正版] 全局震動回饋 (加強力度 + 觸控優先) === -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    
    // 定義震動函數
    function triggerVibration() {
        // 檢查瀏覽器支援
        if (!navigator.vibrate) {
            console.log("此設備/瀏覽器不支援震動 API (如: iPhone)");
            return;
        }
        
        // 嘗試震動 50 毫秒 (比 10ms 更明顯)
        // 有些手機需要用戶曾經點擊過頁面至少一次才會開啟震動權限
        try {
            navigator.vibrate(35);
            console.log("觸發震動指令");
        } catch (e) {
            console.error("震動失敗", e);
        }
    }
 
    // 定義目標元素
  const interactiveSelectors = [
     
        '.anime-card',             // 主頁動漫卡片
        '.side-menu-item',         // 側邊選單項目
        '#homeBtn',                // 懸浮返回主頁鍵
        '.btn',                    // 生成/自訂題目按鈕
        '.btn-action',             // 提交/執行按鈕
        '.btn-icon-action',        // 圖示操作按鈕 (儲存/清空等)
        '.btn-icon-confirm',       // 圓形確認按鈕
        '.btn-save-html',          // 下載 HTML 按鈕
        '.history-folder-btn',     // 歷史紀錄資料夾
        '.history-card',           // 歷史紀錄卡片
        '.task-card',              // 雲端課業卡片
        '.logout-icon-btn',        // 登出按鈕
        'select'                   // 下拉選單
    ];

 
    // 使用 'touchstart' (手指按下瞬間) 而不是 'click'，反應會更快
    // 同時監聽 'mousedown' 以相容電腦滑鼠測試
    const triggerEvents = ['touchstart', 'mousedown'];
 
    triggerEvents.forEach(eventType => {
        document.body.addEventListener(eventType, function(e) {
            // 檢查點擊目標
            for (let selector of interactiveSelectors) {
                if (e.target.closest(selector)) {
                    triggerVibration();
                    // 不使用 break，確保複合元素也能觸發
                    return;
                }
            }
        }, { passive: true }); // passive: true 優化滾動效能
    });
});
</script>

	<script>
// ==========================================
// === 自動統一訪客額度提示 & 攔截雜訊 ===
// ==========================================
(function() {
    // 1. 設定一個全域旗標，用來標記「剛剛是否觸發了額度限制」
    window._isGuestLimitTriggered = false;

    // 2. 覆寫權限檢查函式 (Check Guest Usage Override)
    window.checkGuestUsage = function() {
        // A. 檢查是否已登入 (學生/老師/特許用家)
        const s = JSON.parse(localStorage.getItem('studentProfile'));
        if (s) return true; // 已登入，通過

        // B. 未登入訪客：檢查 LocalStorage 計數
        const today = new Date().toLocaleDateString('zh-HK');
        const storageKey = `sansi_guest_usage_${today}`;
        let currentCount = parseInt(localStorage.getItem(storageKey) || "0");

        // C. 如果超過額度 (上限 1 次)
        if (currentCount >= 1) {
            console.warn("[權限檢查] 攔截：超過每日額度。");
            
            // ★ 設定旗標：開啟「靜音模式」
            window._isGuestLimitTriggered = true;
            
            // ★ 統一彈出標準提示
            alert("⚠️ 訪客每日體驗額度已用完。\n\n請登入學校帳號或註冊。");
            
            // ★ 1秒後自動關閉「靜音模式」，恢復正常報錯功能
            setTimeout(() => { window._isGuestLimitTriggered = false; }, 1000);
            
            return false; // 阻止後續執行
        }

        // D. 增加計數
        localStorage.setItem(storageKey, currentCount + 1);
        return true;
    };

    // 3. 升級 Alert 函式 (過濾雜訊)
    // 這裡會包裝剛才寫好的莫蘭迪 Alert，增加過濾功能
    const _baseAlert = window.alert;

    window.alert = function(message) {
        const msgStr = String(message);

        // ★ 核心邏輯：如果處於「靜音模式」且 訊息不是「額度用完」的那條
        // 代表這是一條因為被擋下而產生的副作用報錯 (如 "API錯誤"、"生成失敗")
        // 我們直接將其攔截 (return)，不顯示出來
        if (window._isGuestLimitTriggered && !msgStr.includes("訪客每日體驗額度")) {
            console.log("已自動過濾重複的錯誤提示:", msgStr);
            return; 
        }

        // 否則，正常顯示
        _baseAlert(message);
    };
})();
</script>




<!-- === 新增：班號強制更新視窗 (莫蘭迪風格) === -->
<div id="classNumberUpdateModal" class="books-modal" style="z-index: 200000; background-color: rgba(253, 252, 248, 0.95); backdrop-filter: blur(5px);">
    <!-- ★★★ 修改處：加入 width: 85%; 以及 margin: auto; 確保手機版左右留白 ★★★ -->
    <div class="modal-content" style="width: 85%; max-width: 350px; text-align: center; border: 1px solid #e0ddd7; border-radius: 16px; box-shadow: 0 10px 30px rgba(141, 110, 99, 0.15); margin: auto;">
        
        <div style="margin-bottom: 20px;">
            <i class="fas fa-user-edit" style="font-size: 3rem; color: #8fa398; margin-bottom: 10px;"></i>
            <h3 style="color: #5e5e5e; margin: 0; font-size: 1.4rem;">更新班號</h3>
            <p style="color: #888; font-size: 0.95rem; margin-top: 10px;">新學年開始，請輸入您的新班號。</p>
        </div>
 
        <!-- 班號選擇器 -->
        <select id="newClassNumberSelect" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #ccc; font-size: 1.2rem; text-align: center; margin-bottom: 25px; background-color: #fff;">
            <!-- JS 會自動填入 1-35 -->
        </select>
 
        <button onclick="confirmClassNumberUpdate()" class="btn-action" style="width: 100%; justify-content: center; font-size: 1.1rem; padding: 12px; background-color: #8fa398; border: none; box-shadow: 0 4px 10px rgba(143, 163, 152, 0.4);">
            確認更新
        </button>
    </div>
</div>


<!-- === API 故障備用線路提示視窗 === -->
<div id="backupAlertModal" class="backup-alert-overlay">
    <div class="backup-alert-card">
        <div class="backup-alert-icon">
            <i class="fas fa-wifi"></i>
        </div>
        <div class="backup-alert-title">連線不穩</div>
        <div class="backup-alert-desc">
            系統偵測到多次連線異常。<br>
            建議切換至備用線路以確保體驗。
        </div>
        <div class="backup-btn-group">
            <button class="backup-btn btn-stay" onclick="closeBackupAlert()">稍後</button>
            <button class="backup-btn btn-switch" onclick="window.open('https://sansi.vercel.app/', '_blank'); closeBackupAlert();">
                <i class="fas fa-external-link-alt"></i> 前往
            </button>
        </div>
    </div>
</div>

	
	

</body>
</html>
